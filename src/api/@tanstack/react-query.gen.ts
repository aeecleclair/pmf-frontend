// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { deleteAdvertAdvertisersAdvertiserId, deleteAdvertAdvertsAdvertId, deleteAmapDeliveriesDeliveryId, deleteAmapDeliveriesDeliveryIdProducts, deleteAmapOrdersOrderId, deleteAmapProductsProductId, deleteBookingBookingsBookingId, deleteBookingManagersManagerId, deleteBookingRoomsRoomId, deleteCalendarEventsEventId, deleteCampaignLists, deleteCampaignListsListId, deleteCampaignSectionsSectionId, deleteCampaignVoters, deleteCampaignVotersGroupId, deleteCdrCurriculumsCurriculumId, deleteCdrSellersSellerId, deleteCdrSellersSellerIdDocumentsDocumentId, deleteCdrSellersSellerIdProductsProductId, deleteCdrSellersSellerIdProductsProductIdDataFieldId, deleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorId, deleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId, deleteCdrSellersSellerIdProductsProductIdVariantsVariantId, deleteCdrUsersUserIdCurriculumsCurriculumId, deleteCdrUsersUserIdPaymentsPaymentId, deleteCdrUsersUserIdPurchasesProductVariantId, deleteCdrUsersUserIdSignaturesDocumentId, deleteCinemaSessionsSessionId, deleteCompetitionGroupsGroupUsersUserId, deleteCompetitionLocationsLocationId, deleteCompetitionMatchesMatchId, deleteCompetitionParticipantsSportsSportIdCertificate, deleteCompetitionParticipantsUserIdSportsSportId, deleteCompetitionPodiumsSportsSportId, deleteCompetitionProductsProductId, deleteCompetitionProductsVariantsVariantId, deleteCompetitionPurchasesProductVariantId, deleteCompetitionSchoolsSchoolId, deleteCompetitionSchoolsSchoolIdProductQuotasProductId, deleteCompetitionSchoolsSchoolIdSportsSportIdQuotas, deleteCompetitionSportsSportId, deleteCompetitionSportsSportIdWithdraw, deleteCompetitionTeamsTeamId, deleteCompetitionUsersUserIdPaymentsPaymentId, deleteCompetitionVolunteersShiftsShiftId, deleteFlappybirdScoresTargetedUserId, deleteGroupsBatchMembership, deleteGroupsGroupId, deleteGroupsMembership, deleteLoansLoanersLoanerId, deleteLoansLoanersLoanerIdItemsItemId, deleteLoansLoanId, deleteMembershipsAssociationMembershipId, deleteMembershipsUsersMembershipId, deleteModuleVisibilityRootAccountTypesAccountType, deleteModuleVisibilityRootGroupsGroupId, deleteMyeclpayInvoicesInvoiceId, deleteMyeclpayStoresStoreId, deleteMyeclpayStoresStoreIdSellersSellerUserId, deleteMyeclpayStructuresStructureId, deleteNotificationDevicesFirebaseToken, deletePhonebookAssociationsAssociationId, deletePhonebookAssociationsMembershipsMembershipId, deletePhPaperId, deletePmfOfferOfferId, deletePmfTagTagId, deleteRaidTeams, deleteRaidTeamsTeamId, deleteRecommendationRecommendationsRecommendationId, deleteSchoolsSchoolId, deleteSeedLibraryPlantsPlantId, deleteSeedLibrarySpeciesSpeciesId, deleteTombolaPackTicketsPackticketId, deleteTombolaPrizesPrizeId, deleteTombolaRafflesRaffleId, getAdvertAdvertisers, getAdvertAdverts, getAdvertAdvertsAdvertId, getAdvertAdvertsAdvertIdPicture, getAdvertMeAdvertisers, getAmapDeliveries, getAmapDeliveriesDeliveryIdOrders, getAmapInformation, getAmapOrdersOrderId, getAmapProducts, getAmapProductsProductId, getAmapUsersCash, getAmapUsersUserIdCash, getAmapUsersUserIdOrders, getAuthAuthorize, getAuthUserinfo, getBookingBookingsConfirmed, getBookingBookingsConfirmedUsersMeManage, getBookingBookingsUsersMe, getBookingBookingsUsersMeManage, getBookingManagers, getBookingManagersUsersMe, getBookingRooms, getCalendarEvents, getCalendarEventsConfirmed, getCalendarEventsEventId, getCalendarEventsEventIdApplicant, getCalendarEventsUserApplicantId, getCalendarIcal, getCampaignLists, getCampaignListsListIdLogo, getCampaignResults, getCampaignSections, getCampaignStatsSectionId, getCampaignStatus, getCampaignVoters, getCampaignVotes, getCdrCurriculums, getCdrDocuments, getCdrMePurchases, getCdrOnlineProducts, getCdrOnlineSellers, getCdrOnlineSellersSellerIdProducts, getCdrProducts, getCdrSellers, getCdrSellersSellerIdDocuments, getCdrSellersSellerIdProducts, getCdrSellersSellerIdProductsProductIdData, getCdrSellersSellerIdProductsProductIdTagsGeneratorId, getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag, getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret, getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId, getCdrSellersSellerIdResults, getCdrSellersSellerIdUsersUserIdPurchases, getCdrSellersSellerIdUsersUserIdSignatures, getCdrStatus, getCdrUsers, getCdrUsersMeSellers, getCdrUsersMeTickets, getCdrUsersMeTicketsTicketIdSecret, getCdrUsersPending, getCdrUsersUserId, getCdrUsersUserIdPayments, getCdrUsersUserIdPurchases, getCdrUsersUserIdSignatures, getCdrUsersUserIdTickets, getCdrYear, getCinemaSessions, getCinemaSessionsSessionIdPoster, getCinemaThemoviedbThemoviedbId, getCompetitionEditions, getCompetitionEditionsActive, getCompetitionGroupsGroup, getCompetitionLocations, getCompetitionLocationsLocationId, getCompetitionMatches, getCompetitionMatchesSchoolsSchoolId, getCompetitionMatchesSportsSportId, getCompetitionParticipantsMe, getCompetitionParticipantsSchoolsSchoolId, getCompetitionParticipantsSportsSportId, getCompetitionParticipantsUsersUserIdCertificate, getCompetitionPaymentsSchoolsSchoolId, getCompetitionPodiumsGlobal, getCompetitionPodiumsSchoolsSchoolId, getCompetitionPodiumsSportsSportId, getCompetitionProducts, getCompetitionProductsAvailable, getCompetitionProductsProductIdSchoolsQuotas, getCompetitionPurchasesMe, getCompetitionPurchasesSchoolsSchoolId, getCompetitionPurchasesUsersUserId, getCompetitionSchools, getCompetitionSchoolsSchoolId, getCompetitionSchoolsSchoolIdGeneralQuota, getCompetitionSchoolsSchoolIdProductQuotas, getCompetitionSchoolsSchoolIdSportsQuotas, getCompetitionSports, getCompetitionSportsSportIdQuotas, getCompetitionTeams, getCompetitionTeamsMe, getCompetitionTeamsSchoolsSchoolId, getCompetitionTeamsSportsSportId, getCompetitionTeamsSportsSportIdSchoolsSchoolId, getCompetitionUsers, getCompetitionUsersDataExport, getCompetitionUsersMe, getCompetitionUsersMeGroups, getCompetitionUsersSchoolsSchoolId, getCompetitionUsersUserId, getCompetitionUsersUserIdGroups, getCompetitionUsersUserIdPayments, getCompetitionVolunteersMe, getCompetitionVolunteersShifts, getFaviconIco, getFlappybirdScores, getFlappybirdScoresMe, getGoogleApiOauth2Callback, getGroups, getGroupsGroupId, getInformation, getLoansLoaners, getLoansLoanersLoanerIdItems, getLoansLoanersLoanerIdLoans, getLoansUsersMe, getLoansUsersMeLoaners, getMemberships, getMembershipsAssociationMembershipIdMembers, getMembershipsUsersUserId, getMembershipsUsersUserIdAssociationMembershipId, getModuleVisibility, getModuleVisibilityMe, getMyeclpayBankAccountHolder, getMyeclpayDevicesActivate, getMyeclpayIntegrityCheck, getMyeclpayInvoices, getMyeclpayInvoicesInvoiceId, getMyeclpayInvoicesStructuresStructureId, getMyeclpayStoresStoreIdHistory, getMyeclpayStoresStoreIdSellers, getMyeclpayStructures, getMyeclpayStructuresConfirmManagerTransfer, getMyeclpayTermsOfService, getMyeclpayTransferRedirect, getMyeclpayUsersMeStores, getMyeclpayUsersMeTos, getMyeclpayUsersMeWallet, getMyeclpayUsersMeWalletDevices, getMyeclpayUsersMeWalletDevicesWalletDeviceId, getMyeclpayUsersMeWalletHistory, getNotificationDevices, getNotificationTopics, getOidcAuthorizationFlowJwksUri, getPh, getPhAdmin, getPhonebookAssociations, getPhonebookAssociationsAssociationIdMembers, getPhonebookAssociationsAssociationIdMembersMandateYear, getPhonebookAssociationsAssociationIdPicture, getPhonebookAssociationsKinds, getPhonebookMemberUserId, getPhonebookRoletags, getPhPaperIdCover, getPhPaperIdPdf, getPmfOffers, getPmfOffersOfferId, getPmfTags, getPmfTagTagId, getPrivacy, getRaidDocumentDocumentId, getRaidDrive, getRaidInformation, getRaidParticipantsParticipantId, getRaidParticipantsParticipantIdTeam, getRaidPay, getRaidPrice, getRaidSecurityFilesZip, getRaidTeamFilesZip, getRaidTeams, getRaidTeamsTeamId, getRecommendationRecommendations, getRecommendationRecommendationsRecommendationIdPicture, getRobotsTxt, getSchools, getSchoolsSchoolId, getSecurityTxt, getSeedLibraryInformation, getSeedLibraryPlantsPlantId, getSeedLibraryPlantsUsersMe, getSeedLibraryPlantsUsersUserId, getSeedLibraryPlantsWaiting, getSeedLibrarySpecies, getSeedLibrarySpeciesTypes, getStyleFileCss, getSupport, getTermsAndConditions, getTombolaGroupGroupIdRaffles, getTombolaPackTickets, getTombolaPrizes, getTombolaPrizesPrizeIdPicture, getTombolaRaffles, getTombolaRafflesRaffleIdLogo, getTombolaRafflesRaffleIdPackTickets, getTombolaRafflesRaffleIdPrizes, getTombolaRafflesRaffleIdStats, getTombolaRafflesRaffleIdTickets, getTombolaTickets, getTombolaUsersCash, getTombolaUsersUserIdCash, getTombolaUsersUserIdTickets, getUsers, getUsersAccountTypes, getUsersCount, getUsersMe, getUsersMeProfilePicture, getUsersMigrateMailConfirm, getUsersSearch, getUsersUserId, getUsersUserIdProfilePicture, getWellKnownOauthAuthorizationServer, getWellKnownOpenidConfiguration, getWellKnownSecurityTxt, type Options, patchAdvertAdvertisersAdvertiserId, patchAdvertAdvertsAdvertId, patchAmapDeliveriesDeliveryId, patchAmapInformation, patchAmapOrdersOrderId, patchAmapProductsProductId, patchAmapUsersUserIdCash, patchBookingBookingsBookingId, patchBookingBookingsBookingIdReplyDecision, patchBookingManagersManagerId, patchBookingRoomsRoomId, patchCalendarEventsEventId, patchCalendarEventsEventIdReplyDecision, patchCampaignListsListId, patchCdrSellersSellerId, patchCdrSellersSellerIdProductsProductId, patchCdrSellersSellerIdProductsProductIdDataFieldId, patchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret, patchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId, patchCdrSellersSellerIdProductsProductIdVariantsVariantId, patchCdrStatus, patchCdrUsersUserId, patchCdrUsersUserIdCurriculumsCurriculumId, patchCdrUsersUserIdPurchasesProductVariantIdValidated, patchCdrYear, patchCinemaSessionsSessionId, patchCompetitionEditionsEditionId, patchCompetitionLocationsLocationId, patchCompetitionMatchesMatchId, patchCompetitionParticipantsSportsSportIdUsersUserIdLicense, patchCompetitionProductsProductId, patchCompetitionProductsVariantsVariantId, patchCompetitionSchoolsSchoolId, patchCompetitionSchoolsSchoolIdGeneralQuota, patchCompetitionSchoolsSchoolIdProductQuotasProductId, patchCompetitionSchoolsSchoolIdSportsSportIdQuotas, patchCompetitionSportsSportId, patchCompetitionTeamsTeamId, patchCompetitionUsersMe, patchCompetitionUsersUserId, patchCompetitionUsersUserIdInvalidate, patchCompetitionUsersUserIdValidate, patchCompetitionVolunteersShiftsShiftId, patchGroupsGroupId, patchLoansLoanersLoanerId, patchLoansLoanersLoanerIdItemsItemId, patchLoansLoanId, patchMembershipsAssociationMembershipId, patchMembershipsUsersMembershipId, patchMyeclpayInvoicesInvoiceIdPaid, patchMyeclpayInvoicesInvoiceIdReceived, patchMyeclpayStoresStoreId, patchMyeclpayStoresStoreIdSellersSellerUserId, patchMyeclpayStructuresStructureId, patchPhonebookAssociationsAssociationId, patchPhonebookAssociationsAssociationIdDeactivate, patchPhonebookAssociationsAssociationIdGroups, patchPhonebookAssociationsMembershipsMembershipId, patchPhPaperId, patchRaidDrive, patchRaidInformation, patchRaidParticipantsParticipantId, patchRaidPrice, patchRaidTeamsTeamId, patchRecommendationRecommendationsRecommendationId, patchSchoolsSchoolId, patchSeedLibraryInformation, patchSeedLibraryPlantsPlantId, patchSeedLibraryPlantsPlantIdAdmin, patchSeedLibraryPlantsPlantIdBorrow, patchSeedLibrarySpeciesSpeciesId, patchTombolaPackTicketsPackticketId, patchTombolaPrizesPrizeId, patchTombolaRafflesRaffleId, patchTombolaRafflesRaffleIdLock, patchTombolaRafflesRaffleIdOpen, patchTombolaUsersUserIdCash, patchUsersMe, patchUsersUserId, postAdvertAdvertisers, postAdvertAdverts, postAdvertAdvertsAdvertIdPicture, postAmapDeliveries, postAmapDeliveriesDeliveryIdArchive, postAmapDeliveriesDeliveryIdDelivered, postAmapDeliveriesDeliveryIdLock, postAmapDeliveriesDeliveryIdOpenordering, postAmapDeliveriesDeliveryIdProducts, postAmapOrders, postAmapProducts, postAmapUsersUserIdCash, postAuthAuthorizationFlowAuthorizeValidation, postAuthAuthorize, postAuthIntrospect, postAuthSimpleToken, postAuthToken, postBookingBookings, postBookingManagers, postBookingRooms, postCalendarEvents, postCalendarIcalCreate, postCampaignLists, postCampaignListsListIdLogo, postCampaignSections, postCampaignStatusClose, postCampaignStatusCounting, postCampaignStatusOpen, postCampaignStatusPublished, postCampaignStatusReset, postCampaignVoters, postCampaignVotes, postCdrBatchPurchases, postCdrBatchValidation, postCdrCurriculums, postCdrPay, postCdrSellers, postCdrSellersSellerIdDocuments, postCdrSellersSellerIdProducts, postCdrSellersSellerIdProductsProductIdData, postCdrSellersSellerIdProductsProductIdTickets, postCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId, postCdrSellersSellerIdProductsProductIdVariants, postCdrUsersUserIdCurriculumsCurriculumId, postCdrUsersUserIdPayments, postCdrUsersUserIdPurchasesProductVariantId, postCdrUsersUserIdSignaturesDocumentId, postCinemaSessions, postCinemaSessionsSessionIdPoster, postCompetitionEditions, postCompetitionEditionsEditionIdActivate, postCompetitionEditionsEditionIdInscription, postCompetitionGroupsGroupUsersUserId, postCompetitionLocations, postCompetitionMatchesSportsSportId, postCompetitionParticipantsSportsSportIdCertificate, postCompetitionPay, postCompetitionPodiumsSportsSportId, postCompetitionProducts, postCompetitionProductsProductIdVariants, postCompetitionPurchasesMe, postCompetitionSchools, postCompetitionSchoolsSchoolIdGeneralQuota, postCompetitionSchoolsSchoolIdProductQuotas, postCompetitionSchoolsSchoolIdSportsSportIdQuotas, postCompetitionSports, postCompetitionSportsSportIdParticipate, postCompetitionTeams, postCompetitionUsers, postCompetitionUsersUserIdPayments, postCompetitionVolunteersShifts, postCompetitionVolunteersShiftsShiftIdRegister, postFlappybirdScores, postGroups, postGroupsBatchMembership, postGroupsMembership, postLoans, postLoansLoaners, postLoansLoanersLoanerIdItems, postLoansLoanIdExtend, postLoansLoanIdReturn, postMemberships, postMembershipsAssociationMembershipIdAddBatch, postMembershipsUsersUserId, postModuleVisibility, postMyeclpayBankAccountHolder, postMyeclpayInvoicesStructuresStructureId, postMyeclpayStoresStoreIdScan, postMyeclpayStoresStoreIdScanCheck, postMyeclpayStoresStoreIdSellers, postMyeclpayStructures, postMyeclpayStructuresStructureIdInitManagerTransfer, postMyeclpayStructuresStructureIdStores, postMyeclpayTransactionsTransactionIdCancel, postMyeclpayTransactionsTransactionIdRefund, postMyeclpayTransferInit, postMyeclpayUsersMeRegister, postMyeclpayUsersMeTos, postMyeclpayUsersMeWalletDevices, postMyeclpayUsersMeWalletDevicesWalletDeviceIdRevoke, postNotificationDevices, postNotificationSend, postNotificationTestSend, postNotificationTestSendFuture, postNotificationTestSendTopic, postNotificationTestSendTopicFuture, postNotificationTopicsTopicIdSubscribe, postNotificationTopicsTopicIdUnsubscribe, postPaymentHelloassoWebhook, postPh, postPhonebookAssociations, postPhonebookAssociationsAssociationIdPicture, postPhonebookAssociationsMemberships, postPhPaperIdPdf, postPmfOffer, postPmfTag, postRaidDocumentDocumentIdValidate, postRaidDocumentDocumentType, postRaidParticipantParticipantIdHonour, postRaidParticipantParticipantIdPayment, postRaidParticipantParticipantIdTShirtPayment, postRaidParticipants, postRaidSecurityFile, postRaidTeams, postRaidTeamsJoinToken, postRaidTeamsMerge, postRaidTeamsTeamIdInvite, postRaidTeamsTeamIdKickParticipantId, postRecommendationRecommendations, postRecommendationRecommendationsRecommendationIdPicture, postSchools, postSeedLibraryPlants, postSeedLibrarySpecies, postTombolaPackTickets, postTombolaPrizes, postTombolaPrizesPrizeIdDraw, postTombolaPrizesPrizeIdPicture, postTombolaRaffles, postTombolaRafflesRaffleIdLogo, postTombolaTicketsBuyPackId, postTombolaUsersUserIdCash, postUsersActivate, postUsersBatchCreation, postUsersChangePassword, postUsersCreate, postUsersMakeAdmin, postUsersMeAskDeletion, postUsersMeProfilePicture, postUsersMerge, postUsersMigrateMail, postUsersRecover, postUsersResetPassword, postUsersS3Init, putPmfOfferOfferId, putPmfTagTagId } from '../sdk.gen';
import type { DeleteAdvertAdvertisersAdvertiserIdData, DeleteAdvertAdvertisersAdvertiserIdError, DeleteAdvertAdvertisersAdvertiserIdResponse, DeleteAdvertAdvertsAdvertIdData, DeleteAdvertAdvertsAdvertIdError, DeleteAdvertAdvertsAdvertIdResponse, DeleteAmapDeliveriesDeliveryIdData, DeleteAmapDeliveriesDeliveryIdError, DeleteAmapDeliveriesDeliveryIdProductsData, DeleteAmapDeliveriesDeliveryIdProductsError, DeleteAmapDeliveriesDeliveryIdProductsResponse, DeleteAmapDeliveriesDeliveryIdResponse, DeleteAmapOrdersOrderIdData, DeleteAmapOrdersOrderIdError, DeleteAmapOrdersOrderIdResponse, DeleteAmapProductsProductIdData, DeleteAmapProductsProductIdError, DeleteAmapProductsProductIdResponse, DeleteBookingBookingsBookingIdData, DeleteBookingBookingsBookingIdError, DeleteBookingBookingsBookingIdResponse, DeleteBookingManagersManagerIdData, DeleteBookingManagersManagerIdError, DeleteBookingManagersManagerIdResponse, DeleteBookingRoomsRoomIdData, DeleteBookingRoomsRoomIdError, DeleteBookingRoomsRoomIdResponse, DeleteCalendarEventsEventIdData, DeleteCalendarEventsEventIdError, DeleteCalendarEventsEventIdResponse, DeleteCampaignListsData, DeleteCampaignListsError, DeleteCampaignListsListIdData, DeleteCampaignListsListIdError, DeleteCampaignListsListIdResponse, DeleteCampaignListsResponse, DeleteCampaignSectionsSectionIdData, DeleteCampaignSectionsSectionIdError, DeleteCampaignSectionsSectionIdResponse, DeleteCampaignVotersData, DeleteCampaignVotersGroupIdData, DeleteCampaignVotersGroupIdError, DeleteCampaignVotersGroupIdResponse, DeleteCampaignVotersResponse, DeleteCdrCurriculumsCurriculumIdData, DeleteCdrCurriculumsCurriculumIdError, DeleteCdrCurriculumsCurriculumIdResponse, DeleteCdrSellersSellerIdData, DeleteCdrSellersSellerIdDocumentsDocumentIdData, DeleteCdrSellersSellerIdDocumentsDocumentIdError, DeleteCdrSellersSellerIdDocumentsDocumentIdResponse, DeleteCdrSellersSellerIdError, DeleteCdrSellersSellerIdProductsProductIdData, DeleteCdrSellersSellerIdProductsProductIdDataFieldIdData, DeleteCdrSellersSellerIdProductsProductIdDataFieldIdError, DeleteCdrSellersSellerIdProductsProductIdDataFieldIdResponse, DeleteCdrSellersSellerIdProductsProductIdError, DeleteCdrSellersSellerIdProductsProductIdResponse, DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdData, DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdError, DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdResponse, DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData, DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdData, DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError, DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdResponse, DeleteCdrSellersSellerIdResponse, DeleteCdrUsersUserIdCurriculumsCurriculumIdData, DeleteCdrUsersUserIdCurriculumsCurriculumIdError, DeleteCdrUsersUserIdCurriculumsCurriculumIdResponse, DeleteCdrUsersUserIdPaymentsPaymentIdData, DeleteCdrUsersUserIdPaymentsPaymentIdError, DeleteCdrUsersUserIdPaymentsPaymentIdResponse, DeleteCdrUsersUserIdPurchasesProductVariantIdData, DeleteCdrUsersUserIdPurchasesProductVariantIdError, DeleteCdrUsersUserIdPurchasesProductVariantIdResponse, DeleteCdrUsersUserIdSignaturesDocumentIdData, DeleteCdrUsersUserIdSignaturesDocumentIdError, DeleteCdrUsersUserIdSignaturesDocumentIdResponse, DeleteCinemaSessionsSessionIdData, DeleteCinemaSessionsSessionIdError, DeleteCinemaSessionsSessionIdResponse, DeleteCompetitionGroupsGroupUsersUserIdData, DeleteCompetitionGroupsGroupUsersUserIdError, DeleteCompetitionGroupsGroupUsersUserIdResponse, DeleteCompetitionLocationsLocationIdData, DeleteCompetitionLocationsLocationIdError, DeleteCompetitionLocationsLocationIdResponse, DeleteCompetitionMatchesMatchIdData, DeleteCompetitionMatchesMatchIdError, DeleteCompetitionMatchesMatchIdResponse, DeleteCompetitionParticipantsSportsSportIdCertificateData, DeleteCompetitionParticipantsSportsSportIdCertificateError, DeleteCompetitionParticipantsSportsSportIdCertificateResponse, DeleteCompetitionParticipantsUserIdSportsSportIdData, DeleteCompetitionParticipantsUserIdSportsSportIdError, DeleteCompetitionParticipantsUserIdSportsSportIdResponse, DeleteCompetitionPodiumsSportsSportIdData, DeleteCompetitionPodiumsSportsSportIdError, DeleteCompetitionPodiumsSportsSportIdResponse, DeleteCompetitionProductsProductIdData, DeleteCompetitionProductsProductIdError, DeleteCompetitionProductsProductIdResponse, DeleteCompetitionProductsVariantsVariantIdData, DeleteCompetitionProductsVariantsVariantIdError, DeleteCompetitionProductsVariantsVariantIdResponse, DeleteCompetitionPurchasesProductVariantIdData, DeleteCompetitionPurchasesProductVariantIdError, DeleteCompetitionPurchasesProductVariantIdResponse, DeleteCompetitionSchoolsSchoolIdData, DeleteCompetitionSchoolsSchoolIdError, DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdData, DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdError, DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdResponse, DeleteCompetitionSchoolsSchoolIdResponse, DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasData, DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasError, DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, DeleteCompetitionSportsSportIdData, DeleteCompetitionSportsSportIdError, DeleteCompetitionSportsSportIdResponse, DeleteCompetitionSportsSportIdWithdrawData, DeleteCompetitionSportsSportIdWithdrawError, DeleteCompetitionSportsSportIdWithdrawResponse, DeleteCompetitionTeamsTeamIdData, DeleteCompetitionTeamsTeamIdError, DeleteCompetitionTeamsTeamIdResponse, DeleteCompetitionUsersUserIdPaymentsPaymentIdData, DeleteCompetitionUsersUserIdPaymentsPaymentIdError, DeleteCompetitionUsersUserIdPaymentsPaymentIdResponse, DeleteCompetitionVolunteersShiftsShiftIdData, DeleteCompetitionVolunteersShiftsShiftIdError, DeleteCompetitionVolunteersShiftsShiftIdResponse, DeleteFlappybirdScoresTargetedUserIdData, DeleteFlappybirdScoresTargetedUserIdError, DeleteFlappybirdScoresTargetedUserIdResponse, DeleteGroupsBatchMembershipData, DeleteGroupsBatchMembershipError, DeleteGroupsBatchMembershipResponse, DeleteGroupsGroupIdData, DeleteGroupsGroupIdError, DeleteGroupsGroupIdResponse, DeleteGroupsMembershipData, DeleteGroupsMembershipError, DeleteGroupsMembershipResponse, DeleteLoansLoanersLoanerIdData, DeleteLoansLoanersLoanerIdError, DeleteLoansLoanersLoanerIdItemsItemIdData, DeleteLoansLoanersLoanerIdItemsItemIdError, DeleteLoansLoanersLoanerIdItemsItemIdResponse, DeleteLoansLoanersLoanerIdResponse, DeleteLoansLoanIdData, DeleteLoansLoanIdError, DeleteLoansLoanIdResponse, DeleteMembershipsAssociationMembershipIdData, DeleteMembershipsAssociationMembershipIdError, DeleteMembershipsAssociationMembershipIdResponse, DeleteMembershipsUsersMembershipIdData, DeleteMembershipsUsersMembershipIdError, DeleteMembershipsUsersMembershipIdResponse, DeleteModuleVisibilityRootAccountTypesAccountTypeData, DeleteModuleVisibilityRootAccountTypesAccountTypeError, DeleteModuleVisibilityRootAccountTypesAccountTypeResponse, DeleteModuleVisibilityRootGroupsGroupIdData, DeleteModuleVisibilityRootGroupsGroupIdError, DeleteModuleVisibilityRootGroupsGroupIdResponse, DeleteMyeclpayInvoicesInvoiceIdData, DeleteMyeclpayInvoicesInvoiceIdError, DeleteMyeclpayInvoicesInvoiceIdResponse, DeleteMyeclpayStoresStoreIdData, DeleteMyeclpayStoresStoreIdError, DeleteMyeclpayStoresStoreIdResponse, DeleteMyeclpayStoresStoreIdSellersSellerUserIdData, DeleteMyeclpayStoresStoreIdSellersSellerUserIdError, DeleteMyeclpayStoresStoreIdSellersSellerUserIdResponse, DeleteMyeclpayStructuresStructureIdData, DeleteMyeclpayStructuresStructureIdError, DeleteMyeclpayStructuresStructureIdResponse, DeleteNotificationDevicesFirebaseTokenData, DeleteNotificationDevicesFirebaseTokenError, DeleteNotificationDevicesFirebaseTokenResponse, DeletePhonebookAssociationsAssociationIdData, DeletePhonebookAssociationsAssociationIdError, DeletePhonebookAssociationsAssociationIdResponse, DeletePhonebookAssociationsMembershipsMembershipIdData, DeletePhonebookAssociationsMembershipsMembershipIdError, DeletePhonebookAssociationsMembershipsMembershipIdResponse, DeletePhPaperIdData, DeletePhPaperIdError, DeletePhPaperIdResponse, DeletePmfOfferOfferIdData, DeletePmfOfferOfferIdError, DeletePmfOfferOfferIdResponse, DeletePmfTagTagIdData, DeletePmfTagTagIdError, DeletePmfTagTagIdResponse, DeleteRaidTeamsData, DeleteRaidTeamsResponse, DeleteRaidTeamsTeamIdData, DeleteRaidTeamsTeamIdError, DeleteRaidTeamsTeamIdResponse, DeleteRecommendationRecommendationsRecommendationIdData, DeleteRecommendationRecommendationsRecommendationIdError, DeleteRecommendationRecommendationsRecommendationIdResponse, DeleteSchoolsSchoolIdData, DeleteSchoolsSchoolIdError, DeleteSchoolsSchoolIdResponse, DeleteSeedLibraryPlantsPlantIdData, DeleteSeedLibraryPlantsPlantIdError, DeleteSeedLibraryPlantsPlantIdResponse, DeleteSeedLibrarySpeciesSpeciesIdData, DeleteSeedLibrarySpeciesSpeciesIdError, DeleteSeedLibrarySpeciesSpeciesIdResponse, DeleteTombolaPackTicketsPackticketIdData, DeleteTombolaPackTicketsPackticketIdError, DeleteTombolaPackTicketsPackticketIdResponse, DeleteTombolaPrizesPrizeIdData, DeleteTombolaPrizesPrizeIdError, DeleteTombolaPrizesPrizeIdResponse, DeleteTombolaRafflesRaffleIdData, DeleteTombolaRafflesRaffleIdError, DeleteTombolaRafflesRaffleIdResponse, GetAdvertAdvertisersData, GetAdvertAdvertisersResponse, GetAdvertAdvertsAdvertIdData, GetAdvertAdvertsAdvertIdError, GetAdvertAdvertsAdvertIdPictureData, GetAdvertAdvertsAdvertIdPictureError, GetAdvertAdvertsAdvertIdResponse, GetAdvertAdvertsData, GetAdvertAdvertsError, GetAdvertAdvertsResponse, GetAdvertMeAdvertisersData, GetAdvertMeAdvertisersResponse, GetAmapDeliveriesData, GetAmapDeliveriesDeliveryIdOrdersData, GetAmapDeliveriesDeliveryIdOrdersError, GetAmapDeliveriesDeliveryIdOrdersResponse, GetAmapDeliveriesResponse, GetAmapInformationData, GetAmapInformationResponse, GetAmapOrdersOrderIdData, GetAmapOrdersOrderIdError, GetAmapOrdersOrderIdResponse, GetAmapProductsData, GetAmapProductsProductIdData, GetAmapProductsProductIdError, GetAmapProductsProductIdResponse, GetAmapProductsResponse, GetAmapUsersCashData, GetAmapUsersCashResponse, GetAmapUsersUserIdCashData, GetAmapUsersUserIdCashError, GetAmapUsersUserIdCashResponse, GetAmapUsersUserIdOrdersData, GetAmapUsersUserIdOrdersError, GetAmapUsersUserIdOrdersResponse, GetAuthAuthorizeData, GetAuthAuthorizeError, GetAuthAuthorizeResponse, GetAuthUserinfoData, GetBookingBookingsConfirmedData, GetBookingBookingsConfirmedResponse, GetBookingBookingsConfirmedUsersMeManageData, GetBookingBookingsConfirmedUsersMeManageResponse, GetBookingBookingsUsersMeData, GetBookingBookingsUsersMeManageData, GetBookingBookingsUsersMeManageResponse, GetBookingBookingsUsersMeResponse, GetBookingManagersData, GetBookingManagersResponse, GetBookingManagersUsersMeData, GetBookingManagersUsersMeResponse, GetBookingRoomsData, GetBookingRoomsResponse, GetCalendarEventsConfirmedData, GetCalendarEventsConfirmedResponse, GetCalendarEventsData, GetCalendarEventsEventIdApplicantData, GetCalendarEventsEventIdApplicantError, GetCalendarEventsEventIdApplicantResponse, GetCalendarEventsEventIdData, GetCalendarEventsEventIdError, GetCalendarEventsEventIdResponse, GetCalendarEventsResponse, GetCalendarEventsUserApplicantIdData, GetCalendarEventsUserApplicantIdError, GetCalendarEventsUserApplicantIdResponse, GetCalendarIcalData, GetCampaignListsData, GetCampaignListsListIdLogoData, GetCampaignListsListIdLogoError, GetCampaignListsResponse, GetCampaignResultsData, GetCampaignResultsResponse, GetCampaignSectionsData, GetCampaignSectionsResponse, GetCampaignStatsSectionIdData, GetCampaignStatsSectionIdError, GetCampaignStatsSectionIdResponse, GetCampaignStatusData, GetCampaignStatusResponse, GetCampaignVotersData, GetCampaignVotersResponse, GetCampaignVotesData, GetCampaignVotesResponse, GetCdrCurriculumsData, GetCdrCurriculumsResponse, GetCdrDocumentsData, GetCdrDocumentsResponse, GetCdrMePurchasesData, GetCdrMePurchasesResponse, GetCdrOnlineProductsData, GetCdrOnlineProductsResponse, GetCdrOnlineSellersData, GetCdrOnlineSellersResponse, GetCdrOnlineSellersSellerIdProductsData, GetCdrOnlineSellersSellerIdProductsError, GetCdrOnlineSellersSellerIdProductsResponse, GetCdrProductsData, GetCdrProductsResponse, GetCdrSellersData, GetCdrSellersResponse, GetCdrSellersSellerIdDocumentsData, GetCdrSellersSellerIdDocumentsError, GetCdrSellersSellerIdDocumentsResponse, GetCdrSellersSellerIdProductsData, GetCdrSellersSellerIdProductsError, GetCdrSellersSellerIdProductsProductIdDataData, GetCdrSellersSellerIdProductsProductIdDataError, GetCdrSellersSellerIdProductsProductIdDataResponse, GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdData, GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdError, GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagData, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagError, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretData, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretResponse, GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData, GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, GetCdrSellersSellerIdProductsResponse, GetCdrSellersSellerIdResultsData, GetCdrSellersSellerIdResultsError, GetCdrSellersSellerIdUsersUserIdPurchasesData, GetCdrSellersSellerIdUsersUserIdPurchasesError, GetCdrSellersSellerIdUsersUserIdPurchasesResponse, GetCdrSellersSellerIdUsersUserIdSignaturesData, GetCdrSellersSellerIdUsersUserIdSignaturesError, GetCdrSellersSellerIdUsersUserIdSignaturesResponse, GetCdrStatusData, GetCdrStatusResponse, GetCdrUsersData, GetCdrUsersMeSellersData, GetCdrUsersMeSellersResponse, GetCdrUsersMeTicketsData, GetCdrUsersMeTicketsResponse, GetCdrUsersMeTicketsTicketIdSecretData, GetCdrUsersMeTicketsTicketIdSecretError, GetCdrUsersMeTicketsTicketIdSecretResponse, GetCdrUsersPendingData, GetCdrUsersPendingResponse, GetCdrUsersResponse, GetCdrUsersUserIdData, GetCdrUsersUserIdError, GetCdrUsersUserIdPaymentsData, GetCdrUsersUserIdPaymentsError, GetCdrUsersUserIdPaymentsResponse, GetCdrUsersUserIdPurchasesData, GetCdrUsersUserIdPurchasesError, GetCdrUsersUserIdPurchasesResponse, GetCdrUsersUserIdResponse, GetCdrUsersUserIdSignaturesData, GetCdrUsersUserIdSignaturesError, GetCdrUsersUserIdSignaturesResponse, GetCdrUsersUserIdTicketsData, GetCdrUsersUserIdTicketsError, GetCdrUsersUserIdTicketsResponse, GetCdrYearData, GetCdrYearResponse, GetCinemaSessionsData, GetCinemaSessionsResponse, GetCinemaSessionsSessionIdPosterData, GetCinemaSessionsSessionIdPosterError, GetCinemaThemoviedbThemoviedbIdData, GetCinemaThemoviedbThemoviedbIdError, GetCinemaThemoviedbThemoviedbIdResponse, GetCompetitionEditionsActiveData, GetCompetitionEditionsActiveResponse, GetCompetitionEditionsData, GetCompetitionEditionsResponse, GetCompetitionGroupsGroupData, GetCompetitionGroupsGroupError, GetCompetitionGroupsGroupResponse, GetCompetitionLocationsData, GetCompetitionLocationsLocationIdData, GetCompetitionLocationsLocationIdError, GetCompetitionLocationsLocationIdResponse, GetCompetitionLocationsResponse, GetCompetitionMatchesData, GetCompetitionMatchesResponse, GetCompetitionMatchesSchoolsSchoolIdData, GetCompetitionMatchesSchoolsSchoolIdError, GetCompetitionMatchesSchoolsSchoolIdResponse, GetCompetitionMatchesSportsSportIdData, GetCompetitionMatchesSportsSportIdError, GetCompetitionMatchesSportsSportIdResponse, GetCompetitionParticipantsMeData, GetCompetitionParticipantsMeResponse, GetCompetitionParticipantsSchoolsSchoolIdData, GetCompetitionParticipantsSchoolsSchoolIdError, GetCompetitionParticipantsSchoolsSchoolIdResponse, GetCompetitionParticipantsSportsSportIdData, GetCompetitionParticipantsSportsSportIdError, GetCompetitionParticipantsSportsSportIdResponse, GetCompetitionParticipantsUsersUserIdCertificateData, GetCompetitionParticipantsUsersUserIdCertificateError, GetCompetitionPaymentsSchoolsSchoolIdData, GetCompetitionPaymentsSchoolsSchoolIdError, GetCompetitionPaymentsSchoolsSchoolIdResponse, GetCompetitionPodiumsGlobalData, GetCompetitionPodiumsGlobalResponse, GetCompetitionPodiumsSchoolsSchoolIdData, GetCompetitionPodiumsSchoolsSchoolIdError, GetCompetitionPodiumsSchoolsSchoolIdResponse, GetCompetitionPodiumsSportsSportIdData, GetCompetitionPodiumsSportsSportIdError, GetCompetitionPodiumsSportsSportIdResponse, GetCompetitionProductsAvailableData, GetCompetitionProductsAvailableResponse, GetCompetitionProductsData, GetCompetitionProductsProductIdSchoolsQuotasData, GetCompetitionProductsProductIdSchoolsQuotasError, GetCompetitionProductsProductIdSchoolsQuotasResponse, GetCompetitionProductsResponse, GetCompetitionPurchasesMeData, GetCompetitionPurchasesMeResponse, GetCompetitionPurchasesSchoolsSchoolIdData, GetCompetitionPurchasesSchoolsSchoolIdError, GetCompetitionPurchasesSchoolsSchoolIdResponse, GetCompetitionPurchasesUsersUserIdData, GetCompetitionPurchasesUsersUserIdError, GetCompetitionPurchasesUsersUserIdResponse, GetCompetitionSchoolsData, GetCompetitionSchoolsResponse, GetCompetitionSchoolsSchoolIdData, GetCompetitionSchoolsSchoolIdError, GetCompetitionSchoolsSchoolIdGeneralQuotaData, GetCompetitionSchoolsSchoolIdGeneralQuotaError, GetCompetitionSchoolsSchoolIdGeneralQuotaResponse, GetCompetitionSchoolsSchoolIdProductQuotasData, GetCompetitionSchoolsSchoolIdProductQuotasError, GetCompetitionSchoolsSchoolIdProductQuotasResponse, GetCompetitionSchoolsSchoolIdResponse, GetCompetitionSchoolsSchoolIdSportsQuotasData, GetCompetitionSchoolsSchoolIdSportsQuotasError, GetCompetitionSchoolsSchoolIdSportsQuotasResponse, GetCompetitionSportsData, GetCompetitionSportsResponse, GetCompetitionSportsSportIdQuotasData, GetCompetitionSportsSportIdQuotasError, GetCompetitionSportsSportIdQuotasResponse, GetCompetitionTeamsData, GetCompetitionTeamsMeData, GetCompetitionTeamsMeResponse, GetCompetitionTeamsResponse, GetCompetitionTeamsSchoolsSchoolIdData, GetCompetitionTeamsSchoolsSchoolIdError, GetCompetitionTeamsSchoolsSchoolIdResponse, GetCompetitionTeamsSportsSportIdData, GetCompetitionTeamsSportsSportIdError, GetCompetitionTeamsSportsSportIdResponse, GetCompetitionTeamsSportsSportIdSchoolsSchoolIdData, GetCompetitionTeamsSportsSportIdSchoolsSchoolIdError, GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse, GetCompetitionUsersData, GetCompetitionUsersDataExportData, GetCompetitionUsersDataExportError, GetCompetitionUsersMeData, GetCompetitionUsersMeGroupsData, GetCompetitionUsersMeGroupsResponse, GetCompetitionUsersMeResponse, GetCompetitionUsersResponse, GetCompetitionUsersSchoolsSchoolIdData, GetCompetitionUsersSchoolsSchoolIdError, GetCompetitionUsersSchoolsSchoolIdResponse, GetCompetitionUsersUserIdData, GetCompetitionUsersUserIdError, GetCompetitionUsersUserIdGroupsData, GetCompetitionUsersUserIdGroupsError, GetCompetitionUsersUserIdGroupsResponse, GetCompetitionUsersUserIdPaymentsData, GetCompetitionUsersUserIdPaymentsError, GetCompetitionUsersUserIdPaymentsResponse, GetCompetitionUsersUserIdResponse, GetCompetitionVolunteersMeData, GetCompetitionVolunteersMeResponse, GetCompetitionVolunteersShiftsData, GetCompetitionVolunteersShiftsResponse, GetFaviconIcoData, GetFlappybirdScoresData, GetFlappybirdScoresMeData, GetFlappybirdScoresMeResponse, GetFlappybirdScoresResponse, GetGoogleApiOauth2CallbackData, GetGroupsData, GetGroupsGroupIdData, GetGroupsGroupIdError, GetGroupsGroupIdResponse, GetGroupsResponse, GetInformationData, GetInformationResponse, GetLoansLoanersData, GetLoansLoanersLoanerIdItemsData, GetLoansLoanersLoanerIdItemsError, GetLoansLoanersLoanerIdItemsResponse, GetLoansLoanersLoanerIdLoansData, GetLoansLoanersLoanerIdLoansError, GetLoansLoanersLoanerIdLoansResponse, GetLoansLoanersResponse, GetLoansUsersMeData, GetLoansUsersMeError, GetLoansUsersMeLoanersData, GetLoansUsersMeLoanersResponse, GetLoansUsersMeResponse, GetMembershipsAssociationMembershipIdMembersData, GetMembershipsAssociationMembershipIdMembersError, GetMembershipsAssociationMembershipIdMembersResponse, GetMembershipsData, GetMembershipsResponse, GetMembershipsUsersUserIdAssociationMembershipIdData, GetMembershipsUsersUserIdAssociationMembershipIdError, GetMembershipsUsersUserIdAssociationMembershipIdResponse, GetMembershipsUsersUserIdData, GetMembershipsUsersUserIdError, GetMembershipsUsersUserIdResponse, GetModuleVisibilityData, GetModuleVisibilityMeData, GetModuleVisibilityMeResponse, GetModuleVisibilityResponse, GetMyeclpayBankAccountHolderData, GetMyeclpayBankAccountHolderResponse, GetMyeclpayDevicesActivateData, GetMyeclpayDevicesActivateError, GetMyeclpayIntegrityCheckData, GetMyeclpayIntegrityCheckError, GetMyeclpayIntegrityCheckResponse, GetMyeclpayInvoicesData, GetMyeclpayInvoicesError, GetMyeclpayInvoicesInvoiceIdData, GetMyeclpayInvoicesInvoiceIdError, GetMyeclpayInvoicesResponse, GetMyeclpayInvoicesStructuresStructureIdData, GetMyeclpayInvoicesStructuresStructureIdError, GetMyeclpayInvoicesStructuresStructureIdResponse, GetMyeclpayStoresStoreIdHistoryData, GetMyeclpayStoresStoreIdHistoryError, GetMyeclpayStoresStoreIdHistoryResponse, GetMyeclpayStoresStoreIdSellersData, GetMyeclpayStoresStoreIdSellersError, GetMyeclpayStoresStoreIdSellersResponse, GetMyeclpayStructuresConfirmManagerTransferData, GetMyeclpayStructuresConfirmManagerTransferError, GetMyeclpayStructuresData, GetMyeclpayStructuresResponse, GetMyeclpayTermsOfServiceData, GetMyeclpayTransferRedirectData, GetMyeclpayTransferRedirectError, GetMyeclpayTransferRedirectResponse, GetMyeclpayUsersMeStoresData, GetMyeclpayUsersMeStoresResponse, GetMyeclpayUsersMeTosData, GetMyeclpayUsersMeTosResponse, GetMyeclpayUsersMeWalletData, GetMyeclpayUsersMeWalletDevicesData, GetMyeclpayUsersMeWalletDevicesResponse, GetMyeclpayUsersMeWalletDevicesWalletDeviceIdData, GetMyeclpayUsersMeWalletDevicesWalletDeviceIdError, GetMyeclpayUsersMeWalletDevicesWalletDeviceIdResponse, GetMyeclpayUsersMeWalletHistoryData, GetMyeclpayUsersMeWalletHistoryError, GetMyeclpayUsersMeWalletHistoryResponse, GetMyeclpayUsersMeWalletResponse, GetNotificationDevicesData, GetNotificationDevicesError, GetNotificationDevicesResponse, GetNotificationTopicsData, GetNotificationTopicsResponse, GetOidcAuthorizationFlowJwksUriData, GetPhAdminData, GetPhAdminResponse, GetPhData, GetPhonebookAssociationsAssociationIdMembersData, GetPhonebookAssociationsAssociationIdMembersError, GetPhonebookAssociationsAssociationIdMembersMandateYearData, GetPhonebookAssociationsAssociationIdMembersMandateYearError, GetPhonebookAssociationsAssociationIdMembersMandateYearResponse, GetPhonebookAssociationsAssociationIdMembersResponse, GetPhonebookAssociationsAssociationIdPictureData, GetPhonebookAssociationsAssociationIdPictureError, GetPhonebookAssociationsData, GetPhonebookAssociationsKindsData, GetPhonebookAssociationsKindsResponse, GetPhonebookAssociationsResponse, GetPhonebookMemberUserIdData, GetPhonebookMemberUserIdError, GetPhonebookMemberUserIdResponse, GetPhonebookRoletagsData, GetPhonebookRoletagsResponse, GetPhPaperIdCoverData, GetPhPaperIdCoverError, GetPhPaperIdPdfData, GetPhPaperIdPdfError, GetPhResponse, GetPmfOffersData, GetPmfOffersError, GetPmfOffersOfferIdData, GetPmfOffersOfferIdError, GetPmfOffersOfferIdResponse, GetPmfOffersResponse, GetPmfTagsData, GetPmfTagsResponse, GetPmfTagTagIdData, GetPmfTagTagIdError, GetPmfTagTagIdResponse, GetPrivacyData, GetRaidDocumentDocumentIdData, GetRaidDocumentDocumentIdError, GetRaidDriveData, GetRaidDriveResponse, GetRaidInformationData, GetRaidInformationResponse, GetRaidParticipantsParticipantIdData, GetRaidParticipantsParticipantIdError, GetRaidParticipantsParticipantIdResponse, GetRaidParticipantsParticipantIdTeamData, GetRaidParticipantsParticipantIdTeamError, GetRaidParticipantsParticipantIdTeamResponse, GetRaidPayData, GetRaidPayResponse, GetRaidPriceData, GetRaidPriceResponse, GetRaidSecurityFilesZipData, GetRaidTeamFilesZipData, GetRaidTeamsData, GetRaidTeamsResponse, GetRaidTeamsTeamIdData, GetRaidTeamsTeamIdError, GetRaidTeamsTeamIdResponse, GetRecommendationRecommendationsData, GetRecommendationRecommendationsRecommendationIdPictureData, GetRecommendationRecommendationsRecommendationIdPictureError, GetRecommendationRecommendationsResponse, GetRobotsTxtData, GetSchoolsData, GetSchoolsResponse, GetSchoolsSchoolIdData, GetSchoolsSchoolIdError, GetSchoolsSchoolIdResponse, GetSecurityTxtData, GetSeedLibraryInformationData, GetSeedLibraryInformationResponse, GetSeedLibraryPlantsPlantIdData, GetSeedLibraryPlantsPlantIdError, GetSeedLibraryPlantsPlantIdResponse, GetSeedLibraryPlantsUsersMeData, GetSeedLibraryPlantsUsersMeResponse, GetSeedLibraryPlantsUsersUserIdData, GetSeedLibraryPlantsUsersUserIdError, GetSeedLibraryPlantsUsersUserIdResponse, GetSeedLibraryPlantsWaitingData, GetSeedLibraryPlantsWaitingResponse, GetSeedLibrarySpeciesData, GetSeedLibrarySpeciesResponse, GetSeedLibrarySpeciesTypesData, GetSeedLibrarySpeciesTypesResponse, GetStyleFileCssData, GetStyleFileCssError, GetSupportData, GetTermsAndConditionsData, GetTombolaGroupGroupIdRafflesData, GetTombolaGroupGroupIdRafflesError, GetTombolaGroupGroupIdRafflesResponse, GetTombolaPackTicketsData, GetTombolaPackTicketsResponse, GetTombolaPrizesData, GetTombolaPrizesPrizeIdPictureData, GetTombolaPrizesPrizeIdPictureError, GetTombolaPrizesResponse, GetTombolaRafflesData, GetTombolaRafflesRaffleIdLogoData, GetTombolaRafflesRaffleIdLogoError, GetTombolaRafflesRaffleIdPackTicketsData, GetTombolaRafflesRaffleIdPackTicketsError, GetTombolaRafflesRaffleIdPackTicketsResponse, GetTombolaRafflesRaffleIdPrizesData, GetTombolaRafflesRaffleIdPrizesError, GetTombolaRafflesRaffleIdPrizesResponse, GetTombolaRafflesRaffleIdStatsData, GetTombolaRafflesRaffleIdStatsError, GetTombolaRafflesRaffleIdStatsResponse, GetTombolaRafflesRaffleIdTicketsData, GetTombolaRafflesRaffleIdTicketsError, GetTombolaRafflesRaffleIdTicketsResponse, GetTombolaRafflesResponse, GetTombolaTicketsData, GetTombolaTicketsResponse, GetTombolaUsersCashData, GetTombolaUsersCashResponse, GetTombolaUsersUserIdCashData, GetTombolaUsersUserIdCashError, GetTombolaUsersUserIdCashResponse, GetTombolaUsersUserIdTicketsData, GetTombolaUsersUserIdTicketsError, GetTombolaUsersUserIdTicketsResponse, GetUsersAccountTypesData, GetUsersAccountTypesResponse, GetUsersCountData, GetUsersCountResponse, GetUsersData, GetUsersError, GetUsersMeData, GetUsersMeProfilePictureData, GetUsersMeResponse, GetUsersMigrateMailConfirmData, GetUsersMigrateMailConfirmError, GetUsersResponse, GetUsersSearchData, GetUsersSearchError, GetUsersSearchResponse, GetUsersUserIdData, GetUsersUserIdError, GetUsersUserIdProfilePictureData, GetUsersUserIdProfilePictureError, GetUsersUserIdResponse, GetWellKnownOauthAuthorizationServerData, GetWellKnownOpenidConfigurationData, GetWellKnownSecurityTxtData, PatchAdvertAdvertisersAdvertiserIdData, PatchAdvertAdvertisersAdvertiserIdError, PatchAdvertAdvertisersAdvertiserIdResponse, PatchAdvertAdvertsAdvertIdData, PatchAdvertAdvertsAdvertIdError, PatchAdvertAdvertsAdvertIdResponse, PatchAmapDeliveriesDeliveryIdData, PatchAmapDeliveriesDeliveryIdError, PatchAmapDeliveriesDeliveryIdResponse, PatchAmapInformationData, PatchAmapInformationError, PatchAmapInformationResponse, PatchAmapOrdersOrderIdData, PatchAmapOrdersOrderIdError, PatchAmapOrdersOrderIdResponse, PatchAmapProductsProductIdData, PatchAmapProductsProductIdError, PatchAmapProductsProductIdResponse, PatchAmapUsersUserIdCashData, PatchAmapUsersUserIdCashError, PatchAmapUsersUserIdCashResponse, PatchBookingBookingsBookingIdData, PatchBookingBookingsBookingIdError, PatchBookingBookingsBookingIdReplyDecisionData, PatchBookingBookingsBookingIdReplyDecisionError, PatchBookingBookingsBookingIdReplyDecisionResponse, PatchBookingBookingsBookingIdResponse, PatchBookingManagersManagerIdData, PatchBookingManagersManagerIdError, PatchBookingManagersManagerIdResponse, PatchBookingRoomsRoomIdData, PatchBookingRoomsRoomIdError, PatchBookingRoomsRoomIdResponse, PatchCalendarEventsEventIdData, PatchCalendarEventsEventIdError, PatchCalendarEventsEventIdReplyDecisionData, PatchCalendarEventsEventIdReplyDecisionError, PatchCalendarEventsEventIdReplyDecisionResponse, PatchCalendarEventsEventIdResponse, PatchCampaignListsListIdData, PatchCampaignListsListIdError, PatchCampaignListsListIdResponse, PatchCdrSellersSellerIdData, PatchCdrSellersSellerIdError, PatchCdrSellersSellerIdProductsProductIdData, PatchCdrSellersSellerIdProductsProductIdDataFieldIdData, PatchCdrSellersSellerIdProductsProductIdDataFieldIdError, PatchCdrSellersSellerIdProductsProductIdDataFieldIdResponse, PatchCdrSellersSellerIdProductsProductIdError, PatchCdrSellersSellerIdProductsProductIdResponse, PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretData, PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError, PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretResponse, PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData, PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdData, PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError, PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdResponse, PatchCdrSellersSellerIdResponse, PatchCdrStatusData, PatchCdrStatusError, PatchCdrStatusResponse, PatchCdrUsersUserIdCurriculumsCurriculumIdData, PatchCdrUsersUserIdCurriculumsCurriculumIdError, PatchCdrUsersUserIdCurriculumsCurriculumIdResponse, PatchCdrUsersUserIdData, PatchCdrUsersUserIdError, PatchCdrUsersUserIdPurchasesProductVariantIdValidatedData, PatchCdrUsersUserIdPurchasesProductVariantIdValidatedError, PatchCdrUsersUserIdPurchasesProductVariantIdValidatedResponse, PatchCdrUsersUserIdResponse, PatchCdrYearData, PatchCdrYearError, PatchCdrYearResponse, PatchCinemaSessionsSessionIdData, PatchCinemaSessionsSessionIdError, PatchCompetitionEditionsEditionIdData, PatchCompetitionEditionsEditionIdError, PatchCompetitionEditionsEditionIdResponse, PatchCompetitionLocationsLocationIdData, PatchCompetitionLocationsLocationIdError, PatchCompetitionLocationsLocationIdResponse, PatchCompetitionMatchesMatchIdData, PatchCompetitionMatchesMatchIdError, PatchCompetitionMatchesMatchIdResponse, PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseData, PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseError, PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseResponse, PatchCompetitionProductsProductIdData, PatchCompetitionProductsProductIdError, PatchCompetitionProductsProductIdResponse, PatchCompetitionProductsVariantsVariantIdData, PatchCompetitionProductsVariantsVariantIdError, PatchCompetitionProductsVariantsVariantIdResponse, PatchCompetitionSchoolsSchoolIdData, PatchCompetitionSchoolsSchoolIdError, PatchCompetitionSchoolsSchoolIdGeneralQuotaData, PatchCompetitionSchoolsSchoolIdGeneralQuotaError, PatchCompetitionSchoolsSchoolIdGeneralQuotaResponse, PatchCompetitionSchoolsSchoolIdProductQuotasProductIdData, PatchCompetitionSchoolsSchoolIdProductQuotasProductIdError, PatchCompetitionSchoolsSchoolIdProductQuotasProductIdResponse, PatchCompetitionSchoolsSchoolIdResponse, PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasData, PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasError, PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, PatchCompetitionSportsSportIdData, PatchCompetitionSportsSportIdError, PatchCompetitionSportsSportIdResponse, PatchCompetitionTeamsTeamIdData, PatchCompetitionTeamsTeamIdError, PatchCompetitionTeamsTeamIdResponse, PatchCompetitionUsersMeData, PatchCompetitionUsersMeError, PatchCompetitionUsersMeResponse, PatchCompetitionUsersUserIdData, PatchCompetitionUsersUserIdError, PatchCompetitionUsersUserIdInvalidateData, PatchCompetitionUsersUserIdInvalidateError, PatchCompetitionUsersUserIdInvalidateResponse, PatchCompetitionUsersUserIdResponse, PatchCompetitionUsersUserIdValidateData, PatchCompetitionUsersUserIdValidateError, PatchCompetitionUsersUserIdValidateResponse, PatchCompetitionVolunteersShiftsShiftIdData, PatchCompetitionVolunteersShiftsShiftIdError, PatchCompetitionVolunteersShiftsShiftIdResponse, PatchGroupsGroupIdData, PatchGroupsGroupIdError, PatchGroupsGroupIdResponse, PatchLoansLoanersLoanerIdData, PatchLoansLoanersLoanerIdError, PatchLoansLoanersLoanerIdItemsItemIdData, PatchLoansLoanersLoanerIdItemsItemIdError, PatchLoansLoanersLoanerIdItemsItemIdResponse, PatchLoansLoanersLoanerIdResponse, PatchLoansLoanIdData, PatchLoansLoanIdError, PatchLoansLoanIdResponse, PatchMembershipsAssociationMembershipIdData, PatchMembershipsAssociationMembershipIdError, PatchMembershipsAssociationMembershipIdResponse, PatchMembershipsUsersMembershipIdData, PatchMembershipsUsersMembershipIdError, PatchMembershipsUsersMembershipIdResponse, PatchMyeclpayInvoicesInvoiceIdPaidData, PatchMyeclpayInvoicesInvoiceIdPaidError, PatchMyeclpayInvoicesInvoiceIdPaidResponse, PatchMyeclpayInvoicesInvoiceIdReceivedData, PatchMyeclpayInvoicesInvoiceIdReceivedError, PatchMyeclpayInvoicesInvoiceIdReceivedResponse, PatchMyeclpayStoresStoreIdData, PatchMyeclpayStoresStoreIdError, PatchMyeclpayStoresStoreIdResponse, PatchMyeclpayStoresStoreIdSellersSellerUserIdData, PatchMyeclpayStoresStoreIdSellersSellerUserIdError, PatchMyeclpayStoresStoreIdSellersSellerUserIdResponse, PatchMyeclpayStructuresStructureIdData, PatchMyeclpayStructuresStructureIdError, PatchMyeclpayStructuresStructureIdResponse, PatchPhonebookAssociationsAssociationIdData, PatchPhonebookAssociationsAssociationIdDeactivateData, PatchPhonebookAssociationsAssociationIdDeactivateError, PatchPhonebookAssociationsAssociationIdDeactivateResponse, PatchPhonebookAssociationsAssociationIdError, PatchPhonebookAssociationsAssociationIdGroupsData, PatchPhonebookAssociationsAssociationIdGroupsError, PatchPhonebookAssociationsAssociationIdGroupsResponse, PatchPhonebookAssociationsAssociationIdResponse, PatchPhonebookAssociationsMembershipsMembershipIdData, PatchPhonebookAssociationsMembershipsMembershipIdError, PatchPhonebookAssociationsMembershipsMembershipIdResponse, PatchPhPaperIdData, PatchPhPaperIdError, PatchPhPaperIdResponse, PatchRaidDriveData, PatchRaidDriveError, PatchRaidDriveResponse, PatchRaidInformationData, PatchRaidInformationError, PatchRaidInformationResponse, PatchRaidParticipantsParticipantIdData, PatchRaidParticipantsParticipantIdError, PatchRaidParticipantsParticipantIdResponse, PatchRaidPriceData, PatchRaidPriceError, PatchRaidPriceResponse, PatchRaidTeamsTeamIdData, PatchRaidTeamsTeamIdError, PatchRaidTeamsTeamIdResponse, PatchRecommendationRecommendationsRecommendationIdData, PatchRecommendationRecommendationsRecommendationIdError, PatchRecommendationRecommendationsRecommendationIdResponse, PatchSchoolsSchoolIdData, PatchSchoolsSchoolIdError, PatchSchoolsSchoolIdResponse, PatchSeedLibraryInformationData, PatchSeedLibraryInformationError, PatchSeedLibraryInformationResponse, PatchSeedLibraryPlantsPlantIdAdminData, PatchSeedLibraryPlantsPlantIdAdminError, PatchSeedLibraryPlantsPlantIdAdminResponse, PatchSeedLibraryPlantsPlantIdBorrowData, PatchSeedLibraryPlantsPlantIdBorrowError, PatchSeedLibraryPlantsPlantIdBorrowResponse, PatchSeedLibraryPlantsPlantIdData, PatchSeedLibraryPlantsPlantIdError, PatchSeedLibraryPlantsPlantIdResponse, PatchSeedLibrarySpeciesSpeciesIdData, PatchSeedLibrarySpeciesSpeciesIdError, PatchSeedLibrarySpeciesSpeciesIdResponse, PatchTombolaPackTicketsPackticketIdData, PatchTombolaPackTicketsPackticketIdError, PatchTombolaPackTicketsPackticketIdResponse, PatchTombolaPrizesPrizeIdData, PatchTombolaPrizesPrizeIdError, PatchTombolaPrizesPrizeIdResponse, PatchTombolaRafflesRaffleIdData, PatchTombolaRafflesRaffleIdError, PatchTombolaRafflesRaffleIdLockData, PatchTombolaRafflesRaffleIdLockError, PatchTombolaRafflesRaffleIdLockResponse, PatchTombolaRafflesRaffleIdOpenData, PatchTombolaRafflesRaffleIdOpenError, PatchTombolaRafflesRaffleIdOpenResponse, PatchTombolaRafflesRaffleIdResponse, PatchTombolaUsersUserIdCashData, PatchTombolaUsersUserIdCashError, PatchTombolaUsersUserIdCashResponse, PatchUsersMeData, PatchUsersMeError, PatchUsersMeResponse, PatchUsersUserIdData, PatchUsersUserIdError, PatchUsersUserIdResponse, PostAdvertAdvertisersData, PostAdvertAdvertisersError, PostAdvertAdvertisersResponse, PostAdvertAdvertsAdvertIdPictureData, PostAdvertAdvertsAdvertIdPictureError, PostAdvertAdvertsAdvertIdPictureResponse, PostAdvertAdvertsData, PostAdvertAdvertsError, PostAdvertAdvertsResponse, PostAmapDeliveriesData, PostAmapDeliveriesDeliveryIdArchiveData, PostAmapDeliveriesDeliveryIdArchiveError, PostAmapDeliveriesDeliveryIdArchiveResponse, PostAmapDeliveriesDeliveryIdDeliveredData, PostAmapDeliveriesDeliveryIdDeliveredError, PostAmapDeliveriesDeliveryIdDeliveredResponse, PostAmapDeliveriesDeliveryIdLockData, PostAmapDeliveriesDeliveryIdLockError, PostAmapDeliveriesDeliveryIdLockResponse, PostAmapDeliveriesDeliveryIdOpenorderingData, PostAmapDeliveriesDeliveryIdOpenorderingError, PostAmapDeliveriesDeliveryIdOpenorderingResponse, PostAmapDeliveriesDeliveryIdProductsData, PostAmapDeliveriesDeliveryIdProductsError, PostAmapDeliveriesError, PostAmapDeliveriesResponse, PostAmapOrdersData, PostAmapOrdersError, PostAmapOrdersResponse, PostAmapProductsData, PostAmapProductsError, PostAmapProductsResponse, PostAmapUsersUserIdCashData, PostAmapUsersUserIdCashError, PostAmapUsersUserIdCashResponse, PostAuthAuthorizationFlowAuthorizeValidationData, PostAuthAuthorizationFlowAuthorizeValidationError, PostAuthAuthorizeData, PostAuthAuthorizeError, PostAuthAuthorizeResponse, PostAuthIntrospectData, PostAuthIntrospectError, PostAuthIntrospectResponse, PostAuthSimpleTokenData, PostAuthSimpleTokenError, PostAuthSimpleTokenResponse, PostAuthTokenData, PostAuthTokenError, PostAuthTokenResponse, PostBookingBookingsData, PostBookingBookingsError, PostBookingBookingsResponse, PostBookingManagersData, PostBookingManagersError, PostBookingManagersResponse, PostBookingRoomsData, PostBookingRoomsError, PostBookingRoomsResponse, PostCalendarEventsData, PostCalendarEventsError, PostCalendarEventsResponse, PostCalendarIcalCreateData, PostCalendarIcalCreateResponse, PostCampaignListsData, PostCampaignListsError, PostCampaignListsListIdLogoData, PostCampaignListsListIdLogoError, PostCampaignListsListIdLogoResponse, PostCampaignListsResponse, PostCampaignSectionsData, PostCampaignSectionsError, PostCampaignSectionsResponse, PostCampaignStatusCloseData, PostCampaignStatusCloseResponse, PostCampaignStatusCountingData, PostCampaignStatusCountingResponse, PostCampaignStatusOpenData, PostCampaignStatusOpenResponse, PostCampaignStatusPublishedData, PostCampaignStatusPublishedResponse, PostCampaignStatusResetData, PostCampaignStatusResetResponse, PostCampaignVotersData, PostCampaignVotersError, PostCampaignVotersResponse, PostCampaignVotesData, PostCampaignVotesError, PostCampaignVotesResponse, PostCdrBatchPurchasesData, PostCdrBatchPurchasesError, PostCdrBatchValidationData, PostCdrBatchValidationError, PostCdrCurriculumsData, PostCdrCurriculumsError, PostCdrCurriculumsResponse, PostCdrPayData, PostCdrPayResponse, PostCdrSellersData, PostCdrSellersError, PostCdrSellersResponse, PostCdrSellersSellerIdDocumentsData, PostCdrSellersSellerIdDocumentsError, PostCdrSellersSellerIdDocumentsResponse, PostCdrSellersSellerIdProductsData, PostCdrSellersSellerIdProductsError, PostCdrSellersSellerIdProductsProductIdDataData, PostCdrSellersSellerIdProductsProductIdDataError, PostCdrSellersSellerIdProductsProductIdDataResponse, PostCdrSellersSellerIdProductsProductIdTicketsData, PostCdrSellersSellerIdProductsProductIdTicketsError, PostCdrSellersSellerIdProductsProductIdTicketsResponse, PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData, PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, PostCdrSellersSellerIdProductsProductIdVariantsData, PostCdrSellersSellerIdProductsProductIdVariantsError, PostCdrSellersSellerIdProductsProductIdVariantsResponse, PostCdrSellersSellerIdProductsResponse, PostCdrUsersUserIdCurriculumsCurriculumIdData, PostCdrUsersUserIdCurriculumsCurriculumIdError, PostCdrUsersUserIdPaymentsData, PostCdrUsersUserIdPaymentsError, PostCdrUsersUserIdPaymentsResponse, PostCdrUsersUserIdPurchasesProductVariantIdData, PostCdrUsersUserIdPurchasesProductVariantIdError, PostCdrUsersUserIdPurchasesProductVariantIdResponse, PostCdrUsersUserIdSignaturesDocumentIdData, PostCdrUsersUserIdSignaturesDocumentIdError, PostCdrUsersUserIdSignaturesDocumentIdResponse, PostCinemaSessionsData, PostCinemaSessionsError, PostCinemaSessionsResponse, PostCinemaSessionsSessionIdPosterData, PostCinemaSessionsSessionIdPosterError, PostCinemaSessionsSessionIdPosterResponse, PostCompetitionEditionsData, PostCompetitionEditionsEditionIdActivateData, PostCompetitionEditionsEditionIdActivateError, PostCompetitionEditionsEditionIdActivateResponse, PostCompetitionEditionsEditionIdInscriptionData, PostCompetitionEditionsEditionIdInscriptionError, PostCompetitionEditionsEditionIdInscriptionResponse, PostCompetitionEditionsError, PostCompetitionEditionsResponse, PostCompetitionGroupsGroupUsersUserIdData, PostCompetitionGroupsGroupUsersUserIdError, PostCompetitionGroupsGroupUsersUserIdResponse, PostCompetitionLocationsData, PostCompetitionLocationsError, PostCompetitionLocationsResponse, PostCompetitionMatchesSportsSportIdData, PostCompetitionMatchesSportsSportIdError, PostCompetitionMatchesSportsSportIdResponse, PostCompetitionParticipantsSportsSportIdCertificateData, PostCompetitionParticipantsSportsSportIdCertificateError, PostCompetitionParticipantsSportsSportIdCertificateResponse, PostCompetitionPayData, PostCompetitionPayResponse, PostCompetitionPodiumsSportsSportIdData, PostCompetitionPodiumsSportsSportIdError, PostCompetitionPodiumsSportsSportIdResponse, PostCompetitionProductsData, PostCompetitionProductsError, PostCompetitionProductsProductIdVariantsData, PostCompetitionProductsProductIdVariantsError, PostCompetitionProductsProductIdVariantsResponse, PostCompetitionProductsResponse, PostCompetitionPurchasesMeData, PostCompetitionPurchasesMeError, PostCompetitionPurchasesMeResponse, PostCompetitionSchoolsData, PostCompetitionSchoolsError, PostCompetitionSchoolsResponse, PostCompetitionSchoolsSchoolIdGeneralQuotaData, PostCompetitionSchoolsSchoolIdGeneralQuotaError, PostCompetitionSchoolsSchoolIdGeneralQuotaResponse, PostCompetitionSchoolsSchoolIdProductQuotasData, PostCompetitionSchoolsSchoolIdProductQuotasError, PostCompetitionSchoolsSchoolIdProductQuotasResponse, PostCompetitionSchoolsSchoolIdSportsSportIdQuotasData, PostCompetitionSchoolsSchoolIdSportsSportIdQuotasError, PostCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, PostCompetitionSportsData, PostCompetitionSportsError, PostCompetitionSportsResponse, PostCompetitionSportsSportIdParticipateData, PostCompetitionSportsSportIdParticipateError, PostCompetitionSportsSportIdParticipateResponse, PostCompetitionTeamsData, PostCompetitionTeamsError, PostCompetitionTeamsResponse, PostCompetitionUsersData, PostCompetitionUsersError, PostCompetitionUsersResponse, PostCompetitionUsersUserIdPaymentsData, PostCompetitionUsersUserIdPaymentsError, PostCompetitionUsersUserIdPaymentsResponse, PostCompetitionVolunteersShiftsData, PostCompetitionVolunteersShiftsError, PostCompetitionVolunteersShiftsResponse, PostCompetitionVolunteersShiftsShiftIdRegisterData, PostCompetitionVolunteersShiftsShiftIdRegisterError, PostCompetitionVolunteersShiftsShiftIdRegisterResponse, PostFlappybirdScoresData, PostFlappybirdScoresError, PostFlappybirdScoresResponse, PostGroupsBatchMembershipData, PostGroupsBatchMembershipError, PostGroupsBatchMembershipResponse, PostGroupsData, PostGroupsError, PostGroupsMembershipData, PostGroupsMembershipError, PostGroupsMembershipResponse, PostGroupsResponse, PostLoansData, PostLoansError, PostLoansLoanersData, PostLoansLoanersError, PostLoansLoanersLoanerIdItemsData, PostLoansLoanersLoanerIdItemsError, PostLoansLoanersLoanerIdItemsResponse, PostLoansLoanersResponse, PostLoansLoanIdExtendData, PostLoansLoanIdExtendError, PostLoansLoanIdExtendResponse, PostLoansLoanIdReturnData, PostLoansLoanIdReturnError, PostLoansLoanIdReturnResponse, PostLoansResponse, PostMembershipsAssociationMembershipIdAddBatchData, PostMembershipsAssociationMembershipIdAddBatchError, PostMembershipsAssociationMembershipIdAddBatchResponse, PostMembershipsData, PostMembershipsError, PostMembershipsResponse, PostMembershipsUsersUserIdData, PostMembershipsUsersUserIdError, PostMembershipsUsersUserIdResponse, PostModuleVisibilityData, PostModuleVisibilityError, PostMyeclpayBankAccountHolderData, PostMyeclpayBankAccountHolderError, PostMyeclpayBankAccountHolderResponse, PostMyeclpayInvoicesStructuresStructureIdData, PostMyeclpayInvoicesStructuresStructureIdError, PostMyeclpayInvoicesStructuresStructureIdResponse, PostMyeclpayStoresStoreIdScanCheckData, PostMyeclpayStoresStoreIdScanCheckError, PostMyeclpayStoresStoreIdScanCheckResponse, PostMyeclpayStoresStoreIdScanData, PostMyeclpayStoresStoreIdScanError, PostMyeclpayStoresStoreIdSellersData, PostMyeclpayStoresStoreIdSellersError, PostMyeclpayStoresStoreIdSellersResponse, PostMyeclpayStructuresData, PostMyeclpayStructuresError, PostMyeclpayStructuresResponse, PostMyeclpayStructuresStructureIdInitManagerTransferData, PostMyeclpayStructuresStructureIdInitManagerTransferError, PostMyeclpayStructuresStructureIdStoresData, PostMyeclpayStructuresStructureIdStoresError, PostMyeclpayStructuresStructureIdStoresResponse, PostMyeclpayTransactionsTransactionIdCancelData, PostMyeclpayTransactionsTransactionIdCancelError, PostMyeclpayTransactionsTransactionIdCancelResponse, PostMyeclpayTransactionsTransactionIdRefundData, PostMyeclpayTransactionsTransactionIdRefundError, PostMyeclpayTransactionsTransactionIdRefundResponse, PostMyeclpayTransferInitData, PostMyeclpayTransferInitError, PostMyeclpayTransferInitResponse, PostMyeclpayUsersMeRegisterData, PostMyeclpayUsersMeRegisterResponse, PostMyeclpayUsersMeTosData, PostMyeclpayUsersMeTosError, PostMyeclpayUsersMeTosResponse, PostMyeclpayUsersMeWalletDevicesData, PostMyeclpayUsersMeWalletDevicesError, PostMyeclpayUsersMeWalletDevicesResponse, PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeData, PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeError, PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeResponse, PostNotificationDevicesData, PostNotificationDevicesError, PostNotificationDevicesResponse, PostNotificationSendData, PostNotificationSendError, PostNotificationSendResponse, PostNotificationTestSendData, PostNotificationTestSendError, PostNotificationTestSendFutureData, PostNotificationTestSendFutureError, PostNotificationTestSendFutureResponse, PostNotificationTestSendTopicData, PostNotificationTestSendTopicFutureData, PostNotificationTestSendTopicFutureResponse, PostNotificationTestSendTopicResponse, PostNotificationTopicsTopicIdSubscribeData, PostNotificationTopicsTopicIdSubscribeError, PostNotificationTopicsTopicIdSubscribeResponse, PostNotificationTopicsTopicIdUnsubscribeData, PostNotificationTopicsTopicIdUnsubscribeError, PostNotificationTopicsTopicIdUnsubscribeResponse, PostPaymentHelloassoWebhookData, PostPaymentHelloassoWebhookResponse, PostPhData, PostPhError, PostPhonebookAssociationsAssociationIdPictureData, PostPhonebookAssociationsAssociationIdPictureError, PostPhonebookAssociationsAssociationIdPictureResponse, PostPhonebookAssociationsData, PostPhonebookAssociationsError, PostPhonebookAssociationsMembershipsData, PostPhonebookAssociationsMembershipsError, PostPhonebookAssociationsMembershipsResponse, PostPhonebookAssociationsResponse, PostPhPaperIdPdfData, PostPhPaperIdPdfError, PostPhResponse, PostPmfOfferData, PostPmfOfferError, PostPmfOfferResponse, PostPmfTagData, PostPmfTagError, PostPmfTagResponse, PostRaidDocumentDocumentIdValidateData, PostRaidDocumentDocumentIdValidateError, PostRaidDocumentDocumentIdValidateResponse, PostRaidDocumentDocumentTypeData, PostRaidDocumentDocumentTypeError, PostRaidDocumentDocumentTypeResponse, PostRaidParticipantParticipantIdHonourData, PostRaidParticipantParticipantIdHonourError, PostRaidParticipantParticipantIdHonourResponse, PostRaidParticipantParticipantIdPaymentData, PostRaidParticipantParticipantIdPaymentError, PostRaidParticipantParticipantIdPaymentResponse, PostRaidParticipantParticipantIdTShirtPaymentData, PostRaidParticipantParticipantIdTShirtPaymentError, PostRaidParticipantParticipantIdTShirtPaymentResponse, PostRaidParticipantsData, PostRaidParticipantsError, PostRaidParticipantsResponse, PostRaidSecurityFileData, PostRaidSecurityFileError, PostRaidSecurityFileResponse, PostRaidTeamsData, PostRaidTeamsError, PostRaidTeamsJoinTokenData, PostRaidTeamsJoinTokenError, PostRaidTeamsJoinTokenResponse, PostRaidTeamsMergeData, PostRaidTeamsMergeError, PostRaidTeamsMergeResponse, PostRaidTeamsResponse, PostRaidTeamsTeamIdInviteData, PostRaidTeamsTeamIdInviteError, PostRaidTeamsTeamIdInviteResponse, PostRaidTeamsTeamIdKickParticipantIdData, PostRaidTeamsTeamIdKickParticipantIdError, PostRaidTeamsTeamIdKickParticipantIdResponse, PostRecommendationRecommendationsData, PostRecommendationRecommendationsError, PostRecommendationRecommendationsRecommendationIdPictureData, PostRecommendationRecommendationsRecommendationIdPictureError, PostRecommendationRecommendationsRecommendationIdPictureResponse, PostRecommendationRecommendationsResponse, PostSchoolsData, PostSchoolsError, PostSchoolsResponse, PostSeedLibraryPlantsData, PostSeedLibraryPlantsError, PostSeedLibraryPlantsResponse, PostSeedLibrarySpeciesData, PostSeedLibrarySpeciesError, PostSeedLibrarySpeciesResponse, PostTombolaPackTicketsData, PostTombolaPackTicketsError, PostTombolaPackTicketsResponse, PostTombolaPrizesData, PostTombolaPrizesError, PostTombolaPrizesPrizeIdDrawData, PostTombolaPrizesPrizeIdDrawError, PostTombolaPrizesPrizeIdDrawResponse, PostTombolaPrizesPrizeIdPictureData, PostTombolaPrizesPrizeIdPictureError, PostTombolaPrizesPrizeIdPictureResponse, PostTombolaPrizesResponse, PostTombolaRafflesData, PostTombolaRafflesError, PostTombolaRafflesRaffleIdLogoData, PostTombolaRafflesRaffleIdLogoError, PostTombolaRafflesRaffleIdLogoResponse, PostTombolaRafflesResponse, PostTombolaTicketsBuyPackIdData, PostTombolaTicketsBuyPackIdError, PostTombolaTicketsBuyPackIdResponse, PostTombolaUsersUserIdCashData, PostTombolaUsersUserIdCashError, PostTombolaUsersUserIdCashResponse, PostUsersActivateData, PostUsersActivateError, PostUsersActivateResponse, PostUsersBatchCreationData, PostUsersBatchCreationError, PostUsersBatchCreationResponse, PostUsersChangePasswordData, PostUsersChangePasswordError, PostUsersChangePasswordResponse, PostUsersCreateData, PostUsersCreateError, PostUsersCreateResponse, PostUsersMakeAdminData, PostUsersMakeAdminResponse, PostUsersMeAskDeletionData, PostUsersMeAskDeletionResponse, PostUsersMeProfilePictureData, PostUsersMeProfilePictureError, PostUsersMeProfilePictureResponse, PostUsersMergeData, PostUsersMergeError, PostUsersMergeResponse, PostUsersMigrateMailData, PostUsersMigrateMailError, PostUsersMigrateMailResponse, PostUsersRecoverData, PostUsersRecoverError, PostUsersRecoverResponse, PostUsersResetPasswordData, PostUsersResetPasswordError, PostUsersResetPasswordResponse, PostUsersS3InitData, PutPmfOfferOfferIdData, PutPmfOfferOfferIdError, PutPmfOfferOfferIdResponse, PutPmfTagTagIdData, PutPmfTagTagIdError, PutPmfTagTagIdResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getCampaignSectionsQueryKey = (options?: Options<GetCampaignSectionsData>) => createQueryKey('getCampaignSections', options);

/**
 * Get Sections
 *
 * Return sections in the database as a list of `schemas_campaign.SectionBase`
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const getCampaignSectionsOptions = (options?: Options<GetCampaignSectionsData>) => queryOptions<GetCampaignSectionsResponse, DefaultError, GetCampaignSectionsResponse, ReturnType<typeof getCampaignSectionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCampaignSections({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCampaignSectionsQueryKey(options)
});

/**
 * Add Section
 *
 * Add a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignSectionsMutation = (options?: Partial<Options<PostCampaignSectionsData>>): UseMutationOptions<PostCampaignSectionsResponse, PostCampaignSectionsError, Options<PostCampaignSectionsData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignSectionsResponse, PostCampaignSectionsError, Options<PostCampaignSectionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignSections({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Section
 *
 * Delete a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const deleteCampaignSectionsSectionIdMutation = (options?: Partial<Options<DeleteCampaignSectionsSectionIdData>>): UseMutationOptions<DeleteCampaignSectionsSectionIdResponse, DeleteCampaignSectionsSectionIdError, Options<DeleteCampaignSectionsSectionIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCampaignSectionsSectionIdResponse, DeleteCampaignSectionsSectionIdError, Options<DeleteCampaignSectionsSectionIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCampaignSectionsSectionId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCampaignListsQueryKey = (options?: Options<GetCampaignListsData>) => createQueryKey('getCampaignLists', options);

/**
 * Get Lists
 *
 * Return campaign lists registered for the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const getCampaignListsOptions = (options?: Options<GetCampaignListsData>) => queryOptions<GetCampaignListsResponse, DefaultError, GetCampaignListsResponse, ReturnType<typeof getCampaignListsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCampaignLists({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCampaignListsQueryKey(options)
});

/**
 * Add List
 *
 * Add a campaign list to a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignListsMutation = (options?: Partial<Options<PostCampaignListsData>>): UseMutationOptions<PostCampaignListsResponse, PostCampaignListsError, Options<PostCampaignListsData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignListsResponse, PostCampaignListsError, Options<PostCampaignListsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignLists({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete List
 *
 * Delete the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const deleteCampaignListsListIdMutation = (options?: Partial<Options<DeleteCampaignListsListIdData>>): UseMutationOptions<DeleteCampaignListsListIdResponse, DeleteCampaignListsListIdError, Options<DeleteCampaignListsListIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCampaignListsListIdResponse, DeleteCampaignListsListIdError, Options<DeleteCampaignListsListIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCampaignListsListId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update List
 *
 * Update the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const patchCampaignListsListIdMutation = (options?: Partial<Options<PatchCampaignListsListIdData>>): UseMutationOptions<PatchCampaignListsListIdResponse, PatchCampaignListsListIdError, Options<PatchCampaignListsListIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCampaignListsListIdResponse, PatchCampaignListsListIdError, Options<PatchCampaignListsListIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCampaignListsListId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Lists By Type
 *
 * Delete the all lists by type.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const deleteCampaignListsMutation = (options?: Partial<Options<DeleteCampaignListsData>>): UseMutationOptions<DeleteCampaignListsResponse, DeleteCampaignListsError, Options<DeleteCampaignListsData>> => {
    const mutationOptions: UseMutationOptions<DeleteCampaignListsResponse, DeleteCampaignListsError, Options<DeleteCampaignListsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCampaignLists({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Voters
 *
 * Remove voters (groups allowed to vote)
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const deleteCampaignVotersMutation = (options?: Partial<Options<DeleteCampaignVotersData>>): UseMutationOptions<DeleteCampaignVotersResponse, DefaultError, Options<DeleteCampaignVotersData>> => {
    const mutationOptions: UseMutationOptions<DeleteCampaignVotersResponse, DefaultError, Options<DeleteCampaignVotersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCampaignVoters({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCampaignVotersQueryKey = (options?: Options<GetCampaignVotersData>) => createQueryKey('getCampaignVoters', options);

/**
 * Get Voters
 *
 * Return the voters (groups allowed to vote) for the current campaign.
 */
export const getCampaignVotersOptions = (options?: Options<GetCampaignVotersData>) => queryOptions<GetCampaignVotersResponse, DefaultError, GetCampaignVotersResponse, ReturnType<typeof getCampaignVotersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCampaignVoters({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCampaignVotersQueryKey(options)
});

/**
 * Add Voter
 *
 * Add voters (groups allowed to vote) for this campaign
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignVotersMutation = (options?: Partial<Options<PostCampaignVotersData>>): UseMutationOptions<PostCampaignVotersResponse, PostCampaignVotersError, Options<PostCampaignVotersData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignVotersResponse, PostCampaignVotersError, Options<PostCampaignVotersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignVoters({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Voter By Group Id
 *
 * Remove a voter by its group id
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const deleteCampaignVotersGroupIdMutation = (options?: Partial<Options<DeleteCampaignVotersGroupIdData>>): UseMutationOptions<DeleteCampaignVotersGroupIdResponse, DeleteCampaignVotersGroupIdError, Options<DeleteCampaignVotersGroupIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCampaignVotersGroupIdResponse, DeleteCampaignVotersGroupIdError, Options<DeleteCampaignVotersGroupIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCampaignVotersGroupId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Open Vote
 *
 * If the status is 'waiting', change it to 'voting' and create the blank lists.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'open', all users can vote and sections and lists can no longer be edited.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignStatusOpenMutation = (options?: Partial<Options<PostCampaignStatusOpenData>>): UseMutationOptions<PostCampaignStatusOpenResponse, DefaultError, Options<PostCampaignStatusOpenData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignStatusOpenResponse, DefaultError, Options<PostCampaignStatusOpenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignStatusOpen({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Close Vote
 *
 * If the status is 'open', change it to 'closed'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'closed', users are no longer able to vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignStatusCloseMutation = (options?: Partial<Options<PostCampaignStatusCloseData>>): UseMutationOptions<PostCampaignStatusCloseResponse, DefaultError, Options<PostCampaignStatusCloseData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignStatusCloseResponse, DefaultError, Options<PostCampaignStatusCloseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignStatusClose({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Count Voting
 *
 * If the status is 'closed', change it to 'counting'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'counting', administrators can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignStatusCountingMutation = (options?: Partial<Options<PostCampaignStatusCountingData>>): UseMutationOptions<PostCampaignStatusCountingResponse, DefaultError, Options<PostCampaignStatusCountingData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignStatusCountingResponse, DefaultError, Options<PostCampaignStatusCountingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignStatusCounting({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Publish Vote
 *
 * If the status is 'counting', change it to 'published'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'published', everyone can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignStatusPublishedMutation = (options?: Partial<Options<PostCampaignStatusPublishedData>>): UseMutationOptions<PostCampaignStatusPublishedResponse, DefaultError, Options<PostCampaignStatusPublishedData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignStatusPublishedResponse, DefaultError, Options<PostCampaignStatusPublishedData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignStatusPublished({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset Vote
 *
 * Reset the vote. Can only be used if the current status is counting ou published.
 *
 * > WARNING: This will delete all votes then put the module to Waiting status. This will also delete blank lists.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignStatusResetMutation = (options?: Partial<Options<PostCampaignStatusResetData>>): UseMutationOptions<PostCampaignStatusResetResponse, DefaultError, Options<PostCampaignStatusResetData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignStatusResetResponse, DefaultError, Options<PostCampaignStatusResetData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignStatusReset({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCampaignVotesQueryKey = (options?: Options<GetCampaignVotesData>) => createQueryKey('getCampaignVotes', options);

/**
 * Get Sections Already Voted
 *
 * Return the list of id of sections an user has already voted for.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const getCampaignVotesOptions = (options?: Options<GetCampaignVotesData>) => queryOptions<GetCampaignVotesResponse, DefaultError, GetCampaignVotesResponse, ReturnType<typeof getCampaignVotesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCampaignVotes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCampaignVotesQueryKey(options)
});

/**
 * Vote
 *
 * Add a vote for a given campaign list.
 *
 * An user can only vote for one list per section.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const postCampaignVotesMutation = (options?: Partial<Options<PostCampaignVotesData>>): UseMutationOptions<PostCampaignVotesResponse, PostCampaignVotesError, Options<PostCampaignVotesData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignVotesResponse, PostCampaignVotesError, Options<PostCampaignVotesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignVotes({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCampaignResultsQueryKey = (options?: Options<GetCampaignResultsData>) => createQueryKey('getCampaignResults', options);

/**
 * Get Results
 *
 * Return the results of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const getCampaignResultsOptions = (options?: Options<GetCampaignResultsData>) => queryOptions<GetCampaignResultsResponse, DefaultError, GetCampaignResultsResponse, ReturnType<typeof getCampaignResultsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCampaignResults({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCampaignResultsQueryKey(options)
});

export const getCampaignStatusQueryKey = (options?: Options<GetCampaignStatusData>) => createQueryKey('getCampaignStatus', options);

/**
 * Get Status Vote
 *
 * Get the current status of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const getCampaignStatusOptions = (options?: Options<GetCampaignStatusData>) => queryOptions<GetCampaignStatusResponse, DefaultError, GetCampaignStatusResponse, ReturnType<typeof getCampaignStatusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCampaignStatus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCampaignStatusQueryKey(options)
});

export const getCampaignStatsSectionIdQueryKey = (options: Options<GetCampaignStatsSectionIdData>) => createQueryKey('getCampaignStatsSectionId', options);

/**
 * Get Stats For Section
 *
 * Get stats about a given section.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const getCampaignStatsSectionIdOptions = (options: Options<GetCampaignStatsSectionIdData>) => queryOptions<GetCampaignStatsSectionIdResponse, GetCampaignStatsSectionIdError, GetCampaignStatsSectionIdResponse, ReturnType<typeof getCampaignStatsSectionIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCampaignStatsSectionId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCampaignStatsSectionIdQueryKey(options)
});

export const getCampaignListsListIdLogoQueryKey = (options: Options<GetCampaignListsListIdLogoData>) => createQueryKey('getCampaignListsListIdLogo', options);

/**
 * Read Campaigns Logo
 *
 * Get the logo of a campaign list.
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const getCampaignListsListIdLogoOptions = (options: Options<GetCampaignListsListIdLogoData>) => queryOptions<unknown, GetCampaignListsListIdLogoError, unknown, ReturnType<typeof getCampaignListsListIdLogoQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCampaignListsListIdLogo({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCampaignListsListIdLogoQueryKey(options)
});

/**
 * Create Campaigns Logo
 *
 * Upload a logo for a campaign list.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const postCampaignListsListIdLogoMutation = (options?: Partial<Options<PostCampaignListsListIdLogoData>>): UseMutationOptions<PostCampaignListsListIdLogoResponse, PostCampaignListsListIdLogoError, Options<PostCampaignListsListIdLogoData>> => {
    const mutationOptions: UseMutationOptions<PostCampaignListsListIdLogoResponse, PostCampaignListsListIdLogoError, Options<PostCampaignListsListIdLogoData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCampaignListsListIdLogo({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAdvertAdvertisersQueryKey = (options?: Options<GetAdvertAdvertisersData>) => createQueryKey('getAdvertAdvertisers', options);

/**
 * Read Advertisers
 *
 * Get existing advertisers.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getAdvertAdvertisersOptions = (options?: Options<GetAdvertAdvertisersData>) => queryOptions<GetAdvertAdvertisersResponse, DefaultError, GetAdvertAdvertisersResponse, ReturnType<typeof getAdvertAdvertisersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAdvertAdvertisers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAdvertAdvertisersQueryKey(options)
});

/**
 * Create Advertiser
 *
 * Create a new advertiser.
 *
 * Each advertiser is associated with a `manager_group`. Users belonging to this group are able to manage the adverts related to the advertiser.
 *
 * **This endpoint is only usable by administrators**
 */
export const postAdvertAdvertisersMutation = (options?: Partial<Options<PostAdvertAdvertisersData>>): UseMutationOptions<PostAdvertAdvertisersResponse, PostAdvertAdvertisersError, Options<PostAdvertAdvertisersData>> => {
    const mutationOptions: UseMutationOptions<PostAdvertAdvertisersResponse, PostAdvertAdvertisersError, Options<PostAdvertAdvertisersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAdvertAdvertisers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Advertiser
 *
 * Delete an advertiser. All adverts associated with the advertiser will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const deleteAdvertAdvertisersAdvertiserIdMutation = (options?: Partial<Options<DeleteAdvertAdvertisersAdvertiserIdData>>): UseMutationOptions<DeleteAdvertAdvertisersAdvertiserIdResponse, DeleteAdvertAdvertisersAdvertiserIdError, Options<DeleteAdvertAdvertisersAdvertiserIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteAdvertAdvertisersAdvertiserIdResponse, DeleteAdvertAdvertisersAdvertiserIdError, Options<DeleteAdvertAdvertisersAdvertiserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAdvertAdvertisersAdvertiserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Advertiser
 *
 * Update an advertiser
 *
 * **This endpoint is only usable by administrators**
 */
export const patchAdvertAdvertisersAdvertiserIdMutation = (options?: Partial<Options<PatchAdvertAdvertisersAdvertiserIdData>>): UseMutationOptions<PatchAdvertAdvertisersAdvertiserIdResponse, PatchAdvertAdvertisersAdvertiserIdError, Options<PatchAdvertAdvertisersAdvertiserIdData>> => {
    const mutationOptions: UseMutationOptions<PatchAdvertAdvertisersAdvertiserIdResponse, PatchAdvertAdvertisersAdvertiserIdError, Options<PatchAdvertAdvertisersAdvertiserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchAdvertAdvertisersAdvertiserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAdvertMeAdvertisersQueryKey = (options?: Options<GetAdvertMeAdvertisersData>) => createQueryKey('getAdvertMeAdvertisers', options);

/**
 * Get Current User Advertisers
 *
 * Return all advertisers the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getAdvertMeAdvertisersOptions = (options?: Options<GetAdvertMeAdvertisersData>) => queryOptions<GetAdvertMeAdvertisersResponse, DefaultError, GetAdvertMeAdvertisersResponse, ReturnType<typeof getAdvertMeAdvertisersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAdvertMeAdvertisers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAdvertMeAdvertisersQueryKey(options)
});

export const getAdvertAdvertsQueryKey = (options?: Options<GetAdvertAdvertsData>) => createQueryKey('getAdvertAdverts', options);

/**
 * Read Adverts
 *
 * Get existing adverts. If advertisers optional parameter is used, search adverts by advertisers
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getAdvertAdvertsOptions = (options?: Options<GetAdvertAdvertsData>) => queryOptions<GetAdvertAdvertsResponse, GetAdvertAdvertsError, GetAdvertAdvertsResponse, ReturnType<typeof getAdvertAdvertsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAdvertAdverts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAdvertAdvertsQueryKey(options)
});

/**
 * Create Advert
 *
 * Create a new advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const postAdvertAdvertsMutation = (options?: Partial<Options<PostAdvertAdvertsData>>): UseMutationOptions<PostAdvertAdvertsResponse, PostAdvertAdvertsError, Options<PostAdvertAdvertsData>> => {
    const mutationOptions: UseMutationOptions<PostAdvertAdvertsResponse, PostAdvertAdvertsError, Options<PostAdvertAdvertsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAdvertAdverts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Advert
 *
 * Delete an advert
 *
 * **The user must be admin or a member of the advertiser group_manager to use this endpoint**
 */
export const deleteAdvertAdvertsAdvertIdMutation = (options?: Partial<Options<DeleteAdvertAdvertsAdvertIdData>>): UseMutationOptions<DeleteAdvertAdvertsAdvertIdResponse, DeleteAdvertAdvertsAdvertIdError, Options<DeleteAdvertAdvertsAdvertIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteAdvertAdvertsAdvertIdResponse, DeleteAdvertAdvertsAdvertIdError, Options<DeleteAdvertAdvertsAdvertIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAdvertAdvertsAdvertId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAdvertAdvertsAdvertIdQueryKey = (options: Options<GetAdvertAdvertsAdvertIdData>) => createQueryKey('getAdvertAdvertsAdvertId', options);

/**
 * Read Advert
 *
 * Get an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getAdvertAdvertsAdvertIdOptions = (options: Options<GetAdvertAdvertsAdvertIdData>) => queryOptions<GetAdvertAdvertsAdvertIdResponse, GetAdvertAdvertsAdvertIdError, GetAdvertAdvertsAdvertIdResponse, ReturnType<typeof getAdvertAdvertsAdvertIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAdvertAdvertsAdvertId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAdvertAdvertsAdvertIdQueryKey(options)
});

/**
 * Update Advert
 *
 * Edit an advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const patchAdvertAdvertsAdvertIdMutation = (options?: Partial<Options<PatchAdvertAdvertsAdvertIdData>>): UseMutationOptions<PatchAdvertAdvertsAdvertIdResponse, PatchAdvertAdvertsAdvertIdError, Options<PatchAdvertAdvertsAdvertIdData>> => {
    const mutationOptions: UseMutationOptions<PatchAdvertAdvertsAdvertIdResponse, PatchAdvertAdvertsAdvertIdError, Options<PatchAdvertAdvertsAdvertIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchAdvertAdvertsAdvertId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAdvertAdvertsAdvertIdPictureQueryKey = (options: Options<GetAdvertAdvertsAdvertIdPictureData>) => createQueryKey('getAdvertAdvertsAdvertIdPicture', options);

/**
 * Read Advert Image
 *
 * Get the image of an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getAdvertAdvertsAdvertIdPictureOptions = (options: Options<GetAdvertAdvertsAdvertIdPictureData>) => queryOptions<unknown, GetAdvertAdvertsAdvertIdPictureError, unknown, ReturnType<typeof getAdvertAdvertsAdvertIdPictureQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAdvertAdvertsAdvertIdPicture({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAdvertAdvertsAdvertIdPictureQueryKey(options)
});

/**
 * Create Advert Image
 *
 * Add an image to an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postAdvertAdvertsAdvertIdPictureMutation = (options?: Partial<Options<PostAdvertAdvertsAdvertIdPictureData>>): UseMutationOptions<PostAdvertAdvertsAdvertIdPictureResponse, PostAdvertAdvertsAdvertIdPictureError, Options<PostAdvertAdvertsAdvertIdPictureData>> => {
    const mutationOptions: UseMutationOptions<PostAdvertAdvertsAdvertIdPictureResponse, PostAdvertAdvertsAdvertIdPictureError, Options<PostAdvertAdvertsAdvertIdPictureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAdvertAdvertsAdvertIdPicture({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRecommendationRecommendationsQueryKey = (options?: Options<GetRecommendationRecommendationsData>) => createQueryKey('getRecommendationRecommendations', options);

/**
 * Get Recommendation
 *
 * Get recommendations.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getRecommendationRecommendationsOptions = (options?: Options<GetRecommendationRecommendationsData>) => queryOptions<GetRecommendationRecommendationsResponse, DefaultError, GetRecommendationRecommendationsResponse, ReturnType<typeof getRecommendationRecommendationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRecommendationRecommendations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRecommendationRecommendationsQueryKey(options)
});

/**
 * Create Recommendation
 *
 * Create a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const postRecommendationRecommendationsMutation = (options?: Partial<Options<PostRecommendationRecommendationsData>>): UseMutationOptions<PostRecommendationRecommendationsResponse, PostRecommendationRecommendationsError, Options<PostRecommendationRecommendationsData>> => {
    const mutationOptions: UseMutationOptions<PostRecommendationRecommendationsResponse, PostRecommendationRecommendationsError, Options<PostRecommendationRecommendationsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRecommendationRecommendations({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Recommendation
 *
 * Delete a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const deleteRecommendationRecommendationsRecommendationIdMutation = (options?: Partial<Options<DeleteRecommendationRecommendationsRecommendationIdData>>): UseMutationOptions<DeleteRecommendationRecommendationsRecommendationIdResponse, DeleteRecommendationRecommendationsRecommendationIdError, Options<DeleteRecommendationRecommendationsRecommendationIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteRecommendationRecommendationsRecommendationIdResponse, DeleteRecommendationRecommendationsRecommendationIdError, Options<DeleteRecommendationRecommendationsRecommendationIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRecommendationRecommendationsRecommendationId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Recommendation
 *
 * Edit a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const patchRecommendationRecommendationsRecommendationIdMutation = (options?: Partial<Options<PatchRecommendationRecommendationsRecommendationIdData>>): UseMutationOptions<PatchRecommendationRecommendationsRecommendationIdResponse, PatchRecommendationRecommendationsRecommendationIdError, Options<PatchRecommendationRecommendationsRecommendationIdData>> => {
    const mutationOptions: UseMutationOptions<PatchRecommendationRecommendationsRecommendationIdResponse, PatchRecommendationRecommendationsRecommendationIdError, Options<PatchRecommendationRecommendationsRecommendationIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchRecommendationRecommendationsRecommendationId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRecommendationRecommendationsRecommendationIdPictureQueryKey = (options: Options<GetRecommendationRecommendationsRecommendationIdPictureData>) => createQueryKey('getRecommendationRecommendationsRecommendationIdPicture', options);

/**
 * Read Recommendation Image
 *
 * Get the image of a recommendation.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getRecommendationRecommendationsRecommendationIdPictureOptions = (options: Options<GetRecommendationRecommendationsRecommendationIdPictureData>) => queryOptions<unknown, GetRecommendationRecommendationsRecommendationIdPictureError, unknown, ReturnType<typeof getRecommendationRecommendationsRecommendationIdPictureQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRecommendationRecommendationsRecommendationIdPicture({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRecommendationRecommendationsRecommendationIdPictureQueryKey(options)
});

/**
 * Create Recommendation Image
 *
 * Add an image to a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const postRecommendationRecommendationsRecommendationIdPictureMutation = (options?: Partial<Options<PostRecommendationRecommendationsRecommendationIdPictureData>>): UseMutationOptions<PostRecommendationRecommendationsRecommendationIdPictureResponse, PostRecommendationRecommendationsRecommendationIdPictureError, Options<PostRecommendationRecommendationsRecommendationIdPictureData>> => {
    const mutationOptions: UseMutationOptions<PostRecommendationRecommendationsRecommendationIdPictureResponse, PostRecommendationRecommendationsRecommendationIdPictureError, Options<PostRecommendationRecommendationsRecommendationIdPictureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRecommendationRecommendationsRecommendationIdPicture({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionSportsQueryKey = (options?: Options<GetCompetitionSportsData>) => createQueryKey('getCompetitionSports', options);

/**
 * Get Sports
 */
export const getCompetitionSportsOptions = (options?: Options<GetCompetitionSportsData>) => queryOptions<GetCompetitionSportsResponse, DefaultError, GetCompetitionSportsResponse, ReturnType<typeof getCompetitionSportsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionSports({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionSportsQueryKey(options)
});

/**
 * Create Sport
 */
export const postCompetitionSportsMutation = (options?: Partial<Options<PostCompetitionSportsData>>): UseMutationOptions<PostCompetitionSportsResponse, PostCompetitionSportsError, Options<PostCompetitionSportsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionSportsResponse, PostCompetitionSportsError, Options<PostCompetitionSportsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionSports({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Sport
 */
export const deleteCompetitionSportsSportIdMutation = (options?: Partial<Options<DeleteCompetitionSportsSportIdData>>): UseMutationOptions<DeleteCompetitionSportsSportIdResponse, DeleteCompetitionSportsSportIdError, Options<DeleteCompetitionSportsSportIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionSportsSportIdResponse, DeleteCompetitionSportsSportIdError, Options<DeleteCompetitionSportsSportIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionSportsSportId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Sport
 */
export const patchCompetitionSportsSportIdMutation = (options?: Partial<Options<PatchCompetitionSportsSportIdData>>): UseMutationOptions<PatchCompetitionSportsSportIdResponse, PatchCompetitionSportsSportIdError, Options<PatchCompetitionSportsSportIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionSportsSportIdResponse, PatchCompetitionSportsSportIdError, Options<PatchCompetitionSportsSportIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionSportsSportId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionEditionsQueryKey = (options?: Options<GetCompetitionEditionsData>) => createQueryKey('getCompetitionEditions', options);

/**
 * Get Editions
 */
export const getCompetitionEditionsOptions = (options?: Options<GetCompetitionEditionsData>) => queryOptions<GetCompetitionEditionsResponse, DefaultError, GetCompetitionEditionsResponse, ReturnType<typeof getCompetitionEditionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionEditions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionEditionsQueryKey(options)
});

/**
 * Create Edition
 */
export const postCompetitionEditionsMutation = (options?: Partial<Options<PostCompetitionEditionsData>>): UseMutationOptions<PostCompetitionEditionsResponse, PostCompetitionEditionsError, Options<PostCompetitionEditionsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionEditionsResponse, PostCompetitionEditionsError, Options<PostCompetitionEditionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionEditions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionEditionsActiveQueryKey = (options?: Options<GetCompetitionEditionsActiveData>) => createQueryKey('getCompetitionEditionsActive', options);

/**
 * Get Active Edition
 *
 * Get the currently active competition edition.
 * Returns None if no edition is active.
 */
export const getCompetitionEditionsActiveOptions = (options?: Options<GetCompetitionEditionsActiveData>) => queryOptions<GetCompetitionEditionsActiveResponse, DefaultError, GetCompetitionEditionsActiveResponse, ReturnType<typeof getCompetitionEditionsActiveQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionEditionsActive({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionEditionsActiveQueryKey(options)
});

/**
 * Activate Edition
 *
 * Activate a competition edition.
 * If another edition is already active, it will be deactivated.
 */
export const postCompetitionEditionsEditionIdActivateMutation = (options?: Partial<Options<PostCompetitionEditionsEditionIdActivateData>>): UseMutationOptions<PostCompetitionEditionsEditionIdActivateResponse, PostCompetitionEditionsEditionIdActivateError, Options<PostCompetitionEditionsEditionIdActivateData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionEditionsEditionIdActivateResponse, PostCompetitionEditionsEditionIdActivateError, Options<PostCompetitionEditionsEditionIdActivateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionEditionsEditionIdActivate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Enable Inscription
 *
 * Enable inscription for a competition edition.
 * The edition must already be active.
 */
export const postCompetitionEditionsEditionIdInscriptionMutation = (options?: Partial<Options<PostCompetitionEditionsEditionIdInscriptionData>>): UseMutationOptions<PostCompetitionEditionsEditionIdInscriptionResponse, PostCompetitionEditionsEditionIdInscriptionError, Options<PostCompetitionEditionsEditionIdInscriptionData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionEditionsEditionIdInscriptionResponse, PostCompetitionEditionsEditionIdInscriptionError, Options<PostCompetitionEditionsEditionIdInscriptionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionEditionsEditionIdInscription({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Edition
 */
export const patchCompetitionEditionsEditionIdMutation = (options?: Partial<Options<PatchCompetitionEditionsEditionIdData>>): UseMutationOptions<PatchCompetitionEditionsEditionIdResponse, PatchCompetitionEditionsEditionIdError, Options<PatchCompetitionEditionsEditionIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionEditionsEditionIdResponse, PatchCompetitionEditionsEditionIdError, Options<PatchCompetitionEditionsEditionIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionEditionsEditionId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionUsersQueryKey = (options?: Options<GetCompetitionUsersData>) => createQueryKey('getCompetitionUsers', options);

/**
 * Get Competition Users
 *
 * Get all competition users for the current edition.
 */
export const getCompetitionUsersOptions = (options?: Options<GetCompetitionUsersData>) => queryOptions<GetCompetitionUsersResponse, DefaultError, GetCompetitionUsersResponse, ReturnType<typeof getCompetitionUsersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionUsers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionUsersQueryKey(options)
});

/**
 * Create Competition User
 *
 * Create a competition user for the current edition.
 * The user must exist in the core users database.
 */
export const postCompetitionUsersMutation = (options?: Partial<Options<PostCompetitionUsersData>>): UseMutationOptions<PostCompetitionUsersResponse, PostCompetitionUsersError, Options<PostCompetitionUsersData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionUsersResponse, PostCompetitionUsersError, Options<PostCompetitionUsersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionUsers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionUsersSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionUsersSchoolsSchoolIdData>) => createQueryKey('getCompetitionUsersSchoolsSchoolId', options);

/**
 * Get Competition Users By School
 *
 * Get all competition users for the current edition by school.
 */
export const getCompetitionUsersSchoolsSchoolIdOptions = (options: Options<GetCompetitionUsersSchoolsSchoolIdData>) => queryOptions<GetCompetitionUsersSchoolsSchoolIdResponse, GetCompetitionUsersSchoolsSchoolIdError, GetCompetitionUsersSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionUsersSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionUsersSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionUsersSchoolsSchoolIdQueryKey(options)
});

export const getCompetitionUsersMeQueryKey = (options?: Options<GetCompetitionUsersMeData>) => createQueryKey('getCompetitionUsersMe', options);

/**
 * Get Current User Competition
 *
 * Get the competition user for the current edition.
 * This is the user making the request.
 */
export const getCompetitionUsersMeOptions = (options?: Options<GetCompetitionUsersMeData>) => queryOptions<GetCompetitionUsersMeResponse, DefaultError, GetCompetitionUsersMeResponse, ReturnType<typeof getCompetitionUsersMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionUsersMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionUsersMeQueryKey(options)
});

/**
 * Edit Current User Competition
 *
 * Edit the current user's competition user for the current edition.
 * The user must exist in the core users database.
 */
export const patchCompetitionUsersMeMutation = (options?: Partial<Options<PatchCompetitionUsersMeData>>): UseMutationOptions<PatchCompetitionUsersMeResponse, PatchCompetitionUsersMeError, Options<PatchCompetitionUsersMeData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionUsersMeResponse, PatchCompetitionUsersMeError, Options<PatchCompetitionUsersMeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionUsersMe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionUsersDataExportQueryKey = (options?: Options<GetCompetitionUsersDataExportData>) => createQueryKey('getCompetitionUsersDataExport', options);

/**
 * Export Competition Users Data
 *
 * Export competition users data for the current edition as a CSV file.
 */
export const getCompetitionUsersDataExportOptions = (options?: Options<GetCompetitionUsersDataExportData>) => queryOptions<unknown, GetCompetitionUsersDataExportError, unknown, ReturnType<typeof getCompetitionUsersDataExportQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionUsersDataExport({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionUsersDataExportQueryKey(options)
});

export const getCompetitionUsersUserIdQueryKey = (options: Options<GetCompetitionUsersUserIdData>) => createQueryKey('getCompetitionUsersUserId', options);

/**
 * Get Competition User
 *
 * Get a competition user by their user ID for the current edition.
 */
export const getCompetitionUsersUserIdOptions = (options: Options<GetCompetitionUsersUserIdData>) => queryOptions<GetCompetitionUsersUserIdResponse, GetCompetitionUsersUserIdError, GetCompetitionUsersUserIdResponse, ReturnType<typeof getCompetitionUsersUserIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionUsersUserId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionUsersUserIdQueryKey(options)
});

/**
 * Edit Competition User
 *
 * Edit a competition user for the current edition.
 * The user must exist in the core users database.
 */
export const patchCompetitionUsersUserIdMutation = (options?: Partial<Options<PatchCompetitionUsersUserIdData>>): UseMutationOptions<PatchCompetitionUsersUserIdResponse, PatchCompetitionUsersUserIdError, Options<PatchCompetitionUsersUserIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionUsersUserIdResponse, PatchCompetitionUsersUserIdError, Options<PatchCompetitionUsersUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionUsersUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Validate Competition User
 */
export const patchCompetitionUsersUserIdValidateMutation = (options?: Partial<Options<PatchCompetitionUsersUserIdValidateData>>): UseMutationOptions<PatchCompetitionUsersUserIdValidateResponse, PatchCompetitionUsersUserIdValidateError, Options<PatchCompetitionUsersUserIdValidateData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionUsersUserIdValidateResponse, PatchCompetitionUsersUserIdValidateError, Options<PatchCompetitionUsersUserIdValidateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionUsersUserIdValidate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Invalidate Competition User
 */
export const patchCompetitionUsersUserIdInvalidateMutation = (options?: Partial<Options<PatchCompetitionUsersUserIdInvalidateData>>): UseMutationOptions<PatchCompetitionUsersUserIdInvalidateResponse, PatchCompetitionUsersUserIdInvalidateError, Options<PatchCompetitionUsersUserIdInvalidateData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionUsersUserIdInvalidateResponse, PatchCompetitionUsersUserIdInvalidateError, Options<PatchCompetitionUsersUserIdInvalidateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionUsersUserIdInvalidate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionGroupsGroupQueryKey = (options: Options<GetCompetitionGroupsGroupData>) => createQueryKey('getCompetitionGroupsGroup', options);

/**
 * Get Group Members
 *
 * Get all users in a specific competition group for the current edition.
 */
export const getCompetitionGroupsGroupOptions = (options: Options<GetCompetitionGroupsGroupData>) => queryOptions<GetCompetitionGroupsGroupResponse, GetCompetitionGroupsGroupError, GetCompetitionGroupsGroupResponse, ReturnType<typeof getCompetitionGroupsGroupQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionGroupsGroup({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionGroupsGroupQueryKey(options)
});

export const getCompetitionUsersMeGroupsQueryKey = (options?: Options<GetCompetitionUsersMeGroupsData>) => createQueryKey('getCompetitionUsersMeGroups', options);

/**
 * Get Current User Groups
 *
 * Get all groups the current user is a member of in the current edition.
 * This is the user making the request.
 */
export const getCompetitionUsersMeGroupsOptions = (options?: Options<GetCompetitionUsersMeGroupsData>) => queryOptions<GetCompetitionUsersMeGroupsResponse, DefaultError, GetCompetitionUsersMeGroupsResponse, ReturnType<typeof getCompetitionUsersMeGroupsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionUsersMeGroups({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionUsersMeGroupsQueryKey(options)
});

export const getCompetitionUsersUserIdGroupsQueryKey = (options: Options<GetCompetitionUsersUserIdGroupsData>) => createQueryKey('getCompetitionUsersUserIdGroups', options);

/**
 * Get User Groups
 *
 * Get all groups a user is a member of in the current edition.
 */
export const getCompetitionUsersUserIdGroupsOptions = (options: Options<GetCompetitionUsersUserIdGroupsData>) => queryOptions<GetCompetitionUsersUserIdGroupsResponse, GetCompetitionUsersUserIdGroupsError, GetCompetitionUsersUserIdGroupsResponse, ReturnType<typeof getCompetitionUsersUserIdGroupsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionUsersUserIdGroups({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionUsersUserIdGroupsQueryKey(options)
});

/**
 * Remove User From Group
 */
export const deleteCompetitionGroupsGroupUsersUserIdMutation = (options?: Partial<Options<DeleteCompetitionGroupsGroupUsersUserIdData>>): UseMutationOptions<DeleteCompetitionGroupsGroupUsersUserIdResponse, DeleteCompetitionGroupsGroupUsersUserIdError, Options<DeleteCompetitionGroupsGroupUsersUserIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionGroupsGroupUsersUserIdResponse, DeleteCompetitionGroupsGroupUsersUserIdError, Options<DeleteCompetitionGroupsGroupUsersUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionGroupsGroupUsersUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add User To Group
 */
export const postCompetitionGroupsGroupUsersUserIdMutation = (options?: Partial<Options<PostCompetitionGroupsGroupUsersUserIdData>>): UseMutationOptions<PostCompetitionGroupsGroupUsersUserIdResponse, PostCompetitionGroupsGroupUsersUserIdError, Options<PostCompetitionGroupsGroupUsersUserIdData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionGroupsGroupUsersUserIdResponse, PostCompetitionGroupsGroupUsersUserIdError, Options<PostCompetitionGroupsGroupUsersUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionGroupsGroupUsersUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionSchoolsQueryKey = (options?: Options<GetCompetitionSchoolsData>) => createQueryKey('getCompetitionSchools', options);

/**
 * Get Schools
 */
export const getCompetitionSchoolsOptions = (options?: Options<GetCompetitionSchoolsData>) => queryOptions<GetCompetitionSchoolsResponse, DefaultError, GetCompetitionSchoolsResponse, ReturnType<typeof getCompetitionSchoolsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionSchools({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionSchoolsQueryKey(options)
});

/**
 * Create School Extension
 */
export const postCompetitionSchoolsMutation = (options?: Partial<Options<PostCompetitionSchoolsData>>): UseMutationOptions<PostCompetitionSchoolsResponse, PostCompetitionSchoolsError, Options<PostCompetitionSchoolsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionSchoolsResponse, PostCompetitionSchoolsError, Options<PostCompetitionSchoolsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionSchools({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete School Extension
 */
export const deleteCompetitionSchoolsSchoolIdMutation = (options?: Partial<Options<DeleteCompetitionSchoolsSchoolIdData>>): UseMutationOptions<DeleteCompetitionSchoolsSchoolIdResponse, DeleteCompetitionSchoolsSchoolIdError, Options<DeleteCompetitionSchoolsSchoolIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionSchoolsSchoolIdResponse, DeleteCompetitionSchoolsSchoolIdError, Options<DeleteCompetitionSchoolsSchoolIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionSchoolsSchoolId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionSchoolsSchoolIdData>) => createQueryKey('getCompetitionSchoolsSchoolId', options);

/**
 * Get School
 */
export const getCompetitionSchoolsSchoolIdOptions = (options: Options<GetCompetitionSchoolsSchoolIdData>) => queryOptions<GetCompetitionSchoolsSchoolIdResponse, GetCompetitionSchoolsSchoolIdError, GetCompetitionSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionSchoolsSchoolIdQueryKey(options)
});

/**
 * Edit School Extension
 */
export const patchCompetitionSchoolsSchoolIdMutation = (options?: Partial<Options<PatchCompetitionSchoolsSchoolIdData>>): UseMutationOptions<PatchCompetitionSchoolsSchoolIdResponse, PatchCompetitionSchoolsSchoolIdError, Options<PatchCompetitionSchoolsSchoolIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionSchoolsSchoolIdResponse, PatchCompetitionSchoolsSchoolIdError, Options<PatchCompetitionSchoolsSchoolIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionSchoolsSchoolId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionSchoolsSchoolIdGeneralQuotaQueryKey = (options: Options<GetCompetitionSchoolsSchoolIdGeneralQuotaData>) => createQueryKey('getCompetitionSchoolsSchoolIdGeneralQuota', options);

/**
 * Get School General Quota
 */
export const getCompetitionSchoolsSchoolIdGeneralQuotaOptions = (options: Options<GetCompetitionSchoolsSchoolIdGeneralQuotaData>) => queryOptions<GetCompetitionSchoolsSchoolIdGeneralQuotaResponse, GetCompetitionSchoolsSchoolIdGeneralQuotaError, GetCompetitionSchoolsSchoolIdGeneralQuotaResponse, ReturnType<typeof getCompetitionSchoolsSchoolIdGeneralQuotaQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionSchoolsSchoolIdGeneralQuota({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionSchoolsSchoolIdGeneralQuotaQueryKey(options)
});

/**
 * Edit School General Quota
 */
export const patchCompetitionSchoolsSchoolIdGeneralQuotaMutation = (options?: Partial<Options<PatchCompetitionSchoolsSchoolIdGeneralQuotaData>>): UseMutationOptions<PatchCompetitionSchoolsSchoolIdGeneralQuotaResponse, PatchCompetitionSchoolsSchoolIdGeneralQuotaError, Options<PatchCompetitionSchoolsSchoolIdGeneralQuotaData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionSchoolsSchoolIdGeneralQuotaResponse, PatchCompetitionSchoolsSchoolIdGeneralQuotaError, Options<PatchCompetitionSchoolsSchoolIdGeneralQuotaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionSchoolsSchoolIdGeneralQuota({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create School General Quota
 */
export const postCompetitionSchoolsSchoolIdGeneralQuotaMutation = (options?: Partial<Options<PostCompetitionSchoolsSchoolIdGeneralQuotaData>>): UseMutationOptions<PostCompetitionSchoolsSchoolIdGeneralQuotaResponse, PostCompetitionSchoolsSchoolIdGeneralQuotaError, Options<PostCompetitionSchoolsSchoolIdGeneralQuotaData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionSchoolsSchoolIdGeneralQuotaResponse, PostCompetitionSchoolsSchoolIdGeneralQuotaError, Options<PostCompetitionSchoolsSchoolIdGeneralQuotaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionSchoolsSchoolIdGeneralQuota({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionSportsSportIdQuotasQueryKey = (options: Options<GetCompetitionSportsSportIdQuotasData>) => createQueryKey('getCompetitionSportsSportIdQuotas', options);

/**
 * Get Quotas For Sport
 */
export const getCompetitionSportsSportIdQuotasOptions = (options: Options<GetCompetitionSportsSportIdQuotasData>) => queryOptions<GetCompetitionSportsSportIdQuotasResponse, GetCompetitionSportsSportIdQuotasError, GetCompetitionSportsSportIdQuotasResponse, ReturnType<typeof getCompetitionSportsSportIdQuotasQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionSportsSportIdQuotas({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionSportsSportIdQuotasQueryKey(options)
});

export const getCompetitionSchoolsSchoolIdSportsQuotasQueryKey = (options: Options<GetCompetitionSchoolsSchoolIdSportsQuotasData>) => createQueryKey('getCompetitionSchoolsSchoolIdSportsQuotas', options);

/**
 * Get Quotas For School
 */
export const getCompetitionSchoolsSchoolIdSportsQuotasOptions = (options: Options<GetCompetitionSchoolsSchoolIdSportsQuotasData>) => queryOptions<GetCompetitionSchoolsSchoolIdSportsQuotasResponse, GetCompetitionSchoolsSchoolIdSportsQuotasError, GetCompetitionSchoolsSchoolIdSportsQuotasResponse, ReturnType<typeof getCompetitionSchoolsSchoolIdSportsQuotasQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionSchoolsSchoolIdSportsQuotas({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionSchoolsSchoolIdSportsQuotasQueryKey(options)
});

/**
 * Delete Sport Quota
 */
export const deleteCompetitionSchoolsSchoolIdSportsSportIdQuotasMutation = (options?: Partial<Options<DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasData>>): UseMutationOptions<DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasError, Options<DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasError, Options<DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionSchoolsSchoolIdSportsSportIdQuotas({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Sport Quota
 */
export const patchCompetitionSchoolsSchoolIdSportsSportIdQuotasMutation = (options?: Partial<Options<PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasData>>): UseMutationOptions<PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasError, Options<PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasError, Options<PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionSchoolsSchoolIdSportsSportIdQuotas({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Sport Quota
 */
export const postCompetitionSchoolsSchoolIdSportsSportIdQuotasMutation = (options?: Partial<Options<PostCompetitionSchoolsSchoolIdSportsSportIdQuotasData>>): UseMutationOptions<PostCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, PostCompetitionSchoolsSchoolIdSportsSportIdQuotasError, Options<PostCompetitionSchoolsSchoolIdSportsSportIdQuotasData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionSchoolsSchoolIdSportsSportIdQuotasResponse, PostCompetitionSchoolsSchoolIdSportsSportIdQuotasError, Options<PostCompetitionSchoolsSchoolIdSportsSportIdQuotasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionSchoolsSchoolIdSportsSportIdQuotas({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionSchoolsSchoolIdProductQuotasQueryKey = (options: Options<GetCompetitionSchoolsSchoolIdProductQuotasData>) => createQueryKey('getCompetitionSchoolsSchoolIdProductQuotas', options);

/**
 * Get Product Quotas For School
 */
export const getCompetitionSchoolsSchoolIdProductQuotasOptions = (options: Options<GetCompetitionSchoolsSchoolIdProductQuotasData>) => queryOptions<GetCompetitionSchoolsSchoolIdProductQuotasResponse, GetCompetitionSchoolsSchoolIdProductQuotasError, GetCompetitionSchoolsSchoolIdProductQuotasResponse, ReturnType<typeof getCompetitionSchoolsSchoolIdProductQuotasQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionSchoolsSchoolIdProductQuotas({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionSchoolsSchoolIdProductQuotasQueryKey(options)
});

/**
 * Create Product Quota
 */
export const postCompetitionSchoolsSchoolIdProductQuotasMutation = (options?: Partial<Options<PostCompetitionSchoolsSchoolIdProductQuotasData>>): UseMutationOptions<PostCompetitionSchoolsSchoolIdProductQuotasResponse, PostCompetitionSchoolsSchoolIdProductQuotasError, Options<PostCompetitionSchoolsSchoolIdProductQuotasData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionSchoolsSchoolIdProductQuotasResponse, PostCompetitionSchoolsSchoolIdProductQuotasError, Options<PostCompetitionSchoolsSchoolIdProductQuotasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionSchoolsSchoolIdProductQuotas({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionProductsProductIdSchoolsQuotasQueryKey = (options: Options<GetCompetitionProductsProductIdSchoolsQuotasData>) => createQueryKey('getCompetitionProductsProductIdSchoolsQuotas', options);

/**
 * Get Product Quotas For Product
 */
export const getCompetitionProductsProductIdSchoolsQuotasOptions = (options: Options<GetCompetitionProductsProductIdSchoolsQuotasData>) => queryOptions<GetCompetitionProductsProductIdSchoolsQuotasResponse, GetCompetitionProductsProductIdSchoolsQuotasError, GetCompetitionProductsProductIdSchoolsQuotasResponse, ReturnType<typeof getCompetitionProductsProductIdSchoolsQuotasQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionProductsProductIdSchoolsQuotas({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionProductsProductIdSchoolsQuotasQueryKey(options)
});

/**
 * Delete Product Quota
 */
export const deleteCompetitionSchoolsSchoolIdProductQuotasProductIdMutation = (options?: Partial<Options<DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdData>>): UseMutationOptions<DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdResponse, DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdError, Options<DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdResponse, DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdError, Options<DeleteCompetitionSchoolsSchoolIdProductQuotasProductIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionSchoolsSchoolIdProductQuotasProductId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Product Quota
 */
export const patchCompetitionSchoolsSchoolIdProductQuotasProductIdMutation = (options?: Partial<Options<PatchCompetitionSchoolsSchoolIdProductQuotasProductIdData>>): UseMutationOptions<PatchCompetitionSchoolsSchoolIdProductQuotasProductIdResponse, PatchCompetitionSchoolsSchoolIdProductQuotasProductIdError, Options<PatchCompetitionSchoolsSchoolIdProductQuotasProductIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionSchoolsSchoolIdProductQuotasProductIdResponse, PatchCompetitionSchoolsSchoolIdProductQuotasProductIdError, Options<PatchCompetitionSchoolsSchoolIdProductQuotasProductIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionSchoolsSchoolIdProductQuotasProductId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionTeamsQueryKey = (options?: Options<GetCompetitionTeamsData>) => createQueryKey('getCompetitionTeams', options);

/**
 * Get Teams
 */
export const getCompetitionTeamsOptions = (options?: Options<GetCompetitionTeamsData>) => queryOptions<GetCompetitionTeamsResponse, DefaultError, GetCompetitionTeamsResponse, ReturnType<typeof getCompetitionTeamsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionTeams({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionTeamsQueryKey(options)
});

/**
 * Create Team
 */
export const postCompetitionTeamsMutation = (options?: Partial<Options<PostCompetitionTeamsData>>): UseMutationOptions<PostCompetitionTeamsResponse, PostCompetitionTeamsError, Options<PostCompetitionTeamsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionTeamsResponse, PostCompetitionTeamsError, Options<PostCompetitionTeamsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionTeams({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionTeamsMeQueryKey = (options?: Options<GetCompetitionTeamsMeData>) => createQueryKey('getCompetitionTeamsMe', options);

/**
 * Get Current User Team As Captain
 */
export const getCompetitionTeamsMeOptions = (options?: Options<GetCompetitionTeamsMeData>) => queryOptions<GetCompetitionTeamsMeResponse, DefaultError, GetCompetitionTeamsMeResponse, ReturnType<typeof getCompetitionTeamsMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionTeamsMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionTeamsMeQueryKey(options)
});

export const getCompetitionTeamsSportsSportIdQueryKey = (options: Options<GetCompetitionTeamsSportsSportIdData>) => createQueryKey('getCompetitionTeamsSportsSportId', options);

/**
 * Get Teams For Sport
 */
export const getCompetitionTeamsSportsSportIdOptions = (options: Options<GetCompetitionTeamsSportsSportIdData>) => queryOptions<GetCompetitionTeamsSportsSportIdResponse, GetCompetitionTeamsSportsSportIdError, GetCompetitionTeamsSportsSportIdResponse, ReturnType<typeof getCompetitionTeamsSportsSportIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionTeamsSportsSportId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionTeamsSportsSportIdQueryKey(options)
});

export const getCompetitionTeamsSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionTeamsSchoolsSchoolIdData>) => createQueryKey('getCompetitionTeamsSchoolsSchoolId', options);

/**
 * Get Teams For School
 */
export const getCompetitionTeamsSchoolsSchoolIdOptions = (options: Options<GetCompetitionTeamsSchoolsSchoolIdData>) => queryOptions<GetCompetitionTeamsSchoolsSchoolIdResponse, GetCompetitionTeamsSchoolsSchoolIdError, GetCompetitionTeamsSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionTeamsSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionTeamsSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionTeamsSchoolsSchoolIdQueryKey(options)
});

export const getCompetitionTeamsSportsSportIdSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionTeamsSportsSportIdSchoolsSchoolIdData>) => createQueryKey('getCompetitionTeamsSportsSportIdSchoolsSchoolId', options);

/**
 * Get Sport Teams For School And Sport
 */
export const getCompetitionTeamsSportsSportIdSchoolsSchoolIdOptions = (options: Options<GetCompetitionTeamsSportsSportIdSchoolsSchoolIdData>) => queryOptions<GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse, GetCompetitionTeamsSportsSportIdSchoolsSchoolIdError, GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionTeamsSportsSportIdSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionTeamsSportsSportIdSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionTeamsSportsSportIdSchoolsSchoolIdQueryKey(options)
});

/**
 * Delete Team
 */
export const deleteCompetitionTeamsTeamIdMutation = (options?: Partial<Options<DeleteCompetitionTeamsTeamIdData>>): UseMutationOptions<DeleteCompetitionTeamsTeamIdResponse, DeleteCompetitionTeamsTeamIdError, Options<DeleteCompetitionTeamsTeamIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionTeamsTeamIdResponse, DeleteCompetitionTeamsTeamIdError, Options<DeleteCompetitionTeamsTeamIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionTeamsTeamId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Team
 */
export const patchCompetitionTeamsTeamIdMutation = (options?: Partial<Options<PatchCompetitionTeamsTeamIdData>>): UseMutationOptions<PatchCompetitionTeamsTeamIdResponse, PatchCompetitionTeamsTeamIdError, Options<PatchCompetitionTeamsTeamIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionTeamsTeamIdResponse, PatchCompetitionTeamsTeamIdError, Options<PatchCompetitionTeamsTeamIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionTeamsTeamId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionParticipantsMeQueryKey = (options?: Options<GetCompetitionParticipantsMeData>) => createQueryKey('getCompetitionParticipantsMe', options);

/**
 * Get Current User Participant
 */
export const getCompetitionParticipantsMeOptions = (options?: Options<GetCompetitionParticipantsMeData>) => queryOptions<GetCompetitionParticipantsMeResponse, DefaultError, GetCompetitionParticipantsMeResponse, ReturnType<typeof getCompetitionParticipantsMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionParticipantsMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionParticipantsMeQueryKey(options)
});

export const getCompetitionParticipantsSportsSportIdQueryKey = (options: Options<GetCompetitionParticipantsSportsSportIdData>) => createQueryKey('getCompetitionParticipantsSportsSportId', options);

/**
 * Get Participants For Sport
 */
export const getCompetitionParticipantsSportsSportIdOptions = (options: Options<GetCompetitionParticipantsSportsSportIdData>) => queryOptions<GetCompetitionParticipantsSportsSportIdResponse, GetCompetitionParticipantsSportsSportIdError, GetCompetitionParticipantsSportsSportIdResponse, ReturnType<typeof getCompetitionParticipantsSportsSportIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionParticipantsSportsSportId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionParticipantsSportsSportIdQueryKey(options)
});

export const getCompetitionParticipantsSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionParticipantsSchoolsSchoolIdData>) => createQueryKey('getCompetitionParticipantsSchoolsSchoolId', options);

/**
 * Get Participants For School
 */
export const getCompetitionParticipantsSchoolsSchoolIdOptions = (options: Options<GetCompetitionParticipantsSchoolsSchoolIdData>) => queryOptions<GetCompetitionParticipantsSchoolsSchoolIdResponse, GetCompetitionParticipantsSchoolsSchoolIdError, GetCompetitionParticipantsSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionParticipantsSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionParticipantsSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionParticipantsSchoolsSchoolIdQueryKey(options)
});

export const getCompetitionParticipantsUsersUserIdCertificateQueryKey = (options: Options<GetCompetitionParticipantsUsersUserIdCertificateData>) => createQueryKey('getCompetitionParticipantsUsersUserIdCertificate', options);

/**
 * Download Participant Certificate
 */
export const getCompetitionParticipantsUsersUserIdCertificateOptions = (options: Options<GetCompetitionParticipantsUsersUserIdCertificateData>) => queryOptions<unknown, GetCompetitionParticipantsUsersUserIdCertificateError, unknown, ReturnType<typeof getCompetitionParticipantsUsersUserIdCertificateQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionParticipantsUsersUserIdCertificate({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionParticipantsUsersUserIdCertificateQueryKey(options)
});

/**
 * Join Sport
 */
export const postCompetitionSportsSportIdParticipateMutation = (options?: Partial<Options<PostCompetitionSportsSportIdParticipateData>>): UseMutationOptions<PostCompetitionSportsSportIdParticipateResponse, PostCompetitionSportsSportIdParticipateError, Options<PostCompetitionSportsSportIdParticipateData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionSportsSportIdParticipateResponse, PostCompetitionSportsSportIdParticipateError, Options<PostCompetitionSportsSportIdParticipateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionSportsSportIdParticipate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Participant Certificate File
 */
export const deleteCompetitionParticipantsSportsSportIdCertificateMutation = (options?: Partial<Options<DeleteCompetitionParticipantsSportsSportIdCertificateData>>): UseMutationOptions<DeleteCompetitionParticipantsSportsSportIdCertificateResponse, DeleteCompetitionParticipantsSportsSportIdCertificateError, Options<DeleteCompetitionParticipantsSportsSportIdCertificateData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionParticipantsSportsSportIdCertificateResponse, DeleteCompetitionParticipantsSportsSportIdCertificateError, Options<DeleteCompetitionParticipantsSportsSportIdCertificateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionParticipantsSportsSportIdCertificate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Upload Participant Certificate
 */
export const postCompetitionParticipantsSportsSportIdCertificateMutation = (options?: Partial<Options<PostCompetitionParticipantsSportsSportIdCertificateData>>): UseMutationOptions<PostCompetitionParticipantsSportsSportIdCertificateResponse, PostCompetitionParticipantsSportsSportIdCertificateError, Options<PostCompetitionParticipantsSportsSportIdCertificateData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionParticipantsSportsSportIdCertificateResponse, PostCompetitionParticipantsSportsSportIdCertificateError, Options<PostCompetitionParticipantsSportsSportIdCertificateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionParticipantsSportsSportIdCertificate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Mark Participant License As Valid
 */
export const patchCompetitionParticipantsSportsSportIdUsersUserIdLicenseMutation = (options?: Partial<Options<PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseData>>): UseMutationOptions<PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseResponse, PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseError, Options<PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseResponse, PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseError, Options<PatchCompetitionParticipantsSportsSportIdUsersUserIdLicenseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionParticipantsSportsSportIdUsersUserIdLicense({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Withdraw From Sport
 */
export const deleteCompetitionSportsSportIdWithdrawMutation = (options?: Partial<Options<DeleteCompetitionSportsSportIdWithdrawData>>): UseMutationOptions<DeleteCompetitionSportsSportIdWithdrawResponse, DeleteCompetitionSportsSportIdWithdrawError, Options<DeleteCompetitionSportsSportIdWithdrawData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionSportsSportIdWithdrawResponse, DeleteCompetitionSportsSportIdWithdrawError, Options<DeleteCompetitionSportsSportIdWithdrawData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionSportsSportIdWithdraw({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Participant
 */
export const deleteCompetitionParticipantsUserIdSportsSportIdMutation = (options?: Partial<Options<DeleteCompetitionParticipantsUserIdSportsSportIdData>>): UseMutationOptions<DeleteCompetitionParticipantsUserIdSportsSportIdResponse, DeleteCompetitionParticipantsUserIdSportsSportIdError, Options<DeleteCompetitionParticipantsUserIdSportsSportIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionParticipantsUserIdSportsSportIdResponse, DeleteCompetitionParticipantsUserIdSportsSportIdError, Options<DeleteCompetitionParticipantsUserIdSportsSportIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionParticipantsUserIdSportsSportId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionLocationsQueryKey = (options?: Options<GetCompetitionLocationsData>) => createQueryKey('getCompetitionLocations', options);

/**
 * Get All Locations
 */
export const getCompetitionLocationsOptions = (options?: Options<GetCompetitionLocationsData>) => queryOptions<GetCompetitionLocationsResponse, DefaultError, GetCompetitionLocationsResponse, ReturnType<typeof getCompetitionLocationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionLocations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionLocationsQueryKey(options)
});

/**
 * Create Location
 */
export const postCompetitionLocationsMutation = (options?: Partial<Options<PostCompetitionLocationsData>>): UseMutationOptions<PostCompetitionLocationsResponse, PostCompetitionLocationsError, Options<PostCompetitionLocationsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionLocationsResponse, PostCompetitionLocationsError, Options<PostCompetitionLocationsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionLocations({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Location
 */
export const deleteCompetitionLocationsLocationIdMutation = (options?: Partial<Options<DeleteCompetitionLocationsLocationIdData>>): UseMutationOptions<DeleteCompetitionLocationsLocationIdResponse, DeleteCompetitionLocationsLocationIdError, Options<DeleteCompetitionLocationsLocationIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionLocationsLocationIdResponse, DeleteCompetitionLocationsLocationIdError, Options<DeleteCompetitionLocationsLocationIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionLocationsLocationId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionLocationsLocationIdQueryKey = (options: Options<GetCompetitionLocationsLocationIdData>) => createQueryKey('getCompetitionLocationsLocationId', options);

/**
 * Get Location By Id
 */
export const getCompetitionLocationsLocationIdOptions = (options: Options<GetCompetitionLocationsLocationIdData>) => queryOptions<GetCompetitionLocationsLocationIdResponse, GetCompetitionLocationsLocationIdError, GetCompetitionLocationsLocationIdResponse, ReturnType<typeof getCompetitionLocationsLocationIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionLocationsLocationId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionLocationsLocationIdQueryKey(options)
});

/**
 * Edit Location
 */
export const patchCompetitionLocationsLocationIdMutation = (options?: Partial<Options<PatchCompetitionLocationsLocationIdData>>): UseMutationOptions<PatchCompetitionLocationsLocationIdResponse, PatchCompetitionLocationsLocationIdError, Options<PatchCompetitionLocationsLocationIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionLocationsLocationIdResponse, PatchCompetitionLocationsLocationIdError, Options<PatchCompetitionLocationsLocationIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionLocationsLocationId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionMatchesQueryKey = (options?: Options<GetCompetitionMatchesData>) => createQueryKey('getCompetitionMatches', options);

/**
 * Get All Matches For Edition
 */
export const getCompetitionMatchesOptions = (options?: Options<GetCompetitionMatchesData>) => queryOptions<GetCompetitionMatchesResponse, DefaultError, GetCompetitionMatchesResponse, ReturnType<typeof getCompetitionMatchesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionMatches({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionMatchesQueryKey(options)
});

export const getCompetitionMatchesSportsSportIdQueryKey = (options: Options<GetCompetitionMatchesSportsSportIdData>) => createQueryKey('getCompetitionMatchesSportsSportId', options);

/**
 * Get Matches For Sport And Edition
 */
export const getCompetitionMatchesSportsSportIdOptions = (options: Options<GetCompetitionMatchesSportsSportIdData>) => queryOptions<GetCompetitionMatchesSportsSportIdResponse, GetCompetitionMatchesSportsSportIdError, GetCompetitionMatchesSportsSportIdResponse, ReturnType<typeof getCompetitionMatchesSportsSportIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionMatchesSportsSportId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionMatchesSportsSportIdQueryKey(options)
});

/**
 * Create Match
 */
export const postCompetitionMatchesSportsSportIdMutation = (options?: Partial<Options<PostCompetitionMatchesSportsSportIdData>>): UseMutationOptions<PostCompetitionMatchesSportsSportIdResponse, PostCompetitionMatchesSportsSportIdError, Options<PostCompetitionMatchesSportsSportIdData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionMatchesSportsSportIdResponse, PostCompetitionMatchesSportsSportIdError, Options<PostCompetitionMatchesSportsSportIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionMatchesSportsSportId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionMatchesSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionMatchesSchoolsSchoolIdData>) => createQueryKey('getCompetitionMatchesSchoolsSchoolId', options);

/**
 * Get Matches For School Sport And Edition
 */
export const getCompetitionMatchesSchoolsSchoolIdOptions = (options: Options<GetCompetitionMatchesSchoolsSchoolIdData>) => queryOptions<GetCompetitionMatchesSchoolsSchoolIdResponse, GetCompetitionMatchesSchoolsSchoolIdError, GetCompetitionMatchesSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionMatchesSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionMatchesSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionMatchesSchoolsSchoolIdQueryKey(options)
});

/**
 * Delete Match
 */
export const deleteCompetitionMatchesMatchIdMutation = (options?: Partial<Options<DeleteCompetitionMatchesMatchIdData>>): UseMutationOptions<DeleteCompetitionMatchesMatchIdResponse, DeleteCompetitionMatchesMatchIdError, Options<DeleteCompetitionMatchesMatchIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionMatchesMatchIdResponse, DeleteCompetitionMatchesMatchIdError, Options<DeleteCompetitionMatchesMatchIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionMatchesMatchId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Match
 */
export const patchCompetitionMatchesMatchIdMutation = (options?: Partial<Options<PatchCompetitionMatchesMatchIdData>>): UseMutationOptions<PatchCompetitionMatchesMatchIdResponse, PatchCompetitionMatchesMatchIdError, Options<PatchCompetitionMatchesMatchIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionMatchesMatchIdResponse, PatchCompetitionMatchesMatchIdError, Options<PatchCompetitionMatchesMatchIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionMatchesMatchId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionPodiumsGlobalQueryKey = (options?: Options<GetCompetitionPodiumsGlobalData>) => createQueryKey('getCompetitionPodiumsGlobal', options);

/**
 * Get Global Podiums
 *
 * Get the global podiums for the current edition.
 */
export const getCompetitionPodiumsGlobalOptions = (options?: Options<GetCompetitionPodiumsGlobalData>) => queryOptions<GetCompetitionPodiumsGlobalResponse, DefaultError, GetCompetitionPodiumsGlobalResponse, ReturnType<typeof getCompetitionPodiumsGlobalQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionPodiumsGlobal({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionPodiumsGlobalQueryKey(options)
});

/**
 * Delete Sport Podium
 *
 * Delete the podium for a specific sport in the current edition.
 */
export const deleteCompetitionPodiumsSportsSportIdMutation = (options?: Partial<Options<DeleteCompetitionPodiumsSportsSportIdData>>): UseMutationOptions<DeleteCompetitionPodiumsSportsSportIdResponse, DeleteCompetitionPodiumsSportsSportIdError, Options<DeleteCompetitionPodiumsSportsSportIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionPodiumsSportsSportIdResponse, DeleteCompetitionPodiumsSportsSportIdError, Options<DeleteCompetitionPodiumsSportsSportIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionPodiumsSportsSportId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionPodiumsSportsSportIdQueryKey = (options: Options<GetCompetitionPodiumsSportsSportIdData>) => createQueryKey('getCompetitionPodiumsSportsSportId', options);

/**
 * Get Sport Podiums
 *
 * Get the podiums for a specific sport in the current edition.
 */
export const getCompetitionPodiumsSportsSportIdOptions = (options: Options<GetCompetitionPodiumsSportsSportIdData>) => queryOptions<GetCompetitionPodiumsSportsSportIdResponse, GetCompetitionPodiumsSportsSportIdError, GetCompetitionPodiumsSportsSportIdResponse, ReturnType<typeof getCompetitionPodiumsSportsSportIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionPodiumsSportsSportId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionPodiumsSportsSportIdQueryKey(options)
});

/**
 * Create Sport Podium
 *
 * Create or update the podium for a specific sport in the current edition.
 */
export const postCompetitionPodiumsSportsSportIdMutation = (options?: Partial<Options<PostCompetitionPodiumsSportsSportIdData>>): UseMutationOptions<PostCompetitionPodiumsSportsSportIdResponse, PostCompetitionPodiumsSportsSportIdError, Options<PostCompetitionPodiumsSportsSportIdData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionPodiumsSportsSportIdResponse, PostCompetitionPodiumsSportsSportIdError, Options<PostCompetitionPodiumsSportsSportIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionPodiumsSportsSportId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionPodiumsSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionPodiumsSchoolsSchoolIdData>) => createQueryKey('getCompetitionPodiumsSchoolsSchoolId', options);

/**
 * Get School Podiums
 *
 * Get the podiums for a specific school in the current edition.
 */
export const getCompetitionPodiumsSchoolsSchoolIdOptions = (options: Options<GetCompetitionPodiumsSchoolsSchoolIdData>) => queryOptions<GetCompetitionPodiumsSchoolsSchoolIdResponse, GetCompetitionPodiumsSchoolsSchoolIdError, GetCompetitionPodiumsSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionPodiumsSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionPodiumsSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionPodiumsSchoolsSchoolIdQueryKey(options)
});

export const getCompetitionProductsQueryKey = (options?: Options<GetCompetitionProductsData>) => createQueryKey('getCompetitionProducts', options);

/**
 * Get All Products
 *
 * Get all products.
 */
export const getCompetitionProductsOptions = (options?: Options<GetCompetitionProductsData>) => queryOptions<GetCompetitionProductsResponse, DefaultError, GetCompetitionProductsResponse, ReturnType<typeof getCompetitionProductsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionProducts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionProductsQueryKey(options)
});

/**
 * Create Product
 *
 * Create a product.
 */
export const postCompetitionProductsMutation = (options?: Partial<Options<PostCompetitionProductsData>>): UseMutationOptions<PostCompetitionProductsResponse, PostCompetitionProductsError, Options<PostCompetitionProductsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionProductsResponse, PostCompetitionProductsError, Options<PostCompetitionProductsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionProducts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Product
 *
 * Delete a product.
 *
 * **User must be a competition admin to use this endpoint**
 */
export const deleteCompetitionProductsProductIdMutation = (options?: Partial<Options<DeleteCompetitionProductsProductIdData>>): UseMutationOptions<DeleteCompetitionProductsProductIdResponse, DeleteCompetitionProductsProductIdError, Options<DeleteCompetitionProductsProductIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionProductsProductIdResponse, DeleteCompetitionProductsProductIdError, Options<DeleteCompetitionProductsProductIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionProductsProductId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Product
 *
 * Edit a product.
 *
 * **User must be a competition admin to use this endpoint**
 */
export const patchCompetitionProductsProductIdMutation = (options?: Partial<Options<PatchCompetitionProductsProductIdData>>): UseMutationOptions<PatchCompetitionProductsProductIdResponse, PatchCompetitionProductsProductIdError, Options<PatchCompetitionProductsProductIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionProductsProductIdResponse, PatchCompetitionProductsProductIdError, Options<PatchCompetitionProductsProductIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionProductsProductId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionProductsAvailableQueryKey = (options?: Options<GetCompetitionProductsAvailableData>) => createQueryKey('getCompetitionProductsAvailable', options);

/**
 * Get Available Product Variants
 *
 * Get all available product variants of the current edition for this user.
 */
export const getCompetitionProductsAvailableOptions = (options?: Options<GetCompetitionProductsAvailableData>) => queryOptions<GetCompetitionProductsAvailableResponse, DefaultError, GetCompetitionProductsAvailableResponse, ReturnType<typeof getCompetitionProductsAvailableQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionProductsAvailable({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionProductsAvailableQueryKey(options)
});

/**
 * Create Product Variant
 *
 * Create a product variant.
 *
 * **User must be a competition admin to use this endpoint**
 */
export const postCompetitionProductsProductIdVariantsMutation = (options?: Partial<Options<PostCompetitionProductsProductIdVariantsData>>): UseMutationOptions<PostCompetitionProductsProductIdVariantsResponse, PostCompetitionProductsProductIdVariantsError, Options<PostCompetitionProductsProductIdVariantsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionProductsProductIdVariantsResponse, PostCompetitionProductsProductIdVariantsError, Options<PostCompetitionProductsProductIdVariantsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionProductsProductIdVariants({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Product Variant
 *
 * Delete a product variant.
 *
 * **User must be a competition admin to use this endpoint**
 */
export const deleteCompetitionProductsVariantsVariantIdMutation = (options?: Partial<Options<DeleteCompetitionProductsVariantsVariantIdData>>): UseMutationOptions<DeleteCompetitionProductsVariantsVariantIdResponse, DeleteCompetitionProductsVariantsVariantIdError, Options<DeleteCompetitionProductsVariantsVariantIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionProductsVariantsVariantIdResponse, DeleteCompetitionProductsVariantsVariantIdError, Options<DeleteCompetitionProductsVariantsVariantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionProductsVariantsVariantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Product Variant
 *
 * Edit a product variant.
 *
 * **User must be a competition admin to use this endpoint**
 */
export const patchCompetitionProductsVariantsVariantIdMutation = (options?: Partial<Options<PatchCompetitionProductsVariantsVariantIdData>>): UseMutationOptions<PatchCompetitionProductsVariantsVariantIdResponse, PatchCompetitionProductsVariantsVariantIdError, Options<PatchCompetitionProductsVariantsVariantIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionProductsVariantsVariantIdResponse, PatchCompetitionProductsVariantsVariantIdError, Options<PatchCompetitionProductsVariantsVariantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionProductsVariantsVariantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionPurchasesSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionPurchasesSchoolsSchoolIdData>) => createQueryKey('getCompetitionPurchasesSchoolsSchoolId', options);

/**
 * Get Purchases By School Id
 *
 * Get a school's purchases.
 *
 * **User must be competition admin to use this endpoint**
 */
export const getCompetitionPurchasesSchoolsSchoolIdOptions = (options: Options<GetCompetitionPurchasesSchoolsSchoolIdData>) => queryOptions<GetCompetitionPurchasesSchoolsSchoolIdResponse, GetCompetitionPurchasesSchoolsSchoolIdError, GetCompetitionPurchasesSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionPurchasesSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionPurchasesSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionPurchasesSchoolsSchoolIdQueryKey(options)
});

export const getCompetitionPurchasesUsersUserIdQueryKey = (options: Options<GetCompetitionPurchasesUsersUserIdData>) => createQueryKey('getCompetitionPurchasesUsersUserId', options);

/**
 * Get Purchases By User Id
 *
 * Get a user's purchases.
 *
 * **User must be competition admin to use this endpoint**
 */
export const getCompetitionPurchasesUsersUserIdOptions = (options: Options<GetCompetitionPurchasesUsersUserIdData>) => queryOptions<GetCompetitionPurchasesUsersUserIdResponse, GetCompetitionPurchasesUsersUserIdError, GetCompetitionPurchasesUsersUserIdResponse, ReturnType<typeof getCompetitionPurchasesUsersUserIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionPurchasesUsersUserId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionPurchasesUsersUserIdQueryKey(options)
});

export const getCompetitionPurchasesMeQueryKey = (options?: Options<GetCompetitionPurchasesMeData>) => createQueryKey('getCompetitionPurchasesMe', options);

/**
 * Get My Purchases
 */
export const getCompetitionPurchasesMeOptions = (options?: Options<GetCompetitionPurchasesMeData>) => queryOptions<GetCompetitionPurchasesMeResponse, DefaultError, GetCompetitionPurchasesMeResponse, ReturnType<typeof getCompetitionPurchasesMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionPurchasesMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionPurchasesMeQueryKey(options)
});

/**
 * Create Purchase
 *
 * Create a purchase.
 *
 * **User must create a purchase for themself**
 */
export const postCompetitionPurchasesMeMutation = (options?: Partial<Options<PostCompetitionPurchasesMeData>>): UseMutationOptions<PostCompetitionPurchasesMeResponse, PostCompetitionPurchasesMeError, Options<PostCompetitionPurchasesMeData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionPurchasesMeResponse, PostCompetitionPurchasesMeError, Options<PostCompetitionPurchasesMeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionPurchasesMe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Purchase
 *
 * Delete a purchase.
 *
 * **User must delete their own purchase**
 */
export const deleteCompetitionPurchasesProductVariantIdMutation = (options?: Partial<Options<DeleteCompetitionPurchasesProductVariantIdData>>): UseMutationOptions<DeleteCompetitionPurchasesProductVariantIdResponse, DeleteCompetitionPurchasesProductVariantIdError, Options<DeleteCompetitionPurchasesProductVariantIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionPurchasesProductVariantIdResponse, DeleteCompetitionPurchasesProductVariantIdError, Options<DeleteCompetitionPurchasesProductVariantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionPurchasesProductVariantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionPaymentsSchoolsSchoolIdQueryKey = (options: Options<GetCompetitionPaymentsSchoolsSchoolIdData>) => createQueryKey('getCompetitionPaymentsSchoolsSchoolId', options);

/**
 * Get Users Payments By School Id
 *
 * Get a school's users payments.
 *
 * **User must be competition admin to use this endpoint**
 */
export const getCompetitionPaymentsSchoolsSchoolIdOptions = (options: Options<GetCompetitionPaymentsSchoolsSchoolIdData>) => queryOptions<GetCompetitionPaymentsSchoolsSchoolIdResponse, GetCompetitionPaymentsSchoolsSchoolIdError, GetCompetitionPaymentsSchoolsSchoolIdResponse, ReturnType<typeof getCompetitionPaymentsSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionPaymentsSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionPaymentsSchoolsSchoolIdQueryKey(options)
});

export const getCompetitionUsersUserIdPaymentsQueryKey = (options: Options<GetCompetitionUsersUserIdPaymentsData>) => createQueryKey('getCompetitionUsersUserIdPayments', options);

/**
 * Get Payments By User Id
 *
 * Get a user's payments.
 *
 * **User must get his own payments or be competition admin to use this endpoint**
 */
export const getCompetitionUsersUserIdPaymentsOptions = (options: Options<GetCompetitionUsersUserIdPaymentsData>) => queryOptions<GetCompetitionUsersUserIdPaymentsResponse, GetCompetitionUsersUserIdPaymentsError, GetCompetitionUsersUserIdPaymentsResponse, ReturnType<typeof getCompetitionUsersUserIdPaymentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionUsersUserIdPayments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionUsersUserIdPaymentsQueryKey(options)
});

/**
 * Create Payment
 *
 * Create a payment.
 *
 * **User must be competition admin to use this endpoint**
 */
export const postCompetitionUsersUserIdPaymentsMutation = (options?: Partial<Options<PostCompetitionUsersUserIdPaymentsData>>): UseMutationOptions<PostCompetitionUsersUserIdPaymentsResponse, PostCompetitionUsersUserIdPaymentsError, Options<PostCompetitionUsersUserIdPaymentsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionUsersUserIdPaymentsResponse, PostCompetitionUsersUserIdPaymentsError, Options<PostCompetitionUsersUserIdPaymentsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionUsersUserIdPayments({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Payment
 *
 * Remove a payment.
 *
 * **User must be competition admin to use this endpoint**
 */
export const deleteCompetitionUsersUserIdPaymentsPaymentIdMutation = (options?: Partial<Options<DeleteCompetitionUsersUserIdPaymentsPaymentIdData>>): UseMutationOptions<DeleteCompetitionUsersUserIdPaymentsPaymentIdResponse, DeleteCompetitionUsersUserIdPaymentsPaymentIdError, Options<DeleteCompetitionUsersUserIdPaymentsPaymentIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionUsersUserIdPaymentsPaymentIdResponse, DeleteCompetitionUsersUserIdPaymentsPaymentIdError, Options<DeleteCompetitionUsersUserIdPaymentsPaymentIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionUsersUserIdPaymentsPaymentId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get Payment Url
 *
 * Get payment url
 */
export const postCompetitionPayMutation = (options?: Partial<Options<PostCompetitionPayData>>): UseMutationOptions<PostCompetitionPayResponse, DefaultError, Options<PostCompetitionPayData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionPayResponse, DefaultError, Options<PostCompetitionPayData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionPay({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionVolunteersShiftsQueryKey = (options?: Options<GetCompetitionVolunteersShiftsData>) => createQueryKey('getCompetitionVolunteersShifts', options);

/**
 * Get All Volunteer Shifts
 *
 * Get all volunteer shifts.
 */
export const getCompetitionVolunteersShiftsOptions = (options?: Options<GetCompetitionVolunteersShiftsData>) => queryOptions<GetCompetitionVolunteersShiftsResponse, DefaultError, GetCompetitionVolunteersShiftsResponse, ReturnType<typeof getCompetitionVolunteersShiftsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionVolunteersShifts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionVolunteersShiftsQueryKey(options)
});

/**
 * Create Volunteer Shift
 *
 * Create a volunteer shift.
 */
export const postCompetitionVolunteersShiftsMutation = (options?: Partial<Options<PostCompetitionVolunteersShiftsData>>): UseMutationOptions<PostCompetitionVolunteersShiftsResponse, PostCompetitionVolunteersShiftsError, Options<PostCompetitionVolunteersShiftsData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionVolunteersShiftsResponse, PostCompetitionVolunteersShiftsError, Options<PostCompetitionVolunteersShiftsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionVolunteersShifts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Volunteer Shift
 *
 * Delete a volunteer shift.
 *
 * **User must be a competition admin to use this endpoint**
 */
export const deleteCompetitionVolunteersShiftsShiftIdMutation = (options?: Partial<Options<DeleteCompetitionVolunteersShiftsShiftIdData>>): UseMutationOptions<DeleteCompetitionVolunteersShiftsShiftIdResponse, DeleteCompetitionVolunteersShiftsShiftIdError, Options<DeleteCompetitionVolunteersShiftsShiftIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCompetitionVolunteersShiftsShiftIdResponse, DeleteCompetitionVolunteersShiftsShiftIdError, Options<DeleteCompetitionVolunteersShiftsShiftIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCompetitionVolunteersShiftsShiftId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Volunteer Shift
 *
 * Edit a volunteer shift.
 *
 * **User must be a competition admin to use this endpoint**
 */
export const patchCompetitionVolunteersShiftsShiftIdMutation = (options?: Partial<Options<PatchCompetitionVolunteersShiftsShiftIdData>>): UseMutationOptions<PatchCompetitionVolunteersShiftsShiftIdResponse, PatchCompetitionVolunteersShiftsShiftIdError, Options<PatchCompetitionVolunteersShiftsShiftIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCompetitionVolunteersShiftsShiftIdResponse, PatchCompetitionVolunteersShiftsShiftIdError, Options<PatchCompetitionVolunteersShiftsShiftIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCompetitionVolunteersShiftsShiftId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCompetitionVolunteersMeQueryKey = (options?: Options<GetCompetitionVolunteersMeData>) => createQueryKey('getCompetitionVolunteersMe', options);

/**
 * Get My Volunteer Registrations
 *
 * Get my volunteer registrations.
 */
export const getCompetitionVolunteersMeOptions = (options?: Options<GetCompetitionVolunteersMeData>) => queryOptions<GetCompetitionVolunteersMeResponse, DefaultError, GetCompetitionVolunteersMeResponse, ReturnType<typeof getCompetitionVolunteersMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCompetitionVolunteersMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCompetitionVolunteersMeQueryKey(options)
});

/**
 * Register To Volunteer Shift
 *
 * Register to a volunteer shift.
 */
export const postCompetitionVolunteersShiftsShiftIdRegisterMutation = (options?: Partial<Options<PostCompetitionVolunteersShiftsShiftIdRegisterData>>): UseMutationOptions<PostCompetitionVolunteersShiftsShiftIdRegisterResponse, PostCompetitionVolunteersShiftsShiftIdRegisterError, Options<PostCompetitionVolunteersShiftsShiftIdRegisterData>> => {
    const mutationOptions: UseMutationOptions<PostCompetitionVolunteersShiftsShiftIdRegisterResponse, PostCompetitionVolunteersShiftsShiftIdRegisterError, Options<PostCompetitionVolunteersShiftsShiftIdRegisterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCompetitionVolunteersShiftsShiftIdRegister({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCalendarEventsQueryKey = (options?: Options<GetCalendarEventsData>) => createQueryKey('getCalendarEvents', options);

/**
 * Get Events
 *
 * Get all events from the database.
 */
export const getCalendarEventsOptions = (options?: Options<GetCalendarEventsData>) => queryOptions<GetCalendarEventsResponse, DefaultError, GetCalendarEventsResponse, ReturnType<typeof getCalendarEventsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCalendarEvents({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCalendarEventsQueryKey(options)
});

/**
 * Add Event
 *
 * Add an event to the calendar.
 */
export const postCalendarEventsMutation = (options?: Partial<Options<PostCalendarEventsData>>): UseMutationOptions<PostCalendarEventsResponse, PostCalendarEventsError, Options<PostCalendarEventsData>> => {
    const mutationOptions: UseMutationOptions<PostCalendarEventsResponse, PostCalendarEventsError, Options<PostCalendarEventsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCalendarEvents({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCalendarEventsConfirmedQueryKey = (options?: Options<GetCalendarEventsConfirmedData>) => createQueryKey('getCalendarEventsConfirmed', options);

/**
 * Get Confirmed Events
 *
 * Get all confirmed events.
 *
 * **Usable by every member**
 */
export const getCalendarEventsConfirmedOptions = (options?: Options<GetCalendarEventsConfirmedData>) => queryOptions<GetCalendarEventsConfirmedResponse, DefaultError, GetCalendarEventsConfirmedResponse, ReturnType<typeof getCalendarEventsConfirmedQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCalendarEventsConfirmed({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCalendarEventsConfirmedQueryKey(options)
});

export const getCalendarEventsUserApplicantIdQueryKey = (options: Options<GetCalendarEventsUserApplicantIdData>) => createQueryKey('getCalendarEventsUserApplicantId', options);

/**
 * Get Applicant Bookings
 *
 * Get one user bookings.
 *
 * **Usable by the user or admins**
 */
export const getCalendarEventsUserApplicantIdOptions = (options: Options<GetCalendarEventsUserApplicantIdData>) => queryOptions<GetCalendarEventsUserApplicantIdResponse, GetCalendarEventsUserApplicantIdError, GetCalendarEventsUserApplicantIdResponse, ReturnType<typeof getCalendarEventsUserApplicantIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCalendarEventsUserApplicantId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCalendarEventsUserApplicantIdQueryKey(options)
});

/**
 * Delete Bookings Id
 *
 * Remove an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const deleteCalendarEventsEventIdMutation = (options?: Partial<Options<DeleteCalendarEventsEventIdData>>): UseMutationOptions<DeleteCalendarEventsEventIdResponse, DeleteCalendarEventsEventIdError, Options<DeleteCalendarEventsEventIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCalendarEventsEventIdResponse, DeleteCalendarEventsEventIdError, Options<DeleteCalendarEventsEventIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCalendarEventsEventId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCalendarEventsEventIdQueryKey = (options: Options<GetCalendarEventsEventIdData>) => createQueryKey('getCalendarEventsEventId', options);

/**
 * Get Event By Id
 *
 * Get an event's information by its id.
 */
export const getCalendarEventsEventIdOptions = (options: Options<GetCalendarEventsEventIdData>) => queryOptions<GetCalendarEventsEventIdResponse, GetCalendarEventsEventIdError, GetCalendarEventsEventIdResponse, ReturnType<typeof getCalendarEventsEventIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCalendarEventsEventId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCalendarEventsEventIdQueryKey(options)
});

/**
 * Edit Bookings Id
 *
 * Edit an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const patchCalendarEventsEventIdMutation = (options?: Partial<Options<PatchCalendarEventsEventIdData>>): UseMutationOptions<PatchCalendarEventsEventIdResponse, PatchCalendarEventsEventIdError, Options<PatchCalendarEventsEventIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCalendarEventsEventIdResponse, PatchCalendarEventsEventIdError, Options<PatchCalendarEventsEventIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCalendarEventsEventId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCalendarEventsEventIdApplicantQueryKey = (options: Options<GetCalendarEventsEventIdApplicantData>) => createQueryKey('getCalendarEventsEventIdApplicant', options);

/**
 * Get Event Applicant
 */
export const getCalendarEventsEventIdApplicantOptions = (options: Options<GetCalendarEventsEventIdApplicantData>) => queryOptions<GetCalendarEventsEventIdApplicantResponse, GetCalendarEventsEventIdApplicantError, GetCalendarEventsEventIdApplicantResponse, ReturnType<typeof getCalendarEventsEventIdApplicantQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCalendarEventsEventIdApplicant({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCalendarEventsEventIdApplicantQueryKey(options)
});

/**
 * Confirm Booking
 *
 * Give a decision to an event.
 *
 * **Only usable by admins**
 */
export const patchCalendarEventsEventIdReplyDecisionMutation = (options?: Partial<Options<PatchCalendarEventsEventIdReplyDecisionData>>): UseMutationOptions<PatchCalendarEventsEventIdReplyDecisionResponse, PatchCalendarEventsEventIdReplyDecisionError, Options<PatchCalendarEventsEventIdReplyDecisionData>> => {
    const mutationOptions: UseMutationOptions<PatchCalendarEventsEventIdReplyDecisionResponse, PatchCalendarEventsEventIdReplyDecisionError, Options<PatchCalendarEventsEventIdReplyDecisionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCalendarEventsEventIdReplyDecision({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Recreate Ical File
 *
 * Create manually the icalendar file
 *
 * **Only usable by global admins**
 */
export const postCalendarIcalCreateMutation = (options?: Partial<Options<PostCalendarIcalCreateData>>): UseMutationOptions<PostCalendarIcalCreateResponse, DefaultError, Options<PostCalendarIcalCreateData>> => {
    const mutationOptions: UseMutationOptions<PostCalendarIcalCreateResponse, DefaultError, Options<PostCalendarIcalCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCalendarIcalCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCalendarIcalQueryKey = (options?: Options<GetCalendarIcalData>) => createQueryKey('getCalendarIcal', options);

/**
 * Get Icalendar File
 *
 * Get the icalendar file corresponding to the event in the database.
 */
export const getCalendarIcalOptions = (options?: Options<GetCalendarIcalData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getCalendarIcalQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCalendarIcal({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCalendarIcalQueryKey(options)
});

export const getCdrUsersQueryKey = (options?: Options<GetCdrUsersData>) => createQueryKey('getCdrUsers', options);

/**
 * Get Cdr Users
 *
 * Get all users.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const getCdrUsersOptions = (options?: Options<GetCdrUsersData>) => queryOptions<GetCdrUsersResponse, DefaultError, GetCdrUsersResponse, ReturnType<typeof getCdrUsersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersQueryKey(options)
});

export const getCdrUsersPendingQueryKey = (options?: Options<GetCdrUsersPendingData>) => createQueryKey('getCdrUsersPending', options);

/**
 * Get Cdr Users Pending Validation
 *
 * Get all users that have non-validated purchases.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const getCdrUsersPendingOptions = (options?: Options<GetCdrUsersPendingData>) => queryOptions<GetCdrUsersPendingResponse, DefaultError, GetCdrUsersPendingResponse, ReturnType<typeof getCdrUsersPendingQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersPending({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersPendingQueryKey(options)
});

export const getCdrUsersUserIdQueryKey = (options: Options<GetCdrUsersUserIdData>) => createQueryKey('getCdrUsersUserId', options);

/**
 * Get Cdr User
 *
 * Get a user.
 *
 * **User must be part of a seller group or trying to get itself to use this endpoint**
 */
export const getCdrUsersUserIdOptions = (options: Options<GetCdrUsersUserIdData>) => queryOptions<GetCdrUsersUserIdResponse, GetCdrUsersUserIdError, GetCdrUsersUserIdResponse, ReturnType<typeof getCdrUsersUserIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersUserId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersUserIdQueryKey(options)
});

/**
 * Update Cdr User
 *
 * Edit a user email, nickname and/or floor.
 *
 * An email will be send to the user, to confirm its new address.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const patchCdrUsersUserIdMutation = (options?: Partial<Options<PatchCdrUsersUserIdData>>): UseMutationOptions<PatchCdrUsersUserIdResponse, PatchCdrUsersUserIdError, Options<PatchCdrUsersUserIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrUsersUserIdResponse, PatchCdrUsersUserIdError, Options<PatchCdrUsersUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrUsersUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrSellersQueryKey = (options?: Options<GetCdrSellersData>) => createQueryKey('getCdrSellers', options);

/**
 * Get Sellers
 *
 * Get all sellers.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const getCdrSellersOptions = (options?: Options<GetCdrSellersData>) => queryOptions<GetCdrSellersResponse, DefaultError, GetCdrSellersResponse, ReturnType<typeof getCdrSellersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersQueryKey(options)
});

/**
 * Create Seller
 *
 * Create a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const postCdrSellersMutation = (options?: Partial<Options<PostCdrSellersData>>): UseMutationOptions<PostCdrSellersResponse, PostCdrSellersError, Options<PostCdrSellersData>> => {
    const mutationOptions: UseMutationOptions<PostCdrSellersResponse, PostCdrSellersError, Options<PostCdrSellersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrSellers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrUsersMeSellersQueryKey = (options?: Options<GetCdrUsersMeSellersData>) => createQueryKey('getCdrUsersMeSellers', options);

/**
 * Get Sellers By User Id
 *
 * Get sellers user is part of the group. If user is adminCDR, returns all sellers.
 *
 * **User must be authenticated to use this endpoint**
 */
export const getCdrUsersMeSellersOptions = (options?: Options<GetCdrUsersMeSellersData>) => queryOptions<GetCdrUsersMeSellersResponse, DefaultError, GetCdrUsersMeSellersResponse, ReturnType<typeof getCdrUsersMeSellersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersMeSellers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersMeSellersQueryKey(options)
});

export const getCdrOnlineSellersQueryKey = (options?: Options<GetCdrOnlineSellersData>) => createQueryKey('getCdrOnlineSellers', options);

/**
 * Get Online Sellers
 *
 * Get all sellers that has online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const getCdrOnlineSellersOptions = (options?: Options<GetCdrOnlineSellersData>) => queryOptions<GetCdrOnlineSellersResponse, DefaultError, GetCdrOnlineSellersResponse, ReturnType<typeof getCdrOnlineSellersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrOnlineSellers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrOnlineSellersQueryKey(options)
});

export const getCdrSellersSellerIdResultsQueryKey = (options: Options<GetCdrSellersSellerIdResultsData>) => createQueryKey('getCdrSellersSellerIdResults', options);

/**
 * Send Seller Results
 *
 * Get a seller's results.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const getCdrSellersSellerIdResultsOptions = (options: Options<GetCdrSellersSellerIdResultsData>) => queryOptions<unknown, GetCdrSellersSellerIdResultsError, unknown, ReturnType<typeof getCdrSellersSellerIdResultsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdResults({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdResultsQueryKey(options)
});

export const getCdrOnlineProductsQueryKey = (options?: Options<GetCdrOnlineProductsData>) => createQueryKey('getCdrOnlineProducts', options);

/**
 * Get All Available Online Products
 *
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const getCdrOnlineProductsOptions = (options?: Options<GetCdrOnlineProductsData>) => queryOptions<GetCdrOnlineProductsResponse, DefaultError, GetCdrOnlineProductsResponse, ReturnType<typeof getCdrOnlineProductsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrOnlineProducts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrOnlineProductsQueryKey(options)
});

export const getCdrProductsQueryKey = (options?: Options<GetCdrProductsData>) => createQueryKey('getCdrProducts', options);

/**
 * Get All Products
 *
 * Get a seller's online available products.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const getCdrProductsOptions = (options?: Options<GetCdrProductsData>) => queryOptions<GetCdrProductsResponse, DefaultError, GetCdrProductsResponse, ReturnType<typeof getCdrProductsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrProducts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrProductsQueryKey(options)
});

/**
 * Delete Seller
 *
 * Delete a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const deleteCdrSellersSellerIdMutation = (options?: Partial<Options<DeleteCdrSellersSellerIdData>>): UseMutationOptions<DeleteCdrSellersSellerIdResponse, DeleteCdrSellersSellerIdError, Options<DeleteCdrSellersSellerIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrSellersSellerIdResponse, DeleteCdrSellersSellerIdError, Options<DeleteCdrSellersSellerIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrSellersSellerId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Seller
 *
 * Update a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const patchCdrSellersSellerIdMutation = (options?: Partial<Options<PatchCdrSellersSellerIdData>>): UseMutationOptions<PatchCdrSellersSellerIdResponse, PatchCdrSellersSellerIdError, Options<PatchCdrSellersSellerIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrSellersSellerIdResponse, PatchCdrSellersSellerIdError, Options<PatchCdrSellersSellerIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrSellersSellerId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrSellersSellerIdProductsQueryKey = (options: Options<GetCdrSellersSellerIdProductsData>) => createQueryKey('getCdrSellersSellerIdProducts', options);

/**
 * Get Products By Seller Id
 *
 * Get a seller's products.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const getCdrSellersSellerIdProductsOptions = (options: Options<GetCdrSellersSellerIdProductsData>) => queryOptions<GetCdrSellersSellerIdProductsResponse, GetCdrSellersSellerIdProductsError, GetCdrSellersSellerIdProductsResponse, ReturnType<typeof getCdrSellersSellerIdProductsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdProducts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdProductsQueryKey(options)
});

/**
 * Create Product
 *
 * Create a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const postCdrSellersSellerIdProductsMutation = (options?: Partial<Options<PostCdrSellersSellerIdProductsData>>): UseMutationOptions<PostCdrSellersSellerIdProductsResponse, PostCdrSellersSellerIdProductsError, Options<PostCdrSellersSellerIdProductsData>> => {
    const mutationOptions: UseMutationOptions<PostCdrSellersSellerIdProductsResponse, PostCdrSellersSellerIdProductsError, Options<PostCdrSellersSellerIdProductsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrSellersSellerIdProducts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrOnlineSellersSellerIdProductsQueryKey = (options: Options<GetCdrOnlineSellersSellerIdProductsData>) => createQueryKey('getCdrOnlineSellersSellerIdProducts', options);

/**
 * Get Available Online Products
 *
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const getCdrOnlineSellersSellerIdProductsOptions = (options: Options<GetCdrOnlineSellersSellerIdProductsData>) => queryOptions<GetCdrOnlineSellersSellerIdProductsResponse, GetCdrOnlineSellersSellerIdProductsError, GetCdrOnlineSellersSellerIdProductsResponse, ReturnType<typeof getCdrOnlineSellersSellerIdProductsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrOnlineSellersSellerIdProducts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrOnlineSellersSellerIdProductsQueryKey(options)
});

/**
 * Delete Product
 *
 * Delete a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const deleteCdrSellersSellerIdProductsProductIdMutation = (options?: Partial<Options<DeleteCdrSellersSellerIdProductsProductIdData>>): UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdResponse, DeleteCdrSellersSellerIdProductsProductIdError, Options<DeleteCdrSellersSellerIdProductsProductIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdResponse, DeleteCdrSellersSellerIdProductsProductIdError, Options<DeleteCdrSellersSellerIdProductsProductIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrSellersSellerIdProductsProductId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Product
 *
 * Edit a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const patchCdrSellersSellerIdProductsProductIdMutation = (options?: Partial<Options<PatchCdrSellersSellerIdProductsProductIdData>>): UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdResponse, PatchCdrSellersSellerIdProductsProductIdError, Options<PatchCdrSellersSellerIdProductsProductIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdResponse, PatchCdrSellersSellerIdProductsProductIdError, Options<PatchCdrSellersSellerIdProductsProductIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrSellersSellerIdProductsProductId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Product Variant
 *
 * Create a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const postCdrSellersSellerIdProductsProductIdVariantsMutation = (options?: Partial<Options<PostCdrSellersSellerIdProductsProductIdVariantsData>>): UseMutationOptions<PostCdrSellersSellerIdProductsProductIdVariantsResponse, PostCdrSellersSellerIdProductsProductIdVariantsError, Options<PostCdrSellersSellerIdProductsProductIdVariantsData>> => {
    const mutationOptions: UseMutationOptions<PostCdrSellersSellerIdProductsProductIdVariantsResponse, PostCdrSellersSellerIdProductsProductIdVariantsError, Options<PostCdrSellersSellerIdProductsProductIdVariantsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrSellersSellerIdProductsProductIdVariants({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Product Variant
 *
 * Delete a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const deleteCdrSellersSellerIdProductsProductIdVariantsVariantIdMutation = (options?: Partial<Options<DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdData>>): UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdResponse, DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError, Options<DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdResponse, DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError, Options<DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrSellersSellerIdProductsProductIdVariantsVariantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Product Variant
 *
 * Edit a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const patchCdrSellersSellerIdProductsProductIdVariantsVariantIdMutation = (options?: Partial<Options<PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdData>>): UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdResponse, PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError, Options<PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdResponse, PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError, Options<PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrSellersSellerIdProductsProductIdVariantsVariantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrSellersSellerIdDocumentsQueryKey = (options: Options<GetCdrSellersSellerIdDocumentsData>) => createQueryKey('getCdrSellersSellerIdDocuments', options);

/**
 * Get Seller Documents
 *
 * Get a seller's documents.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const getCdrSellersSellerIdDocumentsOptions = (options: Options<GetCdrSellersSellerIdDocumentsData>) => queryOptions<GetCdrSellersSellerIdDocumentsResponse, GetCdrSellersSellerIdDocumentsError, GetCdrSellersSellerIdDocumentsResponse, ReturnType<typeof getCdrSellersSellerIdDocumentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdDocuments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdDocumentsQueryKey(options)
});

/**
 * Create Document
 *
 * Create a document.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const postCdrSellersSellerIdDocumentsMutation = (options?: Partial<Options<PostCdrSellersSellerIdDocumentsData>>): UseMutationOptions<PostCdrSellersSellerIdDocumentsResponse, PostCdrSellersSellerIdDocumentsError, Options<PostCdrSellersSellerIdDocumentsData>> => {
    const mutationOptions: UseMutationOptions<PostCdrSellersSellerIdDocumentsResponse, PostCdrSellersSellerIdDocumentsError, Options<PostCdrSellersSellerIdDocumentsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrSellersSellerIdDocuments({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrDocumentsQueryKey = (options?: Options<GetCdrDocumentsData>) => createQueryKey('getCdrDocuments', options);

/**
 * Get All Sellers Documents
 *
 * Get a seller's documents.
 *
 * **User must be part of a seller's group to use this endpoint**
 */
export const getCdrDocumentsOptions = (options?: Options<GetCdrDocumentsData>) => queryOptions<GetCdrDocumentsResponse, DefaultError, GetCdrDocumentsResponse, ReturnType<typeof getCdrDocumentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrDocuments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrDocumentsQueryKey(options)
});

/**
 * Delete Document
 *
 * Delete a document.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const deleteCdrSellersSellerIdDocumentsDocumentIdMutation = (options?: Partial<Options<DeleteCdrSellersSellerIdDocumentsDocumentIdData>>): UseMutationOptions<DeleteCdrSellersSellerIdDocumentsDocumentIdResponse, DeleteCdrSellersSellerIdDocumentsDocumentIdError, Options<DeleteCdrSellersSellerIdDocumentsDocumentIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrSellersSellerIdDocumentsDocumentIdResponse, DeleteCdrSellersSellerIdDocumentsDocumentIdError, Options<DeleteCdrSellersSellerIdDocumentsDocumentIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrSellersSellerIdDocumentsDocumentId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrUsersUserIdPurchasesQueryKey = (options: Options<GetCdrUsersUserIdPurchasesData>) => createQueryKey('getCdrUsersUserIdPurchases', options);

/**
 * Get Purchases By User Id
 *
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export const getCdrUsersUserIdPurchasesOptions = (options: Options<GetCdrUsersUserIdPurchasesData>) => queryOptions<GetCdrUsersUserIdPurchasesResponse, GetCdrUsersUserIdPurchasesError, GetCdrUsersUserIdPurchasesResponse, ReturnType<typeof getCdrUsersUserIdPurchasesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersUserIdPurchases({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersUserIdPurchasesQueryKey(options)
});

export const getCdrMePurchasesQueryKey = (options?: Options<GetCdrMePurchasesData>) => createQueryKey('getCdrMePurchases', options);

/**
 * Get My Purchases
 */
export const getCdrMePurchasesOptions = (options?: Options<GetCdrMePurchasesData>) => queryOptions<GetCdrMePurchasesResponse, DefaultError, GetCdrMePurchasesResponse, ReturnType<typeof getCdrMePurchasesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrMePurchases({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrMePurchasesQueryKey(options)
});

export const getCdrSellersSellerIdUsersUserIdPurchasesQueryKey = (options: Options<GetCdrSellersSellerIdUsersUserIdPurchasesData>) => createQueryKey('getCdrSellersSellerIdUsersUserIdPurchases', options);

/**
 * Get Purchases By User Id By Seller Id
 *
 * Get a user's purchases.
 *
 * **User must get his own purchases or be part of the seller's group to use this endpoint**
 */
export const getCdrSellersSellerIdUsersUserIdPurchasesOptions = (options: Options<GetCdrSellersSellerIdUsersUserIdPurchasesData>) => queryOptions<GetCdrSellersSellerIdUsersUserIdPurchasesResponse, GetCdrSellersSellerIdUsersUserIdPurchasesError, GetCdrSellersSellerIdUsersUserIdPurchasesResponse, ReturnType<typeof getCdrSellersSellerIdUsersUserIdPurchasesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdUsersUserIdPurchases({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdUsersUserIdPurchasesQueryKey(options)
});

/**
 * Delete Purchase
 *
 * Delete a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const deleteCdrUsersUserIdPurchasesProductVariantIdMutation = (options?: Partial<Options<DeleteCdrUsersUserIdPurchasesProductVariantIdData>>): UseMutationOptions<DeleteCdrUsersUserIdPurchasesProductVariantIdResponse, DeleteCdrUsersUserIdPurchasesProductVariantIdError, Options<DeleteCdrUsersUserIdPurchasesProductVariantIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrUsersUserIdPurchasesProductVariantIdResponse, DeleteCdrUsersUserIdPurchasesProductVariantIdError, Options<DeleteCdrUsersUserIdPurchasesProductVariantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrUsersUserIdPurchasesProductVariantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Purchase
 *
 * Create a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const postCdrUsersUserIdPurchasesProductVariantIdMutation = (options?: Partial<Options<PostCdrUsersUserIdPurchasesProductVariantIdData>>): UseMutationOptions<PostCdrUsersUserIdPurchasesProductVariantIdResponse, PostCdrUsersUserIdPurchasesProductVariantIdError, Options<PostCdrUsersUserIdPurchasesProductVariantIdData>> => {
    const mutationOptions: UseMutationOptions<PostCdrUsersUserIdPurchasesProductVariantIdResponse, PostCdrUsersUserIdPurchasesProductVariantIdError, Options<PostCdrUsersUserIdPurchasesProductVariantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrUsersUserIdPurchasesProductVariantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Purchase Batch
 *
 * Create a purchase for a list of user.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const postCdrBatchPurchasesMutation = (options?: Partial<Options<PostCdrBatchPurchasesData>>): UseMutationOptions<unknown, PostCdrBatchPurchasesError, Options<PostCdrBatchPurchasesData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostCdrBatchPurchasesError, Options<PostCdrBatchPurchasesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrBatchPurchases({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Mark Purchase As Validated
 *
 * Validate a purchase.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const patchCdrUsersUserIdPurchasesProductVariantIdValidatedMutation = (options?: Partial<Options<PatchCdrUsersUserIdPurchasesProductVariantIdValidatedData>>): UseMutationOptions<PatchCdrUsersUserIdPurchasesProductVariantIdValidatedResponse, PatchCdrUsersUserIdPurchasesProductVariantIdValidatedError, Options<PatchCdrUsersUserIdPurchasesProductVariantIdValidatedData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrUsersUserIdPurchasesProductVariantIdValidatedResponse, PatchCdrUsersUserIdPurchasesProductVariantIdValidatedError, Options<PatchCdrUsersUserIdPurchasesProductVariantIdValidatedData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrUsersUserIdPurchasesProductVariantIdValidated({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Validate Purchase Batch
 */
export const postCdrBatchValidationMutation = (options?: Partial<Options<PostCdrBatchValidationData>>): UseMutationOptions<unknown, PostCdrBatchValidationError, Options<PostCdrBatchValidationData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostCdrBatchValidationError, Options<PostCdrBatchValidationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrBatchValidation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrUsersUserIdSignaturesQueryKey = (options: Options<GetCdrUsersUserIdSignaturesData>) => createQueryKey('getCdrUsersUserIdSignatures', options);

/**
 * Get Signatures By User Id
 *
 * Get a user's signatures.
 *
 * **User must get his own signatures or be CDR Admin to use this endpoint**
 */
export const getCdrUsersUserIdSignaturesOptions = (options: Options<GetCdrUsersUserIdSignaturesData>) => queryOptions<GetCdrUsersUserIdSignaturesResponse, GetCdrUsersUserIdSignaturesError, GetCdrUsersUserIdSignaturesResponse, ReturnType<typeof getCdrUsersUserIdSignaturesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersUserIdSignatures({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersUserIdSignaturesQueryKey(options)
});

export const getCdrSellersSellerIdUsersUserIdSignaturesQueryKey = (options: Options<GetCdrSellersSellerIdUsersUserIdSignaturesData>) => createQueryKey('getCdrSellersSellerIdUsersUserIdSignatures', options);

/**
 * Get Signatures By User Id By Seller Id
 *
 * Get a user's signatures for a single seller.
 *
 * **User must get his own signatures or be part of the seller's group to use this endpoint**
 */
export const getCdrSellersSellerIdUsersUserIdSignaturesOptions = (options: Options<GetCdrSellersSellerIdUsersUserIdSignaturesData>) => queryOptions<GetCdrSellersSellerIdUsersUserIdSignaturesResponse, GetCdrSellersSellerIdUsersUserIdSignaturesError, GetCdrSellersSellerIdUsersUserIdSignaturesResponse, ReturnType<typeof getCdrSellersSellerIdUsersUserIdSignaturesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdUsersUserIdSignatures({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdUsersUserIdSignaturesQueryKey(options)
});

/**
 * Delete Signature
 *
 * Delete a signature.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const deleteCdrUsersUserIdSignaturesDocumentIdMutation = (options?: Partial<Options<DeleteCdrUsersUserIdSignaturesDocumentIdData>>): UseMutationOptions<DeleteCdrUsersUserIdSignaturesDocumentIdResponse, DeleteCdrUsersUserIdSignaturesDocumentIdError, Options<DeleteCdrUsersUserIdSignaturesDocumentIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrUsersUserIdSignaturesDocumentIdResponse, DeleteCdrUsersUserIdSignaturesDocumentIdError, Options<DeleteCdrUsersUserIdSignaturesDocumentIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrUsersUserIdSignaturesDocumentId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Signature
 *
 * Create a signature.
 *
 * **User must sign numerically or be part of the seller's group to use this endpoint**
 */
export const postCdrUsersUserIdSignaturesDocumentIdMutation = (options?: Partial<Options<PostCdrUsersUserIdSignaturesDocumentIdData>>): UseMutationOptions<PostCdrUsersUserIdSignaturesDocumentIdResponse, PostCdrUsersUserIdSignaturesDocumentIdError, Options<PostCdrUsersUserIdSignaturesDocumentIdData>> => {
    const mutationOptions: UseMutationOptions<PostCdrUsersUserIdSignaturesDocumentIdResponse, PostCdrUsersUserIdSignaturesDocumentIdError, Options<PostCdrUsersUserIdSignaturesDocumentIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrUsersUserIdSignaturesDocumentId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrCurriculumsQueryKey = (options?: Options<GetCdrCurriculumsData>) => createQueryKey('getCdrCurriculums', options);

/**
 * Get Curriculums
 *
 * Get all curriculums.
 *
 * **User be authenticated to use this endpoint**
 */
export const getCdrCurriculumsOptions = (options?: Options<GetCdrCurriculumsData>) => queryOptions<GetCdrCurriculumsResponse, DefaultError, GetCdrCurriculumsResponse, ReturnType<typeof getCdrCurriculumsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrCurriculums({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrCurriculumsQueryKey(options)
});

/**
 * Create Curriculum
 *
 * Create a curriculum.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const postCdrCurriculumsMutation = (options?: Partial<Options<PostCdrCurriculumsData>>): UseMutationOptions<PostCdrCurriculumsResponse, PostCdrCurriculumsError, Options<PostCdrCurriculumsData>> => {
    const mutationOptions: UseMutationOptions<PostCdrCurriculumsResponse, PostCdrCurriculumsError, Options<PostCdrCurriculumsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrCurriculums({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Curriculum
 *
 * Delete a curriculum.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const deleteCdrCurriculumsCurriculumIdMutation = (options?: Partial<Options<DeleteCdrCurriculumsCurriculumIdData>>): UseMutationOptions<DeleteCdrCurriculumsCurriculumIdResponse, DeleteCdrCurriculumsCurriculumIdError, Options<DeleteCdrCurriculumsCurriculumIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrCurriculumsCurriculumIdResponse, DeleteCdrCurriculumsCurriculumIdError, Options<DeleteCdrCurriculumsCurriculumIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrCurriculumsCurriculumId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Curriculum Membership
 *
 * Remove a curriculum from a user.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const deleteCdrUsersUserIdCurriculumsCurriculumIdMutation = (options?: Partial<Options<DeleteCdrUsersUserIdCurriculumsCurriculumIdData>>): UseMutationOptions<DeleteCdrUsersUserIdCurriculumsCurriculumIdResponse, DeleteCdrUsersUserIdCurriculumsCurriculumIdError, Options<DeleteCdrUsersUserIdCurriculumsCurriculumIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrUsersUserIdCurriculumsCurriculumIdResponse, DeleteCdrUsersUserIdCurriculumsCurriculumIdError, Options<DeleteCdrUsersUserIdCurriculumsCurriculumIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrUsersUserIdCurriculumsCurriculumId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Curriculum Membership
 *
 * Update a curriculum membership.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const patchCdrUsersUserIdCurriculumsCurriculumIdMutation = (options?: Partial<Options<PatchCdrUsersUserIdCurriculumsCurriculumIdData>>): UseMutationOptions<PatchCdrUsersUserIdCurriculumsCurriculumIdResponse, PatchCdrUsersUserIdCurriculumsCurriculumIdError, Options<PatchCdrUsersUserIdCurriculumsCurriculumIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrUsersUserIdCurriculumsCurriculumIdResponse, PatchCdrUsersUserIdCurriculumsCurriculumIdError, Options<PatchCdrUsersUserIdCurriculumsCurriculumIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrUsersUserIdCurriculumsCurriculumId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Curriculum Membership
 *
 * Add a curriculum to a user.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const postCdrUsersUserIdCurriculumsCurriculumIdMutation = (options?: Partial<Options<PostCdrUsersUserIdCurriculumsCurriculumIdData>>): UseMutationOptions<unknown, PostCdrUsersUserIdCurriculumsCurriculumIdError, Options<PostCdrUsersUserIdCurriculumsCurriculumIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostCdrUsersUserIdCurriculumsCurriculumIdError, Options<PostCdrUsersUserIdCurriculumsCurriculumIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrUsersUserIdCurriculumsCurriculumId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrUsersUserIdPaymentsQueryKey = (options: Options<GetCdrUsersUserIdPaymentsData>) => createQueryKey('getCdrUsersUserIdPayments', options);

/**
 * Get Payments By User Id
 *
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export const getCdrUsersUserIdPaymentsOptions = (options: Options<GetCdrUsersUserIdPaymentsData>) => queryOptions<GetCdrUsersUserIdPaymentsResponse, GetCdrUsersUserIdPaymentsError, GetCdrUsersUserIdPaymentsResponse, ReturnType<typeof getCdrUsersUserIdPaymentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersUserIdPayments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersUserIdPaymentsQueryKey(options)
});

/**
 * Create Payment
 *
 * Create a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const postCdrUsersUserIdPaymentsMutation = (options?: Partial<Options<PostCdrUsersUserIdPaymentsData>>): UseMutationOptions<PostCdrUsersUserIdPaymentsResponse, PostCdrUsersUserIdPaymentsError, Options<PostCdrUsersUserIdPaymentsData>> => {
    const mutationOptions: UseMutationOptions<PostCdrUsersUserIdPaymentsResponse, PostCdrUsersUserIdPaymentsError, Options<PostCdrUsersUserIdPaymentsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrUsersUserIdPayments({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Payment
 *
 * Remove a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const deleteCdrUsersUserIdPaymentsPaymentIdMutation = (options?: Partial<Options<DeleteCdrUsersUserIdPaymentsPaymentIdData>>): UseMutationOptions<DeleteCdrUsersUserIdPaymentsPaymentIdResponse, DeleteCdrUsersUserIdPaymentsPaymentIdError, Options<DeleteCdrUsersUserIdPaymentsPaymentIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrUsersUserIdPaymentsPaymentIdResponse, DeleteCdrUsersUserIdPaymentsPaymentIdError, Options<DeleteCdrUsersUserIdPaymentsPaymentIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrUsersUserIdPaymentsPaymentId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Get Payment Url
 *
 * Get payment url
 */
export const postCdrPayMutation = (options?: Partial<Options<PostCdrPayData>>): UseMutationOptions<PostCdrPayResponse, DefaultError, Options<PostCdrPayData>> => {
    const mutationOptions: UseMutationOptions<PostCdrPayResponse, DefaultError, Options<PostCdrPayData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrPay({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrYearQueryKey = (options?: Options<GetCdrYearData>) => createQueryKey('getCdrYear', options);

/**
 * Get Cdr Year
 */
export const getCdrYearOptions = (options?: Options<GetCdrYearData>) => queryOptions<GetCdrYearResponse, DefaultError, GetCdrYearResponse, ReturnType<typeof getCdrYearQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrYear({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrYearQueryKey(options)
});

/**
 * Update Cdr Year
 */
export const patchCdrYearMutation = (options?: Partial<Options<PatchCdrYearData>>): UseMutationOptions<PatchCdrYearResponse, PatchCdrYearError, Options<PatchCdrYearData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrYearResponse, PatchCdrYearError, Options<PatchCdrYearData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrYear({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrStatusQueryKey = (options?: Options<GetCdrStatusData>) => createQueryKey('getCdrStatus', options);

/**
 * Get Status
 */
export const getCdrStatusOptions = (options?: Options<GetCdrStatusData>) => queryOptions<GetCdrStatusResponse, DefaultError, GetCdrStatusResponse, ReturnType<typeof getCdrStatusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrStatus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrStatusQueryKey(options)
});

/**
 * Update Status
 */
export const patchCdrStatusMutation = (options?: Partial<Options<PatchCdrStatusData>>): UseMutationOptions<PatchCdrStatusResponse, PatchCdrStatusError, Options<PatchCdrStatusData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrStatusResponse, PatchCdrStatusError, Options<PatchCdrStatusData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrStatus({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrUsersMeTicketsQueryKey = (options?: Options<GetCdrUsersMeTicketsData>) => createQueryKey('getCdrUsersMeTickets', options);

/**
 * Get My Tickets
 */
export const getCdrUsersMeTicketsOptions = (options?: Options<GetCdrUsersMeTicketsData>) => queryOptions<GetCdrUsersMeTicketsResponse, DefaultError, GetCdrUsersMeTicketsResponse, ReturnType<typeof getCdrUsersMeTicketsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersMeTickets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersMeTicketsQueryKey(options)
});

export const getCdrUsersUserIdTicketsQueryKey = (options: Options<GetCdrUsersUserIdTicketsData>) => createQueryKey('getCdrUsersUserIdTickets', options);

/**
 * Get Tickets Of User
 */
export const getCdrUsersUserIdTicketsOptions = (options: Options<GetCdrUsersUserIdTicketsData>) => queryOptions<GetCdrUsersUserIdTicketsResponse, GetCdrUsersUserIdTicketsError, GetCdrUsersUserIdTicketsResponse, ReturnType<typeof getCdrUsersUserIdTicketsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersUserIdTickets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersUserIdTicketsQueryKey(options)
});

export const getCdrUsersMeTicketsTicketIdSecretQueryKey = (options: Options<GetCdrUsersMeTicketsTicketIdSecretData>) => createQueryKey('getCdrUsersMeTicketsTicketIdSecret', options);

/**
 * Get Ticket Secret
 */
export const getCdrUsersMeTicketsTicketIdSecretOptions = (options: Options<GetCdrUsersMeTicketsTicketIdSecretData>) => queryOptions<GetCdrUsersMeTicketsTicketIdSecretResponse, GetCdrUsersMeTicketsTicketIdSecretError, GetCdrUsersMeTicketsTicketIdSecretResponse, ReturnType<typeof getCdrUsersMeTicketsTicketIdSecretQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrUsersMeTicketsTicketIdSecret({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrUsersMeTicketsTicketIdSecretQueryKey(options)
});

export const getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretQueryKey = (options: Options<GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretData>) => createQueryKey('getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret', options);

/**
 * Get Ticket By Secret
 */
export const getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretOptions = (options: Options<GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretData>) => queryOptions<GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretResponse, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretResponse, ReturnType<typeof getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretQueryKey(options)
});

/**
 * Scan Ticket
 */
export const patchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretMutation = (options?: Partial<Options<PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretData>>): UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretResponse, PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError, Options<PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretResponse, PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError, Options<PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagQueryKey = (options: Options<GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagData>) => createQueryKey('getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag', options);

/**
 * Get Users By Tag
 */
export const getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagOptions = (options: Options<GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagData>) => queryOptions<GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagError, GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse, ReturnType<typeof getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagQueryKey(options)
});

export const getCdrSellersSellerIdProductsProductIdTagsGeneratorIdQueryKey = (options: Options<GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdData>) => createQueryKey('getCdrSellersSellerIdProductsProductIdTagsGeneratorId', options);

/**
 * Get Tags Of Ticket
 */
export const getCdrSellersSellerIdProductsProductIdTagsGeneratorIdOptions = (options: Options<GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdData>) => queryOptions<GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse, GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdError, GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse, ReturnType<typeof getCdrSellersSellerIdProductsProductIdTagsGeneratorIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdProductsProductIdTagsGeneratorId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdProductsProductIdTagsGeneratorIdQueryKey(options)
});

/**
 * Generate Ticket For Product
 */
export const postCdrSellersSellerIdProductsProductIdTicketsMutation = (options?: Partial<Options<PostCdrSellersSellerIdProductsProductIdTicketsData>>): UseMutationOptions<PostCdrSellersSellerIdProductsProductIdTicketsResponse, PostCdrSellersSellerIdProductsProductIdTicketsError, Options<PostCdrSellersSellerIdProductsProductIdTicketsData>> => {
    const mutationOptions: UseMutationOptions<PostCdrSellersSellerIdProductsProductIdTicketsResponse, PostCdrSellersSellerIdProductsProductIdTicketsError, Options<PostCdrSellersSellerIdProductsProductIdTicketsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrSellersSellerIdProductsProductIdTickets({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Ticket Generator For Product
 */
export const deleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdMutation = (options?: Partial<Options<DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdData>>): UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdResponse, DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdError, Options<DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdResponse, DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdError, Options<DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrSellersSellerIdProductsProductIdDataQueryKey = (options: Options<GetCdrSellersSellerIdProductsProductIdDataData>) => createQueryKey('getCdrSellersSellerIdProductsProductIdData', options);

/**
 * Get Custom Data Fields
 */
export const getCdrSellersSellerIdProductsProductIdDataOptions = (options: Options<GetCdrSellersSellerIdProductsProductIdDataData>) => queryOptions<GetCdrSellersSellerIdProductsProductIdDataResponse, GetCdrSellersSellerIdProductsProductIdDataError, GetCdrSellersSellerIdProductsProductIdDataResponse, ReturnType<typeof getCdrSellersSellerIdProductsProductIdDataQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdProductsProductIdData({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdProductsProductIdDataQueryKey(options)
});

/**
 * Create Custom Data Field
 */
export const postCdrSellersSellerIdProductsProductIdDataMutation = (options?: Partial<Options<PostCdrSellersSellerIdProductsProductIdDataData>>): UseMutationOptions<PostCdrSellersSellerIdProductsProductIdDataResponse, PostCdrSellersSellerIdProductsProductIdDataError, Options<PostCdrSellersSellerIdProductsProductIdDataData>> => {
    const mutationOptions: UseMutationOptions<PostCdrSellersSellerIdProductsProductIdDataResponse, PostCdrSellersSellerIdProductsProductIdDataError, Options<PostCdrSellersSellerIdProductsProductIdDataData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrSellersSellerIdProductsProductIdData({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Customdata Field
 */
export const deleteCdrSellersSellerIdProductsProductIdDataFieldIdMutation = (options?: Partial<Options<DeleteCdrSellersSellerIdProductsProductIdDataFieldIdData>>): UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdDataFieldIdResponse, DeleteCdrSellersSellerIdProductsProductIdDataFieldIdError, Options<DeleteCdrSellersSellerIdProductsProductIdDataFieldIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdDataFieldIdResponse, DeleteCdrSellersSellerIdProductsProductIdDataFieldIdError, Options<DeleteCdrSellersSellerIdProductsProductIdDataFieldIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrSellersSellerIdProductsProductIdDataFieldId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Custom Data Field
 */
export const patchCdrSellersSellerIdProductsProductIdDataFieldIdMutation = (options?: Partial<Options<PatchCdrSellersSellerIdProductsProductIdDataFieldIdData>>): UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdDataFieldIdResponse, PatchCdrSellersSellerIdProductsProductIdDataFieldIdError, Options<PatchCdrSellersSellerIdProductsProductIdDataFieldIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdDataFieldIdResponse, PatchCdrSellersSellerIdProductsProductIdDataFieldIdError, Options<PatchCdrSellersSellerIdProductsProductIdDataFieldIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrSellersSellerIdProductsProductIdDataFieldId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Customdata
 */
export const deleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdMutation = (options?: Partial<Options<DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>>): UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, Options<DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, Options<DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdQueryKey = (options: Options<GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>) => createQueryKey('getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId', options);

/**
 * Get Customdata
 */
export const getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdOptions = (options: Options<GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>) => queryOptions<GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, ReturnType<typeof getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdQueryKey(options)
});

/**
 * Update Custom Data
 */
export const patchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdMutation = (options?: Partial<Options<PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>>): UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, Options<PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>> => {
    const mutationOptions: UseMutationOptions<PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, Options<PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Custom Data
 */
export const postCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdMutation = (options?: Partial<Options<PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>>): UseMutationOptions<PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, Options<PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>> => {
    const mutationOptions: UseMutationOptions<PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdResponse, PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError, Options<PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFlappybirdScoresQueryKey = (options?: Options<GetFlappybirdScoresData>) => createQueryKey('getFlappybirdScores', options);

/**
 * Get Flappybird Score
 *
 * Return the leaderboard
 */
export const getFlappybirdScoresOptions = (options?: Options<GetFlappybirdScoresData>) => queryOptions<GetFlappybirdScoresResponse, DefaultError, GetFlappybirdScoresResponse, ReturnType<typeof getFlappybirdScoresQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getFlappybirdScores({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getFlappybirdScoresQueryKey(options)
});

/**
 * Create Flappybird Score
 */
export const postFlappybirdScoresMutation = (options?: Partial<Options<PostFlappybirdScoresData>>): UseMutationOptions<PostFlappybirdScoresResponse, PostFlappybirdScoresError, Options<PostFlappybirdScoresData>> => {
    const mutationOptions: UseMutationOptions<PostFlappybirdScoresResponse, PostFlappybirdScoresError, Options<PostFlappybirdScoresData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postFlappybirdScores({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFlappybirdScoresMeQueryKey = (options?: Options<GetFlappybirdScoresMeData>) => createQueryKey('getFlappybirdScoresMe', options);

/**
 * Get Current User Flappybird Personal Best
 */
export const getFlappybirdScoresMeOptions = (options?: Options<GetFlappybirdScoresMeData>) => queryOptions<GetFlappybirdScoresMeResponse, DefaultError, GetFlappybirdScoresMeResponse, ReturnType<typeof getFlappybirdScoresMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getFlappybirdScoresMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getFlappybirdScoresMeQueryKey(options)
});

/**
 * Remove Flappybird Score
 */
export const deleteFlappybirdScoresTargetedUserIdMutation = (options?: Partial<Options<DeleteFlappybirdScoresTargetedUserIdData>>): UseMutationOptions<DeleteFlappybirdScoresTargetedUserIdResponse, DeleteFlappybirdScoresTargetedUserIdError, Options<DeleteFlappybirdScoresTargetedUserIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteFlappybirdScoresTargetedUserIdResponse, DeleteFlappybirdScoresTargetedUserIdError, Options<DeleteFlappybirdScoresTargetedUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteFlappybirdScoresTargetedUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLoansLoanersQueryKey = (options?: Options<GetLoansLoanersData>) => createQueryKey('getLoansLoaners', options);

/**
 * Read Loaners
 *
 * Get existing loaners.
 *
 * **This endpoint is only usable by administrators**
 */
export const getLoansLoanersOptions = (options?: Options<GetLoansLoanersData>) => queryOptions<GetLoansLoanersResponse, DefaultError, GetLoansLoanersResponse, ReturnType<typeof getLoansLoanersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLoansLoaners({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLoansLoanersQueryKey(options)
});

/**
 * Create Loaner
 *
 * Create a new loaner.
 *
 * Each loaner is associated with a `manager_group`. Users belonging to this group are able to manage the loaner items and loans.
 *
 * **This endpoint is only usable by administrators**
 */
export const postLoansLoanersMutation = (options?: Partial<Options<PostLoansLoanersData>>): UseMutationOptions<PostLoansLoanersResponse, PostLoansLoanersError, Options<PostLoansLoanersData>> => {
    const mutationOptions: UseMutationOptions<PostLoansLoanersResponse, PostLoansLoanersError, Options<PostLoansLoanersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postLoansLoaners({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Loaner
 *
 * Delete a loaner. All items and loans associated with the loaner will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const deleteLoansLoanersLoanerIdMutation = (options?: Partial<Options<DeleteLoansLoanersLoanerIdData>>): UseMutationOptions<DeleteLoansLoanersLoanerIdResponse, DeleteLoansLoanersLoanerIdError, Options<DeleteLoansLoanersLoanerIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteLoansLoanersLoanerIdResponse, DeleteLoansLoanersLoanerIdError, Options<DeleteLoansLoanersLoanerIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteLoansLoanersLoanerId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Loaner
 *
 * Update a loaner, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const patchLoansLoanersLoanerIdMutation = (options?: Partial<Options<PatchLoansLoanersLoanerIdData>>): UseMutationOptions<PatchLoansLoanersLoanerIdResponse, PatchLoansLoanersLoanerIdError, Options<PatchLoansLoanersLoanerIdData>> => {
    const mutationOptions: UseMutationOptions<PatchLoansLoanersLoanerIdResponse, PatchLoansLoanersLoanerIdError, Options<PatchLoansLoanersLoanerIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchLoansLoanersLoanerId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLoansLoanersLoanerIdLoansQueryKey = (options: Options<GetLoansLoanersLoanerIdLoansData>) => createQueryKey('getLoansLoanersLoanerIdLoans', options);

/**
 * Get Loans By Loaner
 *
 * Return all loans from a given group.
 *
 *
 * The query string `returned` can be used to get only return or non returned loans. By default, all loans are returned.
 *
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const getLoansLoanersLoanerIdLoansOptions = (options: Options<GetLoansLoanersLoanerIdLoansData>) => queryOptions<GetLoansLoanersLoanerIdLoansResponse, GetLoansLoanersLoanerIdLoansError, GetLoansLoanersLoanerIdLoansResponse, ReturnType<typeof getLoansLoanersLoanerIdLoansQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLoansLoanersLoanerIdLoans({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLoansLoanersLoanerIdLoansQueryKey(options)
});

export const getLoansLoanersLoanerIdItemsQueryKey = (options: Options<GetLoansLoanersLoanerIdItemsData>) => createQueryKey('getLoansLoanersLoanerIdItems', options);

/**
 * Get Items By Loaner
 *
 * Return all items of a loaner.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const getLoansLoanersLoanerIdItemsOptions = (options: Options<GetLoansLoanersLoanerIdItemsData>) => queryOptions<GetLoansLoanersLoanerIdItemsResponse, GetLoansLoanersLoanerIdItemsError, GetLoansLoanersLoanerIdItemsResponse, ReturnType<typeof getLoansLoanersLoanerIdItemsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLoansLoanersLoanerIdItems({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLoansLoanersLoanerIdItemsQueryKey(options)
});

/**
 * Create Items For Loaner
 *
 * Create a new item for a loaner. A given loaner can not have more than one item with the same `name`.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const postLoansLoanersLoanerIdItemsMutation = (options?: Partial<Options<PostLoansLoanersLoanerIdItemsData>>): UseMutationOptions<PostLoansLoanersLoanerIdItemsResponse, PostLoansLoanersLoanerIdItemsError, Options<PostLoansLoanersLoanerIdItemsData>> => {
    const mutationOptions: UseMutationOptions<PostLoansLoanersLoanerIdItemsResponse, PostLoansLoanersLoanerIdItemsError, Options<PostLoansLoanersLoanerIdItemsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postLoansLoanersLoanerIdItems({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Loaner Item
 *
 * Delete a loaner's item.
 * This will remove the item from all loans but won't delete any loan.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const deleteLoansLoanersLoanerIdItemsItemIdMutation = (options?: Partial<Options<DeleteLoansLoanersLoanerIdItemsItemIdData>>): UseMutationOptions<DeleteLoansLoanersLoanerIdItemsItemIdResponse, DeleteLoansLoanersLoanerIdItemsItemIdError, Options<DeleteLoansLoanersLoanerIdItemsItemIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteLoansLoanersLoanerIdItemsItemIdResponse, DeleteLoansLoanersLoanerIdItemsItemIdError, Options<DeleteLoansLoanersLoanerIdItemsItemIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteLoansLoanersLoanerIdItemsItemId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Items For Loaner
 *
 * Update a loaner's item.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const patchLoansLoanersLoanerIdItemsItemIdMutation = (options?: Partial<Options<PatchLoansLoanersLoanerIdItemsItemIdData>>): UseMutationOptions<PatchLoansLoanersLoanerIdItemsItemIdResponse, PatchLoansLoanersLoanerIdItemsItemIdError, Options<PatchLoansLoanersLoanerIdItemsItemIdData>> => {
    const mutationOptions: UseMutationOptions<PatchLoansLoanersLoanerIdItemsItemIdResponse, PatchLoansLoanersLoanerIdItemsItemIdError, Options<PatchLoansLoanersLoanerIdItemsItemIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchLoansLoanersLoanerIdItemsItemId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLoansUsersMeQueryKey = (options?: Options<GetLoansUsersMeData>) => createQueryKey('getLoansUsersMe', options);

/**
 * Get Current User Loans
 *
 * Return all loans from the current user.
 *
 * The query string `returned` can be used to get only returned or non returned loans. By default, all loans are returned.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getLoansUsersMeOptions = (options?: Options<GetLoansUsersMeData>) => queryOptions<GetLoansUsersMeResponse, GetLoansUsersMeError, GetLoansUsersMeResponse, ReturnType<typeof getLoansUsersMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLoansUsersMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLoansUsersMeQueryKey(options)
});

export const getLoansUsersMeLoanersQueryKey = (options?: Options<GetLoansUsersMeLoanersData>) => createQueryKey('getLoansUsersMeLoaners', options);

/**
 * Get Current User Loaners
 *
 * Return all loaners the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getLoansUsersMeLoanersOptions = (options?: Options<GetLoansUsersMeLoanersData>) => queryOptions<GetLoansUsersMeLoanersResponse, DefaultError, GetLoansUsersMeLoanersResponse, ReturnType<typeof getLoansUsersMeLoanersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLoansUsersMeLoaners({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLoansUsersMeLoanersQueryKey(options)
});

/**
 * Create Loan
 *
 * Create a new loan in database and add the requested items
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const postLoansMutation = (options?: Partial<Options<PostLoansData>>): UseMutationOptions<PostLoansResponse, PostLoansError, Options<PostLoansData>> => {
    const mutationOptions: UseMutationOptions<PostLoansResponse, PostLoansError, Options<PostLoansData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postLoans({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Loan
 *
 * Delete a loan
 * This will remove the loan but won't delete any loaner items.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const deleteLoansLoanIdMutation = (options?: Partial<Options<DeleteLoansLoanIdData>>): UseMutationOptions<DeleteLoansLoanIdResponse, DeleteLoansLoanIdError, Options<DeleteLoansLoanIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteLoansLoanIdResponse, DeleteLoansLoanIdError, Options<DeleteLoansLoanIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteLoansLoanId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Loan
 *
 * Update a loan and its items.
 *
 * As the endpoint can update the loan items, it will send back
 * the new representation of the loan `Loan` including the new items relationships
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const patchLoansLoanIdMutation = (options?: Partial<Options<PatchLoansLoanIdData>>): UseMutationOptions<PatchLoansLoanIdResponse, PatchLoansLoanIdError, Options<PatchLoansLoanIdData>> => {
    const mutationOptions: UseMutationOptions<PatchLoansLoanIdResponse, PatchLoansLoanIdError, Options<PatchLoansLoanIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchLoansLoanId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Return Loan
 *
 * Mark a loan as returned. This will update items availability.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const postLoansLoanIdReturnMutation = (options?: Partial<Options<PostLoansLoanIdReturnData>>): UseMutationOptions<PostLoansLoanIdReturnResponse, PostLoansLoanIdReturnError, Options<PostLoansLoanIdReturnData>> => {
    const mutationOptions: UseMutationOptions<PostLoansLoanIdReturnResponse, PostLoansLoanIdReturnError, Options<PostLoansLoanIdReturnData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postLoansLoanIdReturn({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Extend Loan
 *
 * A new `end` date or an extended `duration` can be provided. If the two are provided, only `end` will be used.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const postLoansLoanIdExtendMutation = (options?: Partial<Options<PostLoansLoanIdExtendData>>): UseMutationOptions<PostLoansLoanIdExtendResponse, PostLoansLoanIdExtendError, Options<PostLoansLoanIdExtendData>> => {
    const mutationOptions: UseMutationOptions<PostLoansLoanIdExtendResponse, PostLoansLoanIdExtendError, Options<PostLoansLoanIdExtendData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postLoansLoanIdExtend({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTombolaRafflesQueryKey = (options?: Options<GetTombolaRafflesData>) => createQueryKey('getTombolaRaffles', options);

/**
 * Get Raffle
 *
 * Return all raffles
 */
export const getTombolaRafflesOptions = (options?: Options<GetTombolaRafflesData>) => queryOptions<GetTombolaRafflesResponse, DefaultError, GetTombolaRafflesResponse, ReturnType<typeof getTombolaRafflesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaRaffles({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaRafflesQueryKey(options)
});

/**
 * Create Raffle
 *
 * Create a new raffle
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const postTombolaRafflesMutation = (options?: Partial<Options<PostTombolaRafflesData>>): UseMutationOptions<PostTombolaRafflesResponse, PostTombolaRafflesError, Options<PostTombolaRafflesData>> => {
    const mutationOptions: UseMutationOptions<PostTombolaRafflesResponse, PostTombolaRafflesError, Options<PostTombolaRafflesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTombolaRaffles({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Raffle
 *
 * Delete a raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const deleteTombolaRafflesRaffleIdMutation = (options?: Partial<Options<DeleteTombolaRafflesRaffleIdData>>): UseMutationOptions<DeleteTombolaRafflesRaffleIdResponse, DeleteTombolaRafflesRaffleIdError, Options<DeleteTombolaRafflesRaffleIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteTombolaRafflesRaffleIdResponse, DeleteTombolaRafflesRaffleIdError, Options<DeleteTombolaRafflesRaffleIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTombolaRafflesRaffleId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Raffle
 *
 * Edit a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const patchTombolaRafflesRaffleIdMutation = (options?: Partial<Options<PatchTombolaRafflesRaffleIdData>>): UseMutationOptions<PatchTombolaRafflesRaffleIdResponse, PatchTombolaRafflesRaffleIdError, Options<PatchTombolaRafflesRaffleIdData>> => {
    const mutationOptions: UseMutationOptions<PatchTombolaRafflesRaffleIdResponse, PatchTombolaRafflesRaffleIdError, Options<PatchTombolaRafflesRaffleIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchTombolaRafflesRaffleId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTombolaGroupGroupIdRafflesQueryKey = (options: Options<GetTombolaGroupGroupIdRafflesData>) => createQueryKey('getTombolaGroupGroupIdRaffles', options);

/**
 * Get Raffles By Group Id
 *
 * Return all raffles from a group
 */
export const getTombolaGroupGroupIdRafflesOptions = (options: Options<GetTombolaGroupGroupIdRafflesData>) => queryOptions<GetTombolaGroupGroupIdRafflesResponse, GetTombolaGroupGroupIdRafflesError, GetTombolaGroupGroupIdRafflesResponse, ReturnType<typeof getTombolaGroupGroupIdRafflesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaGroupGroupIdRaffles({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaGroupGroupIdRafflesQueryKey(options)
});

export const getTombolaRafflesRaffleIdStatsQueryKey = (options: Options<GetTombolaRafflesRaffleIdStatsData>) => createQueryKey('getTombolaRafflesRaffleIdStats', options);

/**
 * Get Raffle Stats
 *
 * Return the number of ticket sold and the total amount recollected for a raffle
 */
export const getTombolaRafflesRaffleIdStatsOptions = (options: Options<GetTombolaRafflesRaffleIdStatsData>) => queryOptions<GetTombolaRafflesRaffleIdStatsResponse, GetTombolaRafflesRaffleIdStatsError, GetTombolaRafflesRaffleIdStatsResponse, ReturnType<typeof getTombolaRafflesRaffleIdStatsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaRafflesRaffleIdStats({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaRafflesRaffleIdStatsQueryKey(options)
});

export const getTombolaRafflesRaffleIdLogoQueryKey = (options: Options<GetTombolaRafflesRaffleIdLogoData>) => createQueryKey('getTombolaRafflesRaffleIdLogo', options);

/**
 * Read Raffle Logo
 *
 * Get the logo of a specific raffle.
 */
export const getTombolaRafflesRaffleIdLogoOptions = (options: Options<GetTombolaRafflesRaffleIdLogoData>) => queryOptions<unknown, GetTombolaRafflesRaffleIdLogoError, unknown, ReturnType<typeof getTombolaRafflesRaffleIdLogoQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaRafflesRaffleIdLogo({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaRafflesRaffleIdLogoQueryKey(options)
});

/**
 * Create Current Raffle Logo
 *
 * Upload a logo for a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const postTombolaRafflesRaffleIdLogoMutation = (options?: Partial<Options<PostTombolaRafflesRaffleIdLogoData>>): UseMutationOptions<PostTombolaRafflesRaffleIdLogoResponse, PostTombolaRafflesRaffleIdLogoError, Options<PostTombolaRafflesRaffleIdLogoData>> => {
    const mutationOptions: UseMutationOptions<PostTombolaRafflesRaffleIdLogoResponse, PostTombolaRafflesRaffleIdLogoError, Options<PostTombolaRafflesRaffleIdLogoData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTombolaRafflesRaffleIdLogo({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTombolaPackTicketsQueryKey = (options?: Options<GetTombolaPackTicketsData>) => createQueryKey('getTombolaPackTickets', options);

/**
 * Get Pack Tickets
 *
 * Return all tickets
 */
export const getTombolaPackTicketsOptions = (options?: Options<GetTombolaPackTicketsData>) => queryOptions<GetTombolaPackTicketsResponse, DefaultError, GetTombolaPackTicketsResponse, ReturnType<typeof getTombolaPackTicketsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaPackTickets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaPackTicketsQueryKey(options)
});

/**
 * Create Packticket
 *
 * Create a new packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const postTombolaPackTicketsMutation = (options?: Partial<Options<PostTombolaPackTicketsData>>): UseMutationOptions<PostTombolaPackTicketsResponse, PostTombolaPackTicketsError, Options<PostTombolaPackTicketsData>> => {
    const mutationOptions: UseMutationOptions<PostTombolaPackTicketsResponse, PostTombolaPackTicketsError, Options<PostTombolaPackTicketsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTombolaPackTickets({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Packticket
 *
 * Delete a packticket.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const deleteTombolaPackTicketsPackticketIdMutation = (options?: Partial<Options<DeleteTombolaPackTicketsPackticketIdData>>): UseMutationOptions<DeleteTombolaPackTicketsPackticketIdResponse, DeleteTombolaPackTicketsPackticketIdError, Options<DeleteTombolaPackTicketsPackticketIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteTombolaPackTicketsPackticketIdResponse, DeleteTombolaPackTicketsPackticketIdError, Options<DeleteTombolaPackTicketsPackticketIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTombolaPackTicketsPackticketId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Packticket
 *
 * Edit a packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const patchTombolaPackTicketsPackticketIdMutation = (options?: Partial<Options<PatchTombolaPackTicketsPackticketIdData>>): UseMutationOptions<PatchTombolaPackTicketsPackticketIdResponse, PatchTombolaPackTicketsPackticketIdError, Options<PatchTombolaPackTicketsPackticketIdData>> => {
    const mutationOptions: UseMutationOptions<PatchTombolaPackTicketsPackticketIdResponse, PatchTombolaPackTicketsPackticketIdError, Options<PatchTombolaPackTicketsPackticketIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchTombolaPackTicketsPackticketId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTombolaRafflesRaffleIdPackTicketsQueryKey = (options: Options<GetTombolaRafflesRaffleIdPackTicketsData>) => createQueryKey('getTombolaRafflesRaffleIdPackTickets', options);

/**
 * Get Pack Tickets By Raffle Id
 *
 * Return all pack_tickets associated to a raffle
 */
export const getTombolaRafflesRaffleIdPackTicketsOptions = (options: Options<GetTombolaRafflesRaffleIdPackTicketsData>) => queryOptions<GetTombolaRafflesRaffleIdPackTicketsResponse, GetTombolaRafflesRaffleIdPackTicketsError, GetTombolaRafflesRaffleIdPackTicketsResponse, ReturnType<typeof getTombolaRafflesRaffleIdPackTicketsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaRafflesRaffleIdPackTickets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaRafflesRaffleIdPackTicketsQueryKey(options)
});

export const getTombolaTicketsQueryKey = (options?: Options<GetTombolaTicketsData>) => createQueryKey('getTombolaTickets', options);

/**
 * Get Tickets
 *
 * Return all tickets
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const getTombolaTicketsOptions = (options?: Options<GetTombolaTicketsData>) => queryOptions<GetTombolaTicketsResponse, DefaultError, GetTombolaTicketsResponse, ReturnType<typeof getTombolaTicketsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaTickets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaTicketsQueryKey(options)
});

/**
 * Buy Ticket
 *
 * Buy a ticket
 */
export const postTombolaTicketsBuyPackIdMutation = (options?: Partial<Options<PostTombolaTicketsBuyPackIdData>>): UseMutationOptions<PostTombolaTicketsBuyPackIdResponse, PostTombolaTicketsBuyPackIdError, Options<PostTombolaTicketsBuyPackIdData>> => {
    const mutationOptions: UseMutationOptions<PostTombolaTicketsBuyPackIdResponse, PostTombolaTicketsBuyPackIdError, Options<PostTombolaTicketsBuyPackIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTombolaTicketsBuyPackId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTombolaUsersUserIdTicketsQueryKey = (options: Options<GetTombolaUsersUserIdTicketsData>) => createQueryKey('getTombolaUsersUserIdTickets', options);

/**
 * Get Tickets By Userid
 *
 * Get tickets of a specific user.
 *
 * **Only admin users can get tickets of another user**
 */
export const getTombolaUsersUserIdTicketsOptions = (options: Options<GetTombolaUsersUserIdTicketsData>) => queryOptions<GetTombolaUsersUserIdTicketsResponse, GetTombolaUsersUserIdTicketsError, GetTombolaUsersUserIdTicketsResponse, ReturnType<typeof getTombolaUsersUserIdTicketsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaUsersUserIdTickets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaUsersUserIdTicketsQueryKey(options)
});

export const getTombolaRafflesRaffleIdTicketsQueryKey = (options: Options<GetTombolaRafflesRaffleIdTicketsData>) => createQueryKey('getTombolaRafflesRaffleIdTickets', options);

/**
 * Get Tickets By Raffleid
 *
 * Get tickets from a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const getTombolaRafflesRaffleIdTicketsOptions = (options: Options<GetTombolaRafflesRaffleIdTicketsData>) => queryOptions<GetTombolaRafflesRaffleIdTicketsResponse, GetTombolaRafflesRaffleIdTicketsError, GetTombolaRafflesRaffleIdTicketsResponse, ReturnType<typeof getTombolaRafflesRaffleIdTicketsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaRafflesRaffleIdTickets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaRafflesRaffleIdTicketsQueryKey(options)
});

export const getTombolaPrizesQueryKey = (options?: Options<GetTombolaPrizesData>) => createQueryKey('getTombolaPrizes', options);

/**
 * Get Prizes
 *
 * Return all prizes
 */
export const getTombolaPrizesOptions = (options?: Options<GetTombolaPrizesData>) => queryOptions<GetTombolaPrizesResponse, DefaultError, GetTombolaPrizesResponse, ReturnType<typeof getTombolaPrizesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaPrizes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaPrizesQueryKey(options)
});

/**
 * Create Prize
 *
 * Create a new prize
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const postTombolaPrizesMutation = (options?: Partial<Options<PostTombolaPrizesData>>): UseMutationOptions<PostTombolaPrizesResponse, PostTombolaPrizesError, Options<PostTombolaPrizesData>> => {
    const mutationOptions: UseMutationOptions<PostTombolaPrizesResponse, PostTombolaPrizesError, Options<PostTombolaPrizesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTombolaPrizes({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Prize
 *
 * Delete a prize.
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const deleteTombolaPrizesPrizeIdMutation = (options?: Partial<Options<DeleteTombolaPrizesPrizeIdData>>): UseMutationOptions<DeleteTombolaPrizesPrizeIdResponse, DeleteTombolaPrizesPrizeIdError, Options<DeleteTombolaPrizesPrizeIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteTombolaPrizesPrizeIdResponse, DeleteTombolaPrizesPrizeIdError, Options<DeleteTombolaPrizesPrizeIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTombolaPrizesPrizeId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Prize
 *
 * Edit a prize
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const patchTombolaPrizesPrizeIdMutation = (options?: Partial<Options<PatchTombolaPrizesPrizeIdData>>): UseMutationOptions<PatchTombolaPrizesPrizeIdResponse, PatchTombolaPrizesPrizeIdError, Options<PatchTombolaPrizesPrizeIdData>> => {
    const mutationOptions: UseMutationOptions<PatchTombolaPrizesPrizeIdResponse, PatchTombolaPrizesPrizeIdError, Options<PatchTombolaPrizesPrizeIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchTombolaPrizesPrizeId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTombolaRafflesRaffleIdPrizesQueryKey = (options: Options<GetTombolaRafflesRaffleIdPrizesData>) => createQueryKey('getTombolaRafflesRaffleIdPrizes', options);

/**
 * Get Prizes By Raffleid
 *
 * Get prizes from a specific raffle.
 */
export const getTombolaRafflesRaffleIdPrizesOptions = (options: Options<GetTombolaRafflesRaffleIdPrizesData>) => queryOptions<GetTombolaRafflesRaffleIdPrizesResponse, GetTombolaRafflesRaffleIdPrizesError, GetTombolaRafflesRaffleIdPrizesResponse, ReturnType<typeof getTombolaRafflesRaffleIdPrizesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaRafflesRaffleIdPrizes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaRafflesRaffleIdPrizesQueryKey(options)
});

export const getTombolaPrizesPrizeIdPictureQueryKey = (options: Options<GetTombolaPrizesPrizeIdPictureData>) => createQueryKey('getTombolaPrizesPrizeIdPicture', options);

/**
 * Read Prize Logo
 *
 * Get the logo of a specific prize.
 */
export const getTombolaPrizesPrizeIdPictureOptions = (options: Options<GetTombolaPrizesPrizeIdPictureData>) => queryOptions<unknown, GetTombolaPrizesPrizeIdPictureError, unknown, ReturnType<typeof getTombolaPrizesPrizeIdPictureQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaPrizesPrizeIdPicture({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaPrizesPrizeIdPictureQueryKey(options)
});

/**
 * Create Prize Picture
 *
 * Upload a logo for a specific prize.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const postTombolaPrizesPrizeIdPictureMutation = (options?: Partial<Options<PostTombolaPrizesPrizeIdPictureData>>): UseMutationOptions<PostTombolaPrizesPrizeIdPictureResponse, PostTombolaPrizesPrizeIdPictureError, Options<PostTombolaPrizesPrizeIdPictureData>> => {
    const mutationOptions: UseMutationOptions<PostTombolaPrizesPrizeIdPictureResponse, PostTombolaPrizesPrizeIdPictureError, Options<PostTombolaPrizesPrizeIdPictureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTombolaPrizesPrizeIdPicture({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTombolaUsersCashQueryKey = (options?: Options<GetTombolaUsersCashData>) => createQueryKey('getTombolaUsersCash', options);

/**
 * Get Users Cash
 *
 * Get cash from all users.
 *
 * **The user must be a member of the group admin to use this endpoint
 */
export const getTombolaUsersCashOptions = (options?: Options<GetTombolaUsersCashData>) => queryOptions<GetTombolaUsersCashResponse, DefaultError, GetTombolaUsersCashResponse, ReturnType<typeof getTombolaUsersCashQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaUsersCash({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaUsersCashQueryKey(options)
});

export const getTombolaUsersUserIdCashQueryKey = (options: Options<GetTombolaUsersUserIdCashData>) => createQueryKey('getTombolaUsersUserIdCash', options);

/**
 * Get Cash By Id
 *
 * Get cash from a specific user.
 *
 * **The user must be a member of the group admin to use this endpoint or can only access the endpoint for its own user_id**
 */
export const getTombolaUsersUserIdCashOptions = (options: Options<GetTombolaUsersUserIdCashData>) => queryOptions<GetTombolaUsersUserIdCashResponse, GetTombolaUsersUserIdCashError, GetTombolaUsersUserIdCashResponse, ReturnType<typeof getTombolaUsersUserIdCashQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTombolaUsersUserIdCash({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTombolaUsersUserIdCashQueryKey(options)
});

/**
 * Edit Cash By Id
 *
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const patchTombolaUsersUserIdCashMutation = (options?: Partial<Options<PatchTombolaUsersUserIdCashData>>): UseMutationOptions<PatchTombolaUsersUserIdCashResponse, PatchTombolaUsersUserIdCashError, Options<PatchTombolaUsersUserIdCashData>> => {
    const mutationOptions: UseMutationOptions<PatchTombolaUsersUserIdCashResponse, PatchTombolaUsersUserIdCashError, Options<PatchTombolaUsersUserIdCashData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchTombolaUsersUserIdCash({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Cash Of User
 *
 * Create cash for a user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const postTombolaUsersUserIdCashMutation = (options?: Partial<Options<PostTombolaUsersUserIdCashData>>): UseMutationOptions<PostTombolaUsersUserIdCashResponse, PostTombolaUsersUserIdCashError, Options<PostTombolaUsersUserIdCashData>> => {
    const mutationOptions: UseMutationOptions<PostTombolaUsersUserIdCashResponse, PostTombolaUsersUserIdCashError, Options<PostTombolaUsersUserIdCashData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTombolaUsersUserIdCash({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Draw Winner
 */
export const postTombolaPrizesPrizeIdDrawMutation = (options?: Partial<Options<PostTombolaPrizesPrizeIdDrawData>>): UseMutationOptions<PostTombolaPrizesPrizeIdDrawResponse, PostTombolaPrizesPrizeIdDrawError, Options<PostTombolaPrizesPrizeIdDrawData>> => {
    const mutationOptions: UseMutationOptions<PostTombolaPrizesPrizeIdDrawResponse, PostTombolaPrizesPrizeIdDrawError, Options<PostTombolaPrizesPrizeIdDrawData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postTombolaPrizesPrizeIdDraw({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Open Raffle
 *
 * Open a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const patchTombolaRafflesRaffleIdOpenMutation = (options?: Partial<Options<PatchTombolaRafflesRaffleIdOpenData>>): UseMutationOptions<PatchTombolaRafflesRaffleIdOpenResponse, PatchTombolaRafflesRaffleIdOpenError, Options<PatchTombolaRafflesRaffleIdOpenData>> => {
    const mutationOptions: UseMutationOptions<PatchTombolaRafflesRaffleIdOpenResponse, PatchTombolaRafflesRaffleIdOpenError, Options<PatchTombolaRafflesRaffleIdOpenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchTombolaRafflesRaffleIdOpen({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Lock Raffle
 *
 * Lock a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const patchTombolaRafflesRaffleIdLockMutation = (options?: Partial<Options<PatchTombolaRafflesRaffleIdLockData>>): UseMutationOptions<PatchTombolaRafflesRaffleIdLockResponse, PatchTombolaRafflesRaffleIdLockError, Options<PatchTombolaRafflesRaffleIdLockData>> => {
    const mutationOptions: UseMutationOptions<PatchTombolaRafflesRaffleIdLockResponse, PatchTombolaRafflesRaffleIdLockError, Options<PatchTombolaRafflesRaffleIdLockData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchTombolaRafflesRaffleIdLock({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCinemaThemoviedbThemoviedbIdQueryKey = (options: Options<GetCinemaThemoviedbThemoviedbIdData>) => createQueryKey('getCinemaThemoviedbThemoviedbId', options);

/**
 * Get Movie
 *
 * Makes a HTTP request to The Movie Database (TMDB)
 * using an API key and returns a TheMovieDB object
 * * https://developer.themoviedb.org/reference/movie-details
 * * https://developer.themoviedb.org/docs/errors
 */
export const getCinemaThemoviedbThemoviedbIdOptions = (options: Options<GetCinemaThemoviedbThemoviedbIdData>) => queryOptions<GetCinemaThemoviedbThemoviedbIdResponse, GetCinemaThemoviedbThemoviedbIdError, GetCinemaThemoviedbThemoviedbIdResponse, ReturnType<typeof getCinemaThemoviedbThemoviedbIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCinemaThemoviedbThemoviedbId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCinemaThemoviedbThemoviedbIdQueryKey(options)
});

export const getCinemaSessionsQueryKey = (options?: Options<GetCinemaSessionsData>) => createQueryKey('getCinemaSessions', options);

/**
 * Get Sessions
 */
export const getCinemaSessionsOptions = (options?: Options<GetCinemaSessionsData>) => queryOptions<GetCinemaSessionsResponse, DefaultError, GetCinemaSessionsResponse, ReturnType<typeof getCinemaSessionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCinemaSessions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCinemaSessionsQueryKey(options)
});

/**
 * Create Session
 */
export const postCinemaSessionsMutation = (options?: Partial<Options<PostCinemaSessionsData>>): UseMutationOptions<PostCinemaSessionsResponse, PostCinemaSessionsError, Options<PostCinemaSessionsData>> => {
    const mutationOptions: UseMutationOptions<PostCinemaSessionsResponse, PostCinemaSessionsError, Options<PostCinemaSessionsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCinemaSessions({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Session
 */
export const deleteCinemaSessionsSessionIdMutation = (options?: Partial<Options<DeleteCinemaSessionsSessionIdData>>): UseMutationOptions<DeleteCinemaSessionsSessionIdResponse, DeleteCinemaSessionsSessionIdError, Options<DeleteCinemaSessionsSessionIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteCinemaSessionsSessionIdResponse, DeleteCinemaSessionsSessionIdError, Options<DeleteCinemaSessionsSessionIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCinemaSessionsSessionId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Session
 */
export const patchCinemaSessionsSessionIdMutation = (options?: Partial<Options<PatchCinemaSessionsSessionIdData>>): UseMutationOptions<unknown, PatchCinemaSessionsSessionIdError, Options<PatchCinemaSessionsSessionIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, PatchCinemaSessionsSessionIdError, Options<PatchCinemaSessionsSessionIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchCinemaSessionsSessionId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCinemaSessionsSessionIdPosterQueryKey = (options: Options<GetCinemaSessionsSessionIdPosterData>) => createQueryKey('getCinemaSessionsSessionIdPoster', options);

/**
 * Read Session Poster
 */
export const getCinemaSessionsSessionIdPosterOptions = (options: Options<GetCinemaSessionsSessionIdPosterData>) => queryOptions<unknown, GetCinemaSessionsSessionIdPosterError, unknown, ReturnType<typeof getCinemaSessionsSessionIdPosterQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCinemaSessionsSessionIdPoster({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCinemaSessionsSessionIdPosterQueryKey(options)
});

/**
 * Create Campaigns Logo
 */
export const postCinemaSessionsSessionIdPosterMutation = (options?: Partial<Options<PostCinemaSessionsSessionIdPosterData>>): UseMutationOptions<PostCinemaSessionsSessionIdPosterResponse, PostCinemaSessionsSessionIdPosterError, Options<PostCinemaSessionsSessionIdPosterData>> => {
    const mutationOptions: UseMutationOptions<PostCinemaSessionsSessionIdPosterResponse, PostCinemaSessionsSessionIdPosterError, Options<PostCinemaSessionsSessionIdPosterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCinemaSessionsSessionIdPoster({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidParticipantsParticipantIdQueryKey = (options: Options<GetRaidParticipantsParticipantIdData>) => createQueryKey('getRaidParticipantsParticipantId', options);

/**
 * Get Participant By Id
 *
 * Get a participant by id
 */
export const getRaidParticipantsParticipantIdOptions = (options: Options<GetRaidParticipantsParticipantIdData>) => queryOptions<GetRaidParticipantsParticipantIdResponse, GetRaidParticipantsParticipantIdError, GetRaidParticipantsParticipantIdResponse, ReturnType<typeof getRaidParticipantsParticipantIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidParticipantsParticipantId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidParticipantsParticipantIdQueryKey(options)
});

/**
 * Update Participant
 *
 * Update a participant
 */
export const patchRaidParticipantsParticipantIdMutation = (options?: Partial<Options<PatchRaidParticipantsParticipantIdData>>): UseMutationOptions<PatchRaidParticipantsParticipantIdResponse, PatchRaidParticipantsParticipantIdError, Options<PatchRaidParticipantsParticipantIdData>> => {
    const mutationOptions: UseMutationOptions<PatchRaidParticipantsParticipantIdResponse, PatchRaidParticipantsParticipantIdError, Options<PatchRaidParticipantsParticipantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchRaidParticipantsParticipantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Participant
 *
 * Create a participant
 */
export const postRaidParticipantsMutation = (options?: Partial<Options<PostRaidParticipantsData>>): UseMutationOptions<PostRaidParticipantsResponse, PostRaidParticipantsError, Options<PostRaidParticipantsData>> => {
    const mutationOptions: UseMutationOptions<PostRaidParticipantsResponse, PostRaidParticipantsError, Options<PostRaidParticipantsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidParticipants({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete All Teams
 *
 * Delete all teams
 */
export const deleteRaidTeamsMutation = (options?: Partial<Options<DeleteRaidTeamsData>>): UseMutationOptions<DeleteRaidTeamsResponse, DefaultError, Options<DeleteRaidTeamsData>> => {
    const mutationOptions: UseMutationOptions<DeleteRaidTeamsResponse, DefaultError, Options<DeleteRaidTeamsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRaidTeams({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidTeamsQueryKey = (options?: Options<GetRaidTeamsData>) => createQueryKey('getRaidTeams', options);

/**
 * Get All Teams
 *
 * Get all teams
 */
export const getRaidTeamsOptions = (options?: Options<GetRaidTeamsData>) => queryOptions<GetRaidTeamsResponse, DefaultError, GetRaidTeamsResponse, ReturnType<typeof getRaidTeamsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidTeams({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidTeamsQueryKey(options)
});

/**
 * Create Team
 *
 * Create a team
 */
export const postRaidTeamsMutation = (options?: Partial<Options<PostRaidTeamsData>>): UseMutationOptions<PostRaidTeamsResponse, PostRaidTeamsError, Options<PostRaidTeamsData>> => {
    const mutationOptions: UseMutationOptions<PostRaidTeamsResponse, PostRaidTeamsError, Options<PostRaidTeamsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidTeams({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidParticipantsParticipantIdTeamQueryKey = (options: Options<GetRaidParticipantsParticipantIdTeamData>) => createQueryKey('getRaidParticipantsParticipantIdTeam', options);

/**
 * Get Team By Participant Id
 *
 * Get a team by participant id
 */
export const getRaidParticipantsParticipantIdTeamOptions = (options: Options<GetRaidParticipantsParticipantIdTeamData>) => queryOptions<GetRaidParticipantsParticipantIdTeamResponse, GetRaidParticipantsParticipantIdTeamError, GetRaidParticipantsParticipantIdTeamResponse, ReturnType<typeof getRaidParticipantsParticipantIdTeamQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidParticipantsParticipantIdTeam({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidParticipantsParticipantIdTeamQueryKey(options)
});

/**
 * Delete Team
 *
 * Delete a team
 */
export const deleteRaidTeamsTeamIdMutation = (options?: Partial<Options<DeleteRaidTeamsTeamIdData>>): UseMutationOptions<DeleteRaidTeamsTeamIdResponse, DeleteRaidTeamsTeamIdError, Options<DeleteRaidTeamsTeamIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteRaidTeamsTeamIdResponse, DeleteRaidTeamsTeamIdError, Options<DeleteRaidTeamsTeamIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRaidTeamsTeamId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidTeamsTeamIdQueryKey = (options: Options<GetRaidTeamsTeamIdData>) => createQueryKey('getRaidTeamsTeamId', options);

/**
 * Get Team By Id
 *
 * Get a team by id
 */
export const getRaidTeamsTeamIdOptions = (options: Options<GetRaidTeamsTeamIdData>) => queryOptions<GetRaidTeamsTeamIdResponse, GetRaidTeamsTeamIdError, GetRaidTeamsTeamIdResponse, ReturnType<typeof getRaidTeamsTeamIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidTeamsTeamId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidTeamsTeamIdQueryKey(options)
});

/**
 * Update Team
 *
 * Update a team
 */
export const patchRaidTeamsTeamIdMutation = (options?: Partial<Options<PatchRaidTeamsTeamIdData>>): UseMutationOptions<PatchRaidTeamsTeamIdResponse, PatchRaidTeamsTeamIdError, Options<PatchRaidTeamsTeamIdData>> => {
    const mutationOptions: UseMutationOptions<PatchRaidTeamsTeamIdResponse, PatchRaidTeamsTeamIdError, Options<PatchRaidTeamsTeamIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchRaidTeamsTeamId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Upload Document
 *
 * Upload a document
 */
export const postRaidDocumentDocumentTypeMutation = (options?: Partial<Options<PostRaidDocumentDocumentTypeData>>): UseMutationOptions<PostRaidDocumentDocumentTypeResponse, PostRaidDocumentDocumentTypeError, Options<PostRaidDocumentDocumentTypeData>> => {
    const mutationOptions: UseMutationOptions<PostRaidDocumentDocumentTypeResponse, PostRaidDocumentDocumentTypeError, Options<PostRaidDocumentDocumentTypeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidDocumentDocumentType({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidDocumentDocumentIdQueryKey = (options: Options<GetRaidDocumentDocumentIdData>) => createQueryKey('getRaidDocumentDocumentId', options);

/**
 * Read Document
 *
 * Read a document
 */
export const getRaidDocumentDocumentIdOptions = (options: Options<GetRaidDocumentDocumentIdData>) => queryOptions<unknown, GetRaidDocumentDocumentIdError, unknown, ReturnType<typeof getRaidDocumentDocumentIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidDocumentDocumentId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidDocumentDocumentIdQueryKey(options)
});

/**
 * Validate Document
 *
 * Validate a document
 */
export const postRaidDocumentDocumentIdValidateMutation = (options?: Partial<Options<PostRaidDocumentDocumentIdValidateData>>): UseMutationOptions<PostRaidDocumentDocumentIdValidateResponse, PostRaidDocumentDocumentIdValidateError, Options<PostRaidDocumentDocumentIdValidateData>> => {
    const mutationOptions: UseMutationOptions<PostRaidDocumentDocumentIdValidateResponse, PostRaidDocumentDocumentIdValidateError, Options<PostRaidDocumentDocumentIdValidateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidDocumentDocumentIdValidate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Set Security File
 *
 * Confirm security file
 */
export const postRaidSecurityFileMutation = (options?: Partial<Options<PostRaidSecurityFileData>>): UseMutationOptions<PostRaidSecurityFileResponse, PostRaidSecurityFileError, Options<PostRaidSecurityFileData>> => {
    const mutationOptions: UseMutationOptions<PostRaidSecurityFileResponse, PostRaidSecurityFileError, Options<PostRaidSecurityFileData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidSecurityFile({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Confirm Payment
 *
 * Confirm payment manually
 */
export const postRaidParticipantParticipantIdPaymentMutation = (options?: Partial<Options<PostRaidParticipantParticipantIdPaymentData>>): UseMutationOptions<PostRaidParticipantParticipantIdPaymentResponse, PostRaidParticipantParticipantIdPaymentError, Options<PostRaidParticipantParticipantIdPaymentData>> => {
    const mutationOptions: UseMutationOptions<PostRaidParticipantParticipantIdPaymentResponse, PostRaidParticipantParticipantIdPaymentError, Options<PostRaidParticipantParticipantIdPaymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidParticipantParticipantIdPayment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Confirm T Shirt Payment
 *
 * Confirm T shirt payment
 */
export const postRaidParticipantParticipantIdTShirtPaymentMutation = (options?: Partial<Options<PostRaidParticipantParticipantIdTShirtPaymentData>>): UseMutationOptions<PostRaidParticipantParticipantIdTShirtPaymentResponse, PostRaidParticipantParticipantIdTShirtPaymentError, Options<PostRaidParticipantParticipantIdTShirtPaymentData>> => {
    const mutationOptions: UseMutationOptions<PostRaidParticipantParticipantIdTShirtPaymentResponse, PostRaidParticipantParticipantIdTShirtPaymentError, Options<PostRaidParticipantParticipantIdTShirtPaymentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidParticipantParticipantIdTShirtPayment({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Validate Attestation On Honour
 *
 * Validate attestation on honour
 */
export const postRaidParticipantParticipantIdHonourMutation = (options?: Partial<Options<PostRaidParticipantParticipantIdHonourData>>): UseMutationOptions<PostRaidParticipantParticipantIdHonourResponse, PostRaidParticipantParticipantIdHonourError, Options<PostRaidParticipantParticipantIdHonourData>> => {
    const mutationOptions: UseMutationOptions<PostRaidParticipantParticipantIdHonourResponse, PostRaidParticipantParticipantIdHonourError, Options<PostRaidParticipantParticipantIdHonourData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidParticipantParticipantIdHonour({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Invite Token
 *
 * Create an invite token
 */
export const postRaidTeamsTeamIdInviteMutation = (options?: Partial<Options<PostRaidTeamsTeamIdInviteData>>): UseMutationOptions<PostRaidTeamsTeamIdInviteResponse, PostRaidTeamsTeamIdInviteError, Options<PostRaidTeamsTeamIdInviteData>> => {
    const mutationOptions: UseMutationOptions<PostRaidTeamsTeamIdInviteResponse, PostRaidTeamsTeamIdInviteError, Options<PostRaidTeamsTeamIdInviteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidTeamsTeamIdInvite({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Join Team
 *
 * Join a team
 */
export const postRaidTeamsJoinTokenMutation = (options?: Partial<Options<PostRaidTeamsJoinTokenData>>): UseMutationOptions<PostRaidTeamsJoinTokenResponse, PostRaidTeamsJoinTokenError, Options<PostRaidTeamsJoinTokenData>> => {
    const mutationOptions: UseMutationOptions<PostRaidTeamsJoinTokenResponse, PostRaidTeamsJoinTokenError, Options<PostRaidTeamsJoinTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidTeamsJoinToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Kick Team Member
 *
 * Leave a team
 */
export const postRaidTeamsTeamIdKickParticipantIdMutation = (options?: Partial<Options<PostRaidTeamsTeamIdKickParticipantIdData>>): UseMutationOptions<PostRaidTeamsTeamIdKickParticipantIdResponse, PostRaidTeamsTeamIdKickParticipantIdError, Options<PostRaidTeamsTeamIdKickParticipantIdData>> => {
    const mutationOptions: UseMutationOptions<PostRaidTeamsTeamIdKickParticipantIdResponse, PostRaidTeamsTeamIdKickParticipantIdError, Options<PostRaidTeamsTeamIdKickParticipantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidTeamsTeamIdKickParticipantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Merge Teams
 *
 * Merge two teams
 */
export const postRaidTeamsMergeMutation = (options?: Partial<Options<PostRaidTeamsMergeData>>): UseMutationOptions<PostRaidTeamsMergeResponse, PostRaidTeamsMergeError, Options<PostRaidTeamsMergeData>> => {
    const mutationOptions: UseMutationOptions<PostRaidTeamsMergeResponse, PostRaidTeamsMergeError, Options<PostRaidTeamsMergeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postRaidTeamsMerge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidInformationQueryKey = (options?: Options<GetRaidInformationData>) => createQueryKey('getRaidInformation', options);

/**
 * Get Raid Information
 *
 * Get raid information
 */
export const getRaidInformationOptions = (options?: Options<GetRaidInformationData>) => queryOptions<GetRaidInformationResponse, DefaultError, GetRaidInformationResponse, ReturnType<typeof getRaidInformationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidInformation({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidInformationQueryKey(options)
});

/**
 * Update Raid Information
 *
 * Update raid information
 */
export const patchRaidInformationMutation = (options?: Partial<Options<PatchRaidInformationData>>): UseMutationOptions<PatchRaidInformationResponse, PatchRaidInformationError, Options<PatchRaidInformationData>> => {
    const mutationOptions: UseMutationOptions<PatchRaidInformationResponse, PatchRaidInformationError, Options<PatchRaidInformationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchRaidInformation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidDriveQueryKey = (options?: Options<GetRaidDriveData>) => createQueryKey('getRaidDrive', options);

/**
 * Get Drive Folders
 *
 * Get drive folders
 */
export const getRaidDriveOptions = (options?: Options<GetRaidDriveData>) => queryOptions<GetRaidDriveResponse, DefaultError, GetRaidDriveResponse, ReturnType<typeof getRaidDriveQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidDrive({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidDriveQueryKey(options)
});

/**
 * Update Drive Folders
 *
 * Update drive folders
 */
export const patchRaidDriveMutation = (options?: Partial<Options<PatchRaidDriveData>>): UseMutationOptions<PatchRaidDriveResponse, PatchRaidDriveError, Options<PatchRaidDriveData>> => {
    const mutationOptions: UseMutationOptions<PatchRaidDriveResponse, PatchRaidDriveError, Options<PatchRaidDriveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchRaidDrive({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidPriceQueryKey = (options?: Options<GetRaidPriceData>) => createQueryKey('getRaidPrice', options);

/**
 * Get Raid Price
 *
 * Get raid price
 */
export const getRaidPriceOptions = (options?: Options<GetRaidPriceData>) => queryOptions<GetRaidPriceResponse, DefaultError, GetRaidPriceResponse, ReturnType<typeof getRaidPriceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidPrice({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidPriceQueryKey(options)
});

/**
 * Update Raid Price
 *
 * Update raid price
 */
export const patchRaidPriceMutation = (options?: Partial<Options<PatchRaidPriceData>>): UseMutationOptions<PatchRaidPriceResponse, PatchRaidPriceError, Options<PatchRaidPriceData>> => {
    const mutationOptions: UseMutationOptions<PatchRaidPriceResponse, PatchRaidPriceError, Options<PatchRaidPriceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchRaidPrice({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRaidPayQueryKey = (options?: Options<GetRaidPayData>) => createQueryKey('getRaidPay', options);

/**
 * Get Payment Url
 *
 * Get payment url
 */
export const getRaidPayOptions = (options?: Options<GetRaidPayData>) => queryOptions<GetRaidPayResponse, DefaultError, GetRaidPayResponse, ReturnType<typeof getRaidPayQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidPay({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidPayQueryKey(options)
});

export const getRaidSecurityFilesZipQueryKey = (options?: Options<GetRaidSecurityFilesZipData>) => createQueryKey('getRaidSecurityFilesZip', options);

/**
 * Download Security Files Zip
 *
 * Generate and serve a ZIP file containing all security files.
 * Only accessible to raid admins.
 */
export const getRaidSecurityFilesZipOptions = (options?: Options<GetRaidSecurityFilesZipData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getRaidSecurityFilesZipQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidSecurityFilesZip({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidSecurityFilesZipQueryKey(options)
});

export const getRaidTeamFilesZipQueryKey = (options?: Options<GetRaidTeamFilesZipData>) => createQueryKey('getRaidTeamFilesZip', options);

/**
 * Download Team Files Zip
 *
 * Generate and serve a ZIP file containing all team files.
 * Only accessible to raid admins.
 */
export const getRaidTeamFilesZipOptions = (options?: Options<GetRaidTeamFilesZipData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getRaidTeamFilesZipQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRaidTeamFilesZip({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRaidTeamFilesZipQueryKey(options)
});

export const getSeedLibrarySpeciesQueryKey = (options?: Options<GetSeedLibrarySpeciesData>) => createQueryKey('getSeedLibrarySpecies', options);

/**
 * Get All Species
 *
 * Return all species from database as a list of SpeciesComplete schemas
 */
export const getSeedLibrarySpeciesOptions = (options?: Options<GetSeedLibrarySpeciesData>) => queryOptions<GetSeedLibrarySpeciesResponse, DefaultError, GetSeedLibrarySpeciesResponse, ReturnType<typeof getSeedLibrarySpeciesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSeedLibrarySpecies({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSeedLibrarySpeciesQueryKey(options)
});

/**
 * Create Species
 *
 * Create a new Species by giving an SpeciesBase scheme
 * **This endpoint is only usable by seed_library **
 */
export const postSeedLibrarySpeciesMutation = (options?: Partial<Options<PostSeedLibrarySpeciesData>>): UseMutationOptions<PostSeedLibrarySpeciesResponse, PostSeedLibrarySpeciesError, Options<PostSeedLibrarySpeciesData>> => {
    const mutationOptions: UseMutationOptions<PostSeedLibrarySpeciesResponse, PostSeedLibrarySpeciesError, Options<PostSeedLibrarySpeciesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postSeedLibrarySpecies({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSeedLibrarySpeciesTypesQueryKey = (options?: Options<GetSeedLibrarySpeciesTypesData>) => createQueryKey('getSeedLibrarySpeciesTypes', options);

/**
 * Get All Species Types
 *
 * Return all available types of species from SpeciesType enum.
 */
export const getSeedLibrarySpeciesTypesOptions = (options?: Options<GetSeedLibrarySpeciesTypesData>) => queryOptions<GetSeedLibrarySpeciesTypesResponse, DefaultError, GetSeedLibrarySpeciesTypesResponse, ReturnType<typeof getSeedLibrarySpeciesTypesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSeedLibrarySpeciesTypes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSeedLibrarySpeciesTypesQueryKey(options)
});

/**
 * Delete Species
 *
 * Delete a Species
 * **This endpoint is only usable by seed_library**
 */
export const deleteSeedLibrarySpeciesSpeciesIdMutation = (options?: Partial<Options<DeleteSeedLibrarySpeciesSpeciesIdData>>): UseMutationOptions<DeleteSeedLibrarySpeciesSpeciesIdResponse, DeleteSeedLibrarySpeciesSpeciesIdError, Options<DeleteSeedLibrarySpeciesSpeciesIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteSeedLibrarySpeciesSpeciesIdResponse, DeleteSeedLibrarySpeciesSpeciesIdError, Options<DeleteSeedLibrarySpeciesSpeciesIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSeedLibrarySpeciesSpeciesId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Species
 *
 * Update a Species
 * **This endpoint is only usable by seed_library**
 */
export const patchSeedLibrarySpeciesSpeciesIdMutation = (options?: Partial<Options<PatchSeedLibrarySpeciesSpeciesIdData>>): UseMutationOptions<PatchSeedLibrarySpeciesSpeciesIdResponse, PatchSeedLibrarySpeciesSpeciesIdError, Options<PatchSeedLibrarySpeciesSpeciesIdData>> => {
    const mutationOptions: UseMutationOptions<PatchSeedLibrarySpeciesSpeciesIdResponse, PatchSeedLibrarySpeciesSpeciesIdError, Options<PatchSeedLibrarySpeciesSpeciesIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchSeedLibrarySpeciesSpeciesId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSeedLibraryPlantsWaitingQueryKey = (options?: Options<GetSeedLibraryPlantsWaitingData>) => createQueryKey('getSeedLibraryPlantsWaiting', options);

/**
 * Get Waiting Plants
 *
 * Return all plants where state=waiting from database as a list of PlantsComplete schemas
 */
export const getSeedLibraryPlantsWaitingOptions = (options?: Options<GetSeedLibraryPlantsWaitingData>) => queryOptions<GetSeedLibraryPlantsWaitingResponse, DefaultError, GetSeedLibraryPlantsWaitingResponse, ReturnType<typeof getSeedLibraryPlantsWaitingQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSeedLibraryPlantsWaiting({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSeedLibraryPlantsWaitingQueryKey(options)
});

export const getSeedLibraryPlantsUsersMeQueryKey = (options?: Options<GetSeedLibraryPlantsUsersMeData>) => createQueryKey('getSeedLibraryPlantsUsersMe', options);

/**
 * Get My Plants
 *
 * Return all plants where user ={user_id} from database as a list of PlantsComplete schemas
 */
export const getSeedLibraryPlantsUsersMeOptions = (options?: Options<GetSeedLibraryPlantsUsersMeData>) => queryOptions<GetSeedLibraryPlantsUsersMeResponse, DefaultError, GetSeedLibraryPlantsUsersMeResponse, ReturnType<typeof getSeedLibraryPlantsUsersMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSeedLibraryPlantsUsersMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSeedLibraryPlantsUsersMeQueryKey(options)
});

export const getSeedLibraryPlantsUsersUserIdQueryKey = (options: Options<GetSeedLibraryPlantsUsersUserIdData>) => createQueryKey('getSeedLibraryPlantsUsersUserId', options);

/**
 * Get Plants By User Id
 *
 * Return all plants where borrower_id = {user_id} from database as a list of PlantsComplete schemas
 */
export const getSeedLibraryPlantsUsersUserIdOptions = (options: Options<GetSeedLibraryPlantsUsersUserIdData>) => queryOptions<GetSeedLibraryPlantsUsersUserIdResponse, GetSeedLibraryPlantsUsersUserIdError, GetSeedLibraryPlantsUsersUserIdResponse, ReturnType<typeof getSeedLibraryPlantsUsersUserIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSeedLibraryPlantsUsersUserId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSeedLibraryPlantsUsersUserIdQueryKey(options)
});

/**
 * Delete Plant
 *
 * Delete a Plant
 * **This endpoint is only usable by seed_library**
 */
export const deleteSeedLibraryPlantsPlantIdMutation = (options?: Partial<Options<DeleteSeedLibraryPlantsPlantIdData>>): UseMutationOptions<DeleteSeedLibraryPlantsPlantIdResponse, DeleteSeedLibraryPlantsPlantIdError, Options<DeleteSeedLibraryPlantsPlantIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteSeedLibraryPlantsPlantIdResponse, DeleteSeedLibraryPlantsPlantIdError, Options<DeleteSeedLibraryPlantsPlantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSeedLibraryPlantsPlantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSeedLibraryPlantsPlantIdQueryKey = (options: Options<GetSeedLibraryPlantsPlantIdData>) => createQueryKey('getSeedLibraryPlantsPlantId', options);

/**
 * Get Plant By Id
 *
 * Return the plants where plant ={plant_id} from database as a PlantsComplete schemas
 */
export const getSeedLibraryPlantsPlantIdOptions = (options: Options<GetSeedLibraryPlantsPlantIdData>) => queryOptions<GetSeedLibraryPlantsPlantIdResponse, GetSeedLibraryPlantsPlantIdError, GetSeedLibraryPlantsPlantIdResponse, ReturnType<typeof getSeedLibraryPlantsPlantIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSeedLibraryPlantsPlantId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSeedLibraryPlantsPlantIdQueryKey(options)
});

/**
 * Update Plant
 *
 * Update a Plant
 * **This endpoint is only usable by the owner of the plant**
 */
export const patchSeedLibraryPlantsPlantIdMutation = (options?: Partial<Options<PatchSeedLibraryPlantsPlantIdData>>): UseMutationOptions<PatchSeedLibraryPlantsPlantIdResponse, PatchSeedLibraryPlantsPlantIdError, Options<PatchSeedLibraryPlantsPlantIdData>> => {
    const mutationOptions: UseMutationOptions<PatchSeedLibraryPlantsPlantIdResponse, PatchSeedLibraryPlantsPlantIdError, Options<PatchSeedLibraryPlantsPlantIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchSeedLibraryPlantsPlantId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Plant
 *
 * Create a new Plant by giving an PlantCreation scheme
 * **This endpoint is only usable if the plant has an ancestor_id or by seed_library **
 */
export const postSeedLibraryPlantsMutation = (options?: Partial<Options<PostSeedLibraryPlantsData>>): UseMutationOptions<PostSeedLibraryPlantsResponse, PostSeedLibraryPlantsError, Options<PostSeedLibraryPlantsData>> => {
    const mutationOptions: UseMutationOptions<PostSeedLibraryPlantsResponse, PostSeedLibraryPlantsError, Options<PostSeedLibraryPlantsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postSeedLibraryPlants({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Plant Admin
 *
 * Update a Plant
 * **This endpoint is only usable by seed_library**
 */
export const patchSeedLibraryPlantsPlantIdAdminMutation = (options?: Partial<Options<PatchSeedLibraryPlantsPlantIdAdminData>>): UseMutationOptions<PatchSeedLibraryPlantsPlantIdAdminResponse, PatchSeedLibraryPlantsPlantIdAdminError, Options<PatchSeedLibraryPlantsPlantIdAdminData>> => {
    const mutationOptions: UseMutationOptions<PatchSeedLibraryPlantsPlantIdAdminResponse, PatchSeedLibraryPlantsPlantIdAdminError, Options<PatchSeedLibraryPlantsPlantIdAdminData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchSeedLibraryPlantsPlantIdAdmin({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Borrow Plant
 *
 * Plant borrowed by the user (modify borrowing date, borrower and state)
 */
export const patchSeedLibraryPlantsPlantIdBorrowMutation = (options?: Partial<Options<PatchSeedLibraryPlantsPlantIdBorrowData>>): UseMutationOptions<PatchSeedLibraryPlantsPlantIdBorrowResponse, PatchSeedLibraryPlantsPlantIdBorrowError, Options<PatchSeedLibraryPlantsPlantIdBorrowData>> => {
    const mutationOptions: UseMutationOptions<PatchSeedLibraryPlantsPlantIdBorrowResponse, PatchSeedLibraryPlantsPlantIdBorrowError, Options<PatchSeedLibraryPlantsPlantIdBorrowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchSeedLibraryPlantsPlantIdBorrow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSeedLibraryInformationQueryKey = (options?: Options<GetSeedLibraryInformationData>) => createQueryKey('getSeedLibraryInformation', options);

/**
 * Get Seed Library Information
 */
export const getSeedLibraryInformationOptions = (options?: Options<GetSeedLibraryInformationData>) => queryOptions<GetSeedLibraryInformationResponse, DefaultError, GetSeedLibraryInformationResponse, ReturnType<typeof getSeedLibraryInformationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSeedLibraryInformation({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSeedLibraryInformationQueryKey(options)
});

/**
 * Update Seed Library Information
 */
export const patchSeedLibraryInformationMutation = (options?: Partial<Options<PatchSeedLibraryInformationData>>): UseMutationOptions<PatchSeedLibraryInformationResponse, PatchSeedLibraryInformationError, Options<PatchSeedLibraryInformationData>> => {
    const mutationOptions: UseMutationOptions<PatchSeedLibraryInformationResponse, PatchSeedLibraryInformationError, Options<PatchSeedLibraryInformationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchSeedLibraryInformation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBookingManagersQueryKey = (options?: Options<GetBookingManagersData>) => createQueryKey('getBookingManagers', options);

/**
 * Get Managers
 *
 * Get existing managers.
 *
 * **This endpoint is only usable by administrators**
 */
export const getBookingManagersOptions = (options?: Options<GetBookingManagersData>) => queryOptions<GetBookingManagersResponse, DefaultError, GetBookingManagersResponse, ReturnType<typeof getBookingManagersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBookingManagers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBookingManagersQueryKey(options)
});

/**
 * Create Manager
 *
 * Create a manager.
 *
 * **This endpoint is only usable by administrators**
 */
export const postBookingManagersMutation = (options?: Partial<Options<PostBookingManagersData>>): UseMutationOptions<PostBookingManagersResponse, PostBookingManagersError, Options<PostBookingManagersData>> => {
    const mutationOptions: UseMutationOptions<PostBookingManagersResponse, PostBookingManagersError, Options<PostBookingManagersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postBookingManagers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Manager
 *
 * Delete a manager only if the manager is not linked to any room
 *
 * **This endpoint is only usable by administrators**
 */
export const deleteBookingManagersManagerIdMutation = (options?: Partial<Options<DeleteBookingManagersManagerIdData>>): UseMutationOptions<DeleteBookingManagersManagerIdResponse, DeleteBookingManagersManagerIdError, Options<DeleteBookingManagersManagerIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteBookingManagersManagerIdResponse, DeleteBookingManagersManagerIdError, Options<DeleteBookingManagersManagerIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBookingManagersManagerId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Manager
 *
 * Update a manager, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const patchBookingManagersManagerIdMutation = (options?: Partial<Options<PatchBookingManagersManagerIdData>>): UseMutationOptions<PatchBookingManagersManagerIdResponse, PatchBookingManagersManagerIdError, Options<PatchBookingManagersManagerIdData>> => {
    const mutationOptions: UseMutationOptions<PatchBookingManagersManagerIdResponse, PatchBookingManagersManagerIdError, Options<PatchBookingManagersManagerIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchBookingManagersManagerId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBookingManagersUsersMeQueryKey = (options?: Options<GetBookingManagersUsersMeData>) => createQueryKey('getBookingManagersUsersMe', options);

/**
 * Get Current User Managers
 *
 * Return all managers the current user is a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getBookingManagersUsersMeOptions = (options?: Options<GetBookingManagersUsersMeData>) => queryOptions<GetBookingManagersUsersMeResponse, DefaultError, GetBookingManagersUsersMeResponse, ReturnType<typeof getBookingManagersUsersMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBookingManagersUsersMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBookingManagersUsersMeQueryKey(options)
});

export const getBookingBookingsUsersMeManageQueryKey = (options?: Options<GetBookingBookingsUsersMeManageData>) => createQueryKey('getBookingBookingsUsersMeManage', options);

/**
 * Get Bookings For Manager
 *
 * Return all bookings a user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getBookingBookingsUsersMeManageOptions = (options?: Options<GetBookingBookingsUsersMeManageData>) => queryOptions<GetBookingBookingsUsersMeManageResponse, DefaultError, GetBookingBookingsUsersMeManageResponse, ReturnType<typeof getBookingBookingsUsersMeManageQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBookingBookingsUsersMeManage({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBookingBookingsUsersMeManageQueryKey(options)
});

export const getBookingBookingsConfirmedUsersMeManageQueryKey = (options?: Options<GetBookingBookingsConfirmedUsersMeManageData>) => createQueryKey('getBookingBookingsConfirmedUsersMeManage', options);

/**
 * Get Confirmed Bookings For Manager
 *
 * Return all confirmed bookings a user can manage.
 * **The user must be authenticated to use this endpoint**
 */
export const getBookingBookingsConfirmedUsersMeManageOptions = (options?: Options<GetBookingBookingsConfirmedUsersMeManageData>) => queryOptions<GetBookingBookingsConfirmedUsersMeManageResponse, DefaultError, GetBookingBookingsConfirmedUsersMeManageResponse, ReturnType<typeof getBookingBookingsConfirmedUsersMeManageQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBookingBookingsConfirmedUsersMeManage({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBookingBookingsConfirmedUsersMeManageQueryKey(options)
});

export const getBookingBookingsConfirmedQueryKey = (options?: Options<GetBookingBookingsConfirmedData>) => createQueryKey('getBookingBookingsConfirmed', options);

/**
 * Get Confirmed Bookings
 *
 * Return all confirmed bookings.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getBookingBookingsConfirmedOptions = (options?: Options<GetBookingBookingsConfirmedData>) => queryOptions<GetBookingBookingsConfirmedResponse, DefaultError, GetBookingBookingsConfirmedResponse, ReturnType<typeof getBookingBookingsConfirmedQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBookingBookingsConfirmed({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBookingBookingsConfirmedQueryKey(options)
});

export const getBookingBookingsUsersMeQueryKey = (options?: Options<GetBookingBookingsUsersMeData>) => createQueryKey('getBookingBookingsUsersMe', options);

/**
 * Get Applicant Bookings
 *
 * Get the user bookings.
 *
 * **Only usable by the user**
 */
export const getBookingBookingsUsersMeOptions = (options?: Options<GetBookingBookingsUsersMeData>) => queryOptions<GetBookingBookingsUsersMeResponse, DefaultError, GetBookingBookingsUsersMeResponse, ReturnType<typeof getBookingBookingsUsersMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBookingBookingsUsersMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBookingBookingsUsersMeQueryKey(options)
});

/**
 * Create Booking
 *
 * Create a booking.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postBookingBookingsMutation = (options?: Partial<Options<PostBookingBookingsData>>): UseMutationOptions<PostBookingBookingsResponse, PostBookingBookingsError, Options<PostBookingBookingsData>> => {
    const mutationOptions: UseMutationOptions<PostBookingBookingsResponse, PostBookingBookingsError, Options<PostBookingBookingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postBookingBookings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Booking
 *
 * Remove a booking.
 *
 * **Only usable by the applicant before decision**
 */
export const deleteBookingBookingsBookingIdMutation = (options?: Partial<Options<DeleteBookingBookingsBookingIdData>>): UseMutationOptions<DeleteBookingBookingsBookingIdResponse, DeleteBookingBookingsBookingIdError, Options<DeleteBookingBookingsBookingIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteBookingBookingsBookingIdResponse, DeleteBookingBookingsBookingIdError, Options<DeleteBookingBookingsBookingIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBookingBookingsBookingId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Booking
 *
 * Edit a booking.
 *
 * **Only usable by a user in the manager group of the booking or applicant before decision**
 */
export const patchBookingBookingsBookingIdMutation = (options?: Partial<Options<PatchBookingBookingsBookingIdData>>): UseMutationOptions<PatchBookingBookingsBookingIdResponse, PatchBookingBookingsBookingIdError, Options<PatchBookingBookingsBookingIdData>> => {
    const mutationOptions: UseMutationOptions<PatchBookingBookingsBookingIdResponse, PatchBookingBookingsBookingIdError, Options<PatchBookingBookingsBookingIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchBookingBookingsBookingId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Confirm Booking
 *
 * Give a decision to a booking.
 *
 * **Only usable by a user in the manager group of the booking**
 */
export const patchBookingBookingsBookingIdReplyDecisionMutation = (options?: Partial<Options<PatchBookingBookingsBookingIdReplyDecisionData>>): UseMutationOptions<PatchBookingBookingsBookingIdReplyDecisionResponse, PatchBookingBookingsBookingIdReplyDecisionError, Options<PatchBookingBookingsBookingIdReplyDecisionData>> => {
    const mutationOptions: UseMutationOptions<PatchBookingBookingsBookingIdReplyDecisionResponse, PatchBookingBookingsBookingIdReplyDecisionError, Options<PatchBookingBookingsBookingIdReplyDecisionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchBookingBookingsBookingIdReplyDecision({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBookingRoomsQueryKey = (options?: Options<GetBookingRoomsData>) => createQueryKey('getBookingRooms', options);

/**
 * Get Rooms
 *
 * Get all rooms.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getBookingRoomsOptions = (options?: Options<GetBookingRoomsData>) => queryOptions<GetBookingRoomsResponse, DefaultError, GetBookingRoomsResponse, ReturnType<typeof getBookingRoomsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBookingRooms({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBookingRoomsQueryKey(options)
});

/**
 * Create Room
 *
 * Create a new room in database.
 *
 * **This endpoint is only usable by admins**
 */
export const postBookingRoomsMutation = (options?: Partial<Options<PostBookingRoomsData>>): UseMutationOptions<PostBookingRoomsResponse, PostBookingRoomsError, Options<PostBookingRoomsData>> => {
    const mutationOptions: UseMutationOptions<PostBookingRoomsResponse, PostBookingRoomsError, Options<PostBookingRoomsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postBookingRooms({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Room
 *
 * Delete a room only if there are not future or ongoing bookings of this room
 *
 * **This endpoint is only usable by admins**
 */
export const deleteBookingRoomsRoomIdMutation = (options?: Partial<Options<DeleteBookingRoomsRoomIdData>>): UseMutationOptions<DeleteBookingRoomsRoomIdResponse, DeleteBookingRoomsRoomIdError, Options<DeleteBookingRoomsRoomIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteBookingRoomsRoomIdResponse, DeleteBookingRoomsRoomIdError, Options<DeleteBookingRoomsRoomIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBookingRoomsRoomId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Room
 *
 * Edit a room.
 *
 * **This endpoint is only usable by admins**
 */
export const patchBookingRoomsRoomIdMutation = (options?: Partial<Options<PatchBookingRoomsRoomIdData>>): UseMutationOptions<PatchBookingRoomsRoomIdResponse, PatchBookingRoomsRoomIdError, Options<PatchBookingRoomsRoomIdData>> => {
    const mutationOptions: UseMutationOptions<PatchBookingRoomsRoomIdResponse, PatchBookingRoomsRoomIdError, Options<PatchBookingRoomsRoomIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchBookingRoomsRoomId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPhonebookAssociationsQueryKey = (options?: Options<GetPhonebookAssociationsData>) => createQueryKey('getPhonebookAssociations', options);

/**
 * Get All Associations
 *
 * Return all associations from database as a list of AssociationComplete schemas
 */
export const getPhonebookAssociationsOptions = (options?: Options<GetPhonebookAssociationsData>) => queryOptions<GetPhonebookAssociationsResponse, DefaultError, GetPhonebookAssociationsResponse, ReturnType<typeof getPhonebookAssociationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhonebookAssociations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhonebookAssociationsQueryKey(options)
});

/**
 * Create Association
 *
 * Create a new Association by giving an AssociationBase scheme
 *
 * **This endpoint is only usable by CAA, BDE**
 */
export const postPhonebookAssociationsMutation = (options?: Partial<Options<PostPhonebookAssociationsData>>): UseMutationOptions<PostPhonebookAssociationsResponse, PostPhonebookAssociationsError, Options<PostPhonebookAssociationsData>> => {
    const mutationOptions: UseMutationOptions<PostPhonebookAssociationsResponse, PostPhonebookAssociationsError, Options<PostPhonebookAssociationsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPhonebookAssociations({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPhonebookRoletagsQueryKey = (options?: Options<GetPhonebookRoletagsData>) => createQueryKey('getPhonebookRoletags', options);

/**
 * Get All Role Tags
 *
 * Return all available role tags from RoleTags enum.
 */
export const getPhonebookRoletagsOptions = (options?: Options<GetPhonebookRoletagsData>) => queryOptions<GetPhonebookRoletagsResponse, DefaultError, GetPhonebookRoletagsResponse, ReturnType<typeof getPhonebookRoletagsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhonebookRoletags({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhonebookRoletagsQueryKey(options)
});

export const getPhonebookAssociationsKindsQueryKey = (options?: Options<GetPhonebookAssociationsKindsData>) => createQueryKey('getPhonebookAssociationsKinds', options);

/**
 * Get All Kinds
 *
 * Return all available kinds of from Kinds enum.
 */
export const getPhonebookAssociationsKindsOptions = (options?: Options<GetPhonebookAssociationsKindsData>) => queryOptions<GetPhonebookAssociationsKindsResponse, DefaultError, GetPhonebookAssociationsKindsResponse, ReturnType<typeof getPhonebookAssociationsKindsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhonebookAssociationsKinds({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhonebookAssociationsKindsQueryKey(options)
});

/**
 * Delete Association
 *
 * Delete an Association
 *
 * [!] Memberships linked to association_id will be deleted too
 *
 * **This endpoint is only usable by CAA and BDE**
 */
export const deletePhonebookAssociationsAssociationIdMutation = (options?: Partial<Options<DeletePhonebookAssociationsAssociationIdData>>): UseMutationOptions<DeletePhonebookAssociationsAssociationIdResponse, DeletePhonebookAssociationsAssociationIdError, Options<DeletePhonebookAssociationsAssociationIdData>> => {
    const mutationOptions: UseMutationOptions<DeletePhonebookAssociationsAssociationIdResponse, DeletePhonebookAssociationsAssociationIdError, Options<DeletePhonebookAssociationsAssociationIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePhonebookAssociationsAssociationId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Association
 *
 * Update an Association
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const patchPhonebookAssociationsAssociationIdMutation = (options?: Partial<Options<PatchPhonebookAssociationsAssociationIdData>>): UseMutationOptions<PatchPhonebookAssociationsAssociationIdResponse, PatchPhonebookAssociationsAssociationIdError, Options<PatchPhonebookAssociationsAssociationIdData>> => {
    const mutationOptions: UseMutationOptions<PatchPhonebookAssociationsAssociationIdResponse, PatchPhonebookAssociationsAssociationIdError, Options<PatchPhonebookAssociationsAssociationIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchPhonebookAssociationsAssociationId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Association Groups
 *
 * Update the groups associated with an Association
 *
 * **This endpoint is only usable by Admins (not BDE and CAA)**
 */
export const patchPhonebookAssociationsAssociationIdGroupsMutation = (options?: Partial<Options<PatchPhonebookAssociationsAssociationIdGroupsData>>): UseMutationOptions<PatchPhonebookAssociationsAssociationIdGroupsResponse, PatchPhonebookAssociationsAssociationIdGroupsError, Options<PatchPhonebookAssociationsAssociationIdGroupsData>> => {
    const mutationOptions: UseMutationOptions<PatchPhonebookAssociationsAssociationIdGroupsResponse, PatchPhonebookAssociationsAssociationIdGroupsError, Options<PatchPhonebookAssociationsAssociationIdGroupsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchPhonebookAssociationsAssociationIdGroups({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deactivate Association
 *
 * Deactivate an Association
 *
 * **This endpoint is only usable by CAA and BDE**
 */
export const patchPhonebookAssociationsAssociationIdDeactivateMutation = (options?: Partial<Options<PatchPhonebookAssociationsAssociationIdDeactivateData>>): UseMutationOptions<PatchPhonebookAssociationsAssociationIdDeactivateResponse, PatchPhonebookAssociationsAssociationIdDeactivateError, Options<PatchPhonebookAssociationsAssociationIdDeactivateData>> => {
    const mutationOptions: UseMutationOptions<PatchPhonebookAssociationsAssociationIdDeactivateResponse, PatchPhonebookAssociationsAssociationIdDeactivateError, Options<PatchPhonebookAssociationsAssociationIdDeactivateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchPhonebookAssociationsAssociationIdDeactivate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPhonebookAssociationsAssociationIdMembersQueryKey = (options: Options<GetPhonebookAssociationsAssociationIdMembersData>) => createQueryKey('getPhonebookAssociationsAssociationIdMembers', options);

/**
 * Get Association Members
 *
 * Return the list of MemberComplete of an Association.
 */
export const getPhonebookAssociationsAssociationIdMembersOptions = (options: Options<GetPhonebookAssociationsAssociationIdMembersData>) => queryOptions<GetPhonebookAssociationsAssociationIdMembersResponse, GetPhonebookAssociationsAssociationIdMembersError, GetPhonebookAssociationsAssociationIdMembersResponse, ReturnType<typeof getPhonebookAssociationsAssociationIdMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhonebookAssociationsAssociationIdMembers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhonebookAssociationsAssociationIdMembersQueryKey(options)
});

export const getPhonebookAssociationsAssociationIdMembersMandateYearQueryKey = (options: Options<GetPhonebookAssociationsAssociationIdMembersMandateYearData>) => createQueryKey('getPhonebookAssociationsAssociationIdMembersMandateYear', options);

/**
 * Get Association Members By Mandate Year
 *
 * Return the list of MemberComplete of an Association with given mandate_year.
 */
export const getPhonebookAssociationsAssociationIdMembersMandateYearOptions = (options: Options<GetPhonebookAssociationsAssociationIdMembersMandateYearData>) => queryOptions<GetPhonebookAssociationsAssociationIdMembersMandateYearResponse, GetPhonebookAssociationsAssociationIdMembersMandateYearError, GetPhonebookAssociationsAssociationIdMembersMandateYearResponse, ReturnType<typeof getPhonebookAssociationsAssociationIdMembersMandateYearQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhonebookAssociationsAssociationIdMembersMandateYear({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhonebookAssociationsAssociationIdMembersMandateYearQueryKey(options)
});

export const getPhonebookMemberUserIdQueryKey = (options: Options<GetPhonebookMemberUserIdData>) => createQueryKey('getPhonebookMemberUserId', options);

/**
 * Get Member Details
 *
 * Return MemberComplete for given user_id.
 */
export const getPhonebookMemberUserIdOptions = (options: Options<GetPhonebookMemberUserIdData>) => queryOptions<GetPhonebookMemberUserIdResponse, GetPhonebookMemberUserIdError, GetPhonebookMemberUserIdResponse, ReturnType<typeof getPhonebookMemberUserIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhonebookMemberUserId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhonebookMemberUserIdQueryKey(options)
});

/**
 * Create Membership
 *
 * Create a new Membership.
 * 'role_tags' are used to indicate if the members has a main role in the association (president, secretary ...) and 'role_name' is the display name for this membership
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const postPhonebookAssociationsMembershipsMutation = (options?: Partial<Options<PostPhonebookAssociationsMembershipsData>>): UseMutationOptions<PostPhonebookAssociationsMembershipsResponse, PostPhonebookAssociationsMembershipsError, Options<PostPhonebookAssociationsMembershipsData>> => {
    const mutationOptions: UseMutationOptions<PostPhonebookAssociationsMembershipsResponse, PostPhonebookAssociationsMembershipsError, Options<PostPhonebookAssociationsMembershipsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPhonebookAssociationsMemberships({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Membership
 *
 * Delete a membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const deletePhonebookAssociationsMembershipsMembershipIdMutation = (options?: Partial<Options<DeletePhonebookAssociationsMembershipsMembershipIdData>>): UseMutationOptions<DeletePhonebookAssociationsMembershipsMembershipIdResponse, DeletePhonebookAssociationsMembershipsMembershipIdError, Options<DeletePhonebookAssociationsMembershipsMembershipIdData>> => {
    const mutationOptions: UseMutationOptions<DeletePhonebookAssociationsMembershipsMembershipIdResponse, DeletePhonebookAssociationsMembershipsMembershipIdError, Options<DeletePhonebookAssociationsMembershipsMembershipIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePhonebookAssociationsMembershipsMembershipId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Membership
 *
 * Update a Membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const patchPhonebookAssociationsMembershipsMembershipIdMutation = (options?: Partial<Options<PatchPhonebookAssociationsMembershipsMembershipIdData>>): UseMutationOptions<PatchPhonebookAssociationsMembershipsMembershipIdResponse, PatchPhonebookAssociationsMembershipsMembershipIdError, Options<PatchPhonebookAssociationsMembershipsMembershipIdData>> => {
    const mutationOptions: UseMutationOptions<PatchPhonebookAssociationsMembershipsMembershipIdResponse, PatchPhonebookAssociationsMembershipsMembershipIdError, Options<PatchPhonebookAssociationsMembershipsMembershipIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchPhonebookAssociationsMembershipsMembershipId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPhonebookAssociationsAssociationIdPictureQueryKey = (options: Options<GetPhonebookAssociationsAssociationIdPictureData>) => createQueryKey('getPhonebookAssociationsAssociationIdPicture', options);

/**
 * Read Association Logo
 *
 * Get the logo of an Association.
 */
export const getPhonebookAssociationsAssociationIdPictureOptions = (options: Options<GetPhonebookAssociationsAssociationIdPictureData>) => queryOptions<unknown, GetPhonebookAssociationsAssociationIdPictureError, unknown, ReturnType<typeof getPhonebookAssociationsAssociationIdPictureQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhonebookAssociationsAssociationIdPicture({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhonebookAssociationsAssociationIdPictureQueryKey(options)
});

/**
 * Create Association Logo
 *
 * Upload a logo for an Association.
 * **The user must be a member of the group CAA or BDE to use this endpoint**
 */
export const postPhonebookAssociationsAssociationIdPictureMutation = (options?: Partial<Options<PostPhonebookAssociationsAssociationIdPictureData>>): UseMutationOptions<PostPhonebookAssociationsAssociationIdPictureResponse, PostPhonebookAssociationsAssociationIdPictureError, Options<PostPhonebookAssociationsAssociationIdPictureData>> => {
    const mutationOptions: UseMutationOptions<PostPhonebookAssociationsAssociationIdPictureResponse, PostPhonebookAssociationsAssociationIdPictureError, Options<PostPhonebookAssociationsAssociationIdPictureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPhonebookAssociationsAssociationIdPicture({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPmfOffersOfferIdQueryKey = (options: Options<GetPmfOffersOfferIdData>) => createQueryKey('getPmfOffersOfferId', options);

/**
 * Get Offer
 */
export const getPmfOffersOfferIdOptions = (options: Options<GetPmfOffersOfferIdData>) => queryOptions<GetPmfOffersOfferIdResponse, GetPmfOffersOfferIdError, GetPmfOffersOfferIdResponse, ReturnType<typeof getPmfOffersOfferIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPmfOffersOfferId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPmfOffersOfferIdQueryKey(options)
});

export const getPmfOffersQueryKey = (options?: Options<GetPmfOffersData>) => createQueryKey('getPmfOffers', options);

/**
 * Get Offers
 */
export const getPmfOffersOptions = (options?: Options<GetPmfOffersData>) => queryOptions<GetPmfOffersResponse, GetPmfOffersError, GetPmfOffersResponse, ReturnType<typeof getPmfOffersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPmfOffers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPmfOffersQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getPmfOffersInfiniteQueryKey = (options?: Options<GetPmfOffersData>): QueryKey<Options<GetPmfOffersData>> => createQueryKey('getPmfOffers', options, true);

/**
 * Get Offers
 */
export const getPmfOffersInfiniteOptions = (options?: Options<GetPmfOffersData>) => infiniteQueryOptions<GetPmfOffersResponse, GetPmfOffersError, InfiniteData<GetPmfOffersResponse>, QueryKey<Options<GetPmfOffersData>>, number | null | Pick<QueryKey<Options<GetPmfOffersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPmfOffersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPmfOffers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPmfOffersInfiniteQueryKey(options)
});

/**
 * Create Offer
 */
export const postPmfOfferMutation = (options?: Partial<Options<PostPmfOfferData>>): UseMutationOptions<PostPmfOfferResponse, PostPmfOfferError, Options<PostPmfOfferData>> => {
    const mutationOptions: UseMutationOptions<PostPmfOfferResponse, PostPmfOfferError, Options<PostPmfOfferData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPmfOffer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Offer
 */
export const deletePmfOfferOfferIdMutation = (options?: Partial<Options<DeletePmfOfferOfferIdData>>): UseMutationOptions<DeletePmfOfferOfferIdResponse, DeletePmfOfferOfferIdError, Options<DeletePmfOfferOfferIdData>> => {
    const mutationOptions: UseMutationOptions<DeletePmfOfferOfferIdResponse, DeletePmfOfferOfferIdError, Options<DeletePmfOfferOfferIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePmfOfferOfferId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Offer
 */
export const putPmfOfferOfferIdMutation = (options?: Partial<Options<PutPmfOfferOfferIdData>>): UseMutationOptions<PutPmfOfferOfferIdResponse, PutPmfOfferOfferIdError, Options<PutPmfOfferOfferIdData>> => {
    const mutationOptions: UseMutationOptions<PutPmfOfferOfferIdResponse, PutPmfOfferOfferIdError, Options<PutPmfOfferOfferIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putPmfOfferOfferId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPmfTagsQueryKey = (options?: Options<GetPmfTagsData>) => createQueryKey('getPmfTags', options);

/**
 * Get All Tags
 */
export const getPmfTagsOptions = (options?: Options<GetPmfTagsData>) => queryOptions<GetPmfTagsResponse, DefaultError, GetPmfTagsResponse, ReturnType<typeof getPmfTagsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPmfTags({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPmfTagsQueryKey(options)
});

/**
 * Delete Tag
 */
export const deletePmfTagTagIdMutation = (options?: Partial<Options<DeletePmfTagTagIdData>>): UseMutationOptions<DeletePmfTagTagIdResponse, DeletePmfTagTagIdError, Options<DeletePmfTagTagIdData>> => {
    const mutationOptions: UseMutationOptions<DeletePmfTagTagIdResponse, DeletePmfTagTagIdError, Options<DeletePmfTagTagIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePmfTagTagId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPmfTagTagIdQueryKey = (options: Options<GetPmfTagTagIdData>) => createQueryKey('getPmfTagTagId', options);

/**
 * Get Tag
 */
export const getPmfTagTagIdOptions = (options: Options<GetPmfTagTagIdData>) => queryOptions<GetPmfTagTagIdResponse, GetPmfTagTagIdError, GetPmfTagTagIdResponse, ReturnType<typeof getPmfTagTagIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPmfTagTagId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPmfTagTagIdQueryKey(options)
});

/**
 * Update Tag
 */
export const putPmfTagTagIdMutation = (options?: Partial<Options<PutPmfTagTagIdData>>): UseMutationOptions<PutPmfTagTagIdResponse, PutPmfTagTagIdError, Options<PutPmfTagTagIdData>> => {
    const mutationOptions: UseMutationOptions<PutPmfTagTagIdResponse, PutPmfTagTagIdError, Options<PutPmfTagTagIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putPmfTagTagId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Tag
 */
export const postPmfTagMutation = (options?: Partial<Options<PostPmfTagData>>): UseMutationOptions<PostPmfTagResponse, PostPmfTagError, Options<PostPmfTagData>> => {
    const mutationOptions: UseMutationOptions<PostPmfTagResponse, PostPmfTagError, Options<PostPmfTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPmfTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAmapProductsQueryKey = (options?: Options<GetAmapProductsData>) => createQueryKey('getAmapProducts', options);

/**
 * Get Products
 *
 * Return all products
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const getAmapProductsOptions = (options?: Options<GetAmapProductsData>) => queryOptions<GetAmapProductsResponse, DefaultError, GetAmapProductsResponse, ReturnType<typeof getAmapProductsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapProducts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapProductsQueryKey(options)
});

/**
 * Create Product
 *
 * Create a new product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const postAmapProductsMutation = (options?: Partial<Options<PostAmapProductsData>>): UseMutationOptions<PostAmapProductsResponse, PostAmapProductsError, Options<PostAmapProductsData>> => {
    const mutationOptions: UseMutationOptions<PostAmapProductsResponse, PostAmapProductsError, Options<PostAmapProductsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapProducts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Product
 *
 * Delete a product. A product can not be deleted if it is already used in a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const deleteAmapProductsProductIdMutation = (options?: Partial<Options<DeleteAmapProductsProductIdData>>): UseMutationOptions<DeleteAmapProductsProductIdResponse, DeleteAmapProductsProductIdError, Options<DeleteAmapProductsProductIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteAmapProductsProductIdResponse, DeleteAmapProductsProductIdError, Options<DeleteAmapProductsProductIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAmapProductsProductId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAmapProductsProductIdQueryKey = (options: Options<GetAmapProductsProductIdData>) => createQueryKey('getAmapProductsProductId', options);

/**
 * Get Product By Id
 *
 * Get a specific product
 */
export const getAmapProductsProductIdOptions = (options: Options<GetAmapProductsProductIdData>) => queryOptions<GetAmapProductsProductIdResponse, GetAmapProductsProductIdError, GetAmapProductsProductIdResponse, ReturnType<typeof getAmapProductsProductIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapProductsProductId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapProductsProductIdQueryKey(options)
});

/**
 * Edit Product
 *
 * Edit a product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const patchAmapProductsProductIdMutation = (options?: Partial<Options<PatchAmapProductsProductIdData>>): UseMutationOptions<PatchAmapProductsProductIdResponse, PatchAmapProductsProductIdError, Options<PatchAmapProductsProductIdData>> => {
    const mutationOptions: UseMutationOptions<PatchAmapProductsProductIdResponse, PatchAmapProductsProductIdError, Options<PatchAmapProductsProductIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchAmapProductsProductId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAmapDeliveriesQueryKey = (options?: Options<GetAmapDeliveriesData>) => createQueryKey('getAmapDeliveries', options);

/**
 * Get Deliveries
 *
 * Get all deliveries.
 */
export const getAmapDeliveriesOptions = (options?: Options<GetAmapDeliveriesData>) => queryOptions<GetAmapDeliveriesResponse, DefaultError, GetAmapDeliveriesResponse, ReturnType<typeof getAmapDeliveriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapDeliveries({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapDeliveriesQueryKey(options)
});

/**
 * Create Delivery
 *
 * Create a new delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const postAmapDeliveriesMutation = (options?: Partial<Options<PostAmapDeliveriesData>>): UseMutationOptions<PostAmapDeliveriesResponse, PostAmapDeliveriesError, Options<PostAmapDeliveriesData>> => {
    const mutationOptions: UseMutationOptions<PostAmapDeliveriesResponse, PostAmapDeliveriesError, Options<PostAmapDeliveriesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapDeliveries({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Delivery
 *
 * Delete a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const deleteAmapDeliveriesDeliveryIdMutation = (options?: Partial<Options<DeleteAmapDeliveriesDeliveryIdData>>): UseMutationOptions<DeleteAmapDeliveriesDeliveryIdResponse, DeleteAmapDeliveriesDeliveryIdError, Options<DeleteAmapDeliveriesDeliveryIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteAmapDeliveriesDeliveryIdResponse, DeleteAmapDeliveriesDeliveryIdError, Options<DeleteAmapDeliveriesDeliveryIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAmapDeliveriesDeliveryId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Edit Delivery
 *
 * Edit a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const patchAmapDeliveriesDeliveryIdMutation = (options?: Partial<Options<PatchAmapDeliveriesDeliveryIdData>>): UseMutationOptions<PatchAmapDeliveriesDeliveryIdResponse, PatchAmapDeliveriesDeliveryIdError, Options<PatchAmapDeliveriesDeliveryIdData>> => {
    const mutationOptions: UseMutationOptions<PatchAmapDeliveriesDeliveryIdResponse, PatchAmapDeliveriesDeliveryIdError, Options<PatchAmapDeliveriesDeliveryIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchAmapDeliveriesDeliveryId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove Product From Delivery
 *
 * Remove a given product from a delivery. This won't delete the product nor the delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const deleteAmapDeliveriesDeliveryIdProductsMutation = (options?: Partial<Options<DeleteAmapDeliveriesDeliveryIdProductsData>>): UseMutationOptions<DeleteAmapDeliveriesDeliveryIdProductsResponse, DeleteAmapDeliveriesDeliveryIdProductsError, Options<DeleteAmapDeliveriesDeliveryIdProductsData>> => {
    const mutationOptions: UseMutationOptions<DeleteAmapDeliveriesDeliveryIdProductsResponse, DeleteAmapDeliveriesDeliveryIdProductsError, Options<DeleteAmapDeliveriesDeliveryIdProductsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAmapDeliveriesDeliveryIdProducts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add Product To Delivery
 *
 * Add `product_id` product to `delivery_id` delivery. This endpoint will only add a membership between the two objects.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const postAmapDeliveriesDeliveryIdProductsMutation = (options?: Partial<Options<PostAmapDeliveriesDeliveryIdProductsData>>): UseMutationOptions<unknown, PostAmapDeliveriesDeliveryIdProductsError, Options<PostAmapDeliveriesDeliveryIdProductsData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostAmapDeliveriesDeliveryIdProductsError, Options<PostAmapDeliveriesDeliveryIdProductsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapDeliveriesDeliveryIdProducts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAmapDeliveriesDeliveryIdOrdersQueryKey = (options: Options<GetAmapDeliveriesDeliveryIdOrdersData>) => createQueryKey('getAmapDeliveriesDeliveryIdOrders', options);

/**
 * Get Orders From Delivery
 *
 * Get orders from a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const getAmapDeliveriesDeliveryIdOrdersOptions = (options: Options<GetAmapDeliveriesDeliveryIdOrdersData>) => queryOptions<GetAmapDeliveriesDeliveryIdOrdersResponse, GetAmapDeliveriesDeliveryIdOrdersError, GetAmapDeliveriesDeliveryIdOrdersResponse, ReturnType<typeof getAmapDeliveriesDeliveryIdOrdersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapDeliveriesDeliveryIdOrders({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapDeliveriesDeliveryIdOrdersQueryKey(options)
});

/**
 * Remove Order
 *
 * Delete an order.
 *
 * **A member of the group AMAP can delete orders of other users**
 */
export const deleteAmapOrdersOrderIdMutation = (options?: Partial<Options<DeleteAmapOrdersOrderIdData>>): UseMutationOptions<DeleteAmapOrdersOrderIdResponse, DeleteAmapOrdersOrderIdError, Options<DeleteAmapOrdersOrderIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteAmapOrdersOrderIdResponse, DeleteAmapOrdersOrderIdError, Options<DeleteAmapOrdersOrderIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAmapOrdersOrderId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAmapOrdersOrderIdQueryKey = (options: Options<GetAmapOrdersOrderIdData>) => createQueryKey('getAmapOrdersOrderId', options);

/**
 * Get Order By Id
 *
 * Get content of an order.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const getAmapOrdersOrderIdOptions = (options: Options<GetAmapOrdersOrderIdData>) => queryOptions<GetAmapOrdersOrderIdResponse, GetAmapOrdersOrderIdError, GetAmapOrdersOrderIdResponse, ReturnType<typeof getAmapOrdersOrderIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapOrdersOrderId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapOrdersOrderIdQueryKey(options)
});

/**
 * Edit Order From Delivery
 *
 * Edit an order.
 *
 * **A member of the group AMAP can edit orders of other users**
 */
export const patchAmapOrdersOrderIdMutation = (options?: Partial<Options<PatchAmapOrdersOrderIdData>>): UseMutationOptions<PatchAmapOrdersOrderIdResponse, PatchAmapOrdersOrderIdError, Options<PatchAmapOrdersOrderIdData>> => {
    const mutationOptions: UseMutationOptions<PatchAmapOrdersOrderIdResponse, PatchAmapOrdersOrderIdError, Options<PatchAmapOrdersOrderIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchAmapOrdersOrderId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add Order To Delievery
 *
 * Add an order to a delivery.
 *
 * **A member of the group AMAP can create an order for every user**
 */
export const postAmapOrdersMutation = (options?: Partial<Options<PostAmapOrdersData>>): UseMutationOptions<PostAmapOrdersResponse, PostAmapOrdersError, Options<PostAmapOrdersData>> => {
    const mutationOptions: UseMutationOptions<PostAmapOrdersResponse, PostAmapOrdersError, Options<PostAmapOrdersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapOrders({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Open Ordering Of Delivery
 */
export const postAmapDeliveriesDeliveryIdOpenorderingMutation = (options?: Partial<Options<PostAmapDeliveriesDeliveryIdOpenorderingData>>): UseMutationOptions<PostAmapDeliveriesDeliveryIdOpenorderingResponse, PostAmapDeliveriesDeliveryIdOpenorderingError, Options<PostAmapDeliveriesDeliveryIdOpenorderingData>> => {
    const mutationOptions: UseMutationOptions<PostAmapDeliveriesDeliveryIdOpenorderingResponse, PostAmapDeliveriesDeliveryIdOpenorderingError, Options<PostAmapDeliveriesDeliveryIdOpenorderingData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapDeliveriesDeliveryIdOpenordering({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Lock Delivery
 */
export const postAmapDeliveriesDeliveryIdLockMutation = (options?: Partial<Options<PostAmapDeliveriesDeliveryIdLockData>>): UseMutationOptions<PostAmapDeliveriesDeliveryIdLockResponse, PostAmapDeliveriesDeliveryIdLockError, Options<PostAmapDeliveriesDeliveryIdLockData>> => {
    const mutationOptions: UseMutationOptions<PostAmapDeliveriesDeliveryIdLockResponse, PostAmapDeliveriesDeliveryIdLockError, Options<PostAmapDeliveriesDeliveryIdLockData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapDeliveriesDeliveryIdLock({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Mark Delivery As Delivered
 */
export const postAmapDeliveriesDeliveryIdDeliveredMutation = (options?: Partial<Options<PostAmapDeliveriesDeliveryIdDeliveredData>>): UseMutationOptions<PostAmapDeliveriesDeliveryIdDeliveredResponse, PostAmapDeliveriesDeliveryIdDeliveredError, Options<PostAmapDeliveriesDeliveryIdDeliveredData>> => {
    const mutationOptions: UseMutationOptions<PostAmapDeliveriesDeliveryIdDeliveredResponse, PostAmapDeliveriesDeliveryIdDeliveredError, Options<PostAmapDeliveriesDeliveryIdDeliveredData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapDeliveriesDeliveryIdDelivered({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Archive Of Delivery
 */
export const postAmapDeliveriesDeliveryIdArchiveMutation = (options?: Partial<Options<PostAmapDeliveriesDeliveryIdArchiveData>>): UseMutationOptions<PostAmapDeliveriesDeliveryIdArchiveResponse, PostAmapDeliveriesDeliveryIdArchiveError, Options<PostAmapDeliveriesDeliveryIdArchiveData>> => {
    const mutationOptions: UseMutationOptions<PostAmapDeliveriesDeliveryIdArchiveResponse, PostAmapDeliveriesDeliveryIdArchiveError, Options<PostAmapDeliveriesDeliveryIdArchiveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapDeliveriesDeliveryIdArchive({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAmapUsersCashQueryKey = (options?: Options<GetAmapUsersCashData>) => createQueryKey('getAmapUsersCash', options);

/**
 * Get Users Cash
 *
 * Get cash from all users.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const getAmapUsersCashOptions = (options?: Options<GetAmapUsersCashData>) => queryOptions<GetAmapUsersCashResponse, DefaultError, GetAmapUsersCashResponse, ReturnType<typeof getAmapUsersCashQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapUsersCash({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapUsersCashQueryKey(options)
});

export const getAmapUsersUserIdCashQueryKey = (options: Options<GetAmapUsersUserIdCashData>) => createQueryKey('getAmapUsersUserIdCash', options);

/**
 * Get Cash By Id
 *
 * Get cash from a specific user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const getAmapUsersUserIdCashOptions = (options: Options<GetAmapUsersUserIdCashData>) => queryOptions<GetAmapUsersUserIdCashResponse, GetAmapUsersUserIdCashError, GetAmapUsersUserIdCashResponse, ReturnType<typeof getAmapUsersUserIdCashQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapUsersUserIdCash({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapUsersUserIdCashQueryKey(options)
});

/**
 * Edit Cash By Id
 *
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const patchAmapUsersUserIdCashMutation = (options?: Partial<Options<PatchAmapUsersUserIdCashData>>): UseMutationOptions<PatchAmapUsersUserIdCashResponse, PatchAmapUsersUserIdCashError, Options<PatchAmapUsersUserIdCashData>> => {
    const mutationOptions: UseMutationOptions<PatchAmapUsersUserIdCashResponse, PatchAmapUsersUserIdCashError, Options<PatchAmapUsersUserIdCashData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchAmapUsersUserIdCash({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Cash Of User
 *
 * Create cash for an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const postAmapUsersUserIdCashMutation = (options?: Partial<Options<PostAmapUsersUserIdCashData>>): UseMutationOptions<PostAmapUsersUserIdCashResponse, PostAmapUsersUserIdCashError, Options<PostAmapUsersUserIdCashData>> => {
    const mutationOptions: UseMutationOptions<PostAmapUsersUserIdCashResponse, PostAmapUsersUserIdCashError, Options<PostAmapUsersUserIdCashData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAmapUsersUserIdCash({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAmapUsersUserIdOrdersQueryKey = (options: Options<GetAmapUsersUserIdOrdersData>) => createQueryKey('getAmapUsersUserIdOrders', options);

/**
 * Get Orders Of User
 *
 * Get orders from an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const getAmapUsersUserIdOrdersOptions = (options: Options<GetAmapUsersUserIdOrdersData>) => queryOptions<GetAmapUsersUserIdOrdersResponse, GetAmapUsersUserIdOrdersError, GetAmapUsersUserIdOrdersResponse, ReturnType<typeof getAmapUsersUserIdOrdersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapUsersUserIdOrders({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapUsersUserIdOrdersQueryKey(options)
});

export const getAmapInformationQueryKey = (options?: Options<GetAmapInformationData>) => createQueryKey('getAmapInformation', options);

/**
 * Get Information
 *
 * Return all information
 */
export const getAmapInformationOptions = (options?: Options<GetAmapInformationData>) => queryOptions<GetAmapInformationResponse, DefaultError, GetAmapInformationResponse, ReturnType<typeof getAmapInformationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAmapInformation({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAmapInformationQueryKey(options)
});

/**
 * Edit Information
 *
 * Update information
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const patchAmapInformationMutation = (options?: Partial<Options<PatchAmapInformationData>>): UseMutationOptions<PatchAmapInformationResponse, PatchAmapInformationError, Options<PatchAmapInformationData>> => {
    const mutationOptions: UseMutationOptions<PatchAmapInformationResponse, PatchAmapInformationError, Options<PatchAmapInformationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchAmapInformation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPhPaperIdPdfQueryKey = (options: Options<GetPhPaperIdPdfData>) => createQueryKey('getPhPaperIdPdf', options);

/**
 * Get Paper Pdf
 */
export const getPhPaperIdPdfOptions = (options: Options<GetPhPaperIdPdfData>) => queryOptions<unknown, GetPhPaperIdPdfError, unknown, ReturnType<typeof getPhPaperIdPdfQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhPaperIdPdf({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhPaperIdPdfQueryKey(options)
});

/**
 * Create Paper Pdf And Cover
 */
export const postPhPaperIdPdfMutation = (options?: Partial<Options<PostPhPaperIdPdfData>>): UseMutationOptions<unknown, PostPhPaperIdPdfError, Options<PostPhPaperIdPdfData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostPhPaperIdPdfError, Options<PostPhPaperIdPdfData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPhPaperIdPdf({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPhQueryKey = (options?: Options<GetPhData>) => createQueryKey('getPh', options);

/**
 * Get Papers
 *
 * Return all editions until now, sorted from the latest to the oldest
 */
export const getPhOptions = (options?: Options<GetPhData>) => queryOptions<GetPhResponse, DefaultError, GetPhResponse, ReturnType<typeof getPhQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPh({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhQueryKey(options)
});

/**
 * Create Paper
 *
 * Create a new paper.
 */
export const postPhMutation = (options?: Partial<Options<PostPhData>>): UseMutationOptions<PostPhResponse, PostPhError, Options<PostPhData>> => {
    const mutationOptions: UseMutationOptions<PostPhResponse, PostPhError, Options<PostPhData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPh({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPhAdminQueryKey = (options?: Options<GetPhAdminData>) => createQueryKey('getPhAdmin', options);

/**
 * Get Papers Admin
 *
 * Return all editions, sorted from the latest to the oldest
 */
export const getPhAdminOptions = (options?: Options<GetPhAdminData>) => queryOptions<GetPhAdminResponse, DefaultError, GetPhAdminResponse, ReturnType<typeof getPhAdminQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhAdmin({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhAdminQueryKey(options)
});

export const getPhPaperIdCoverQueryKey = (options: Options<GetPhPaperIdCoverData>) => createQueryKey('getPhPaperIdCover', options);

/**
 * Get Cover
 */
export const getPhPaperIdCoverOptions = (options: Options<GetPhPaperIdCoverData>) => queryOptions<unknown, GetPhPaperIdCoverError, unknown, ReturnType<typeof getPhPaperIdCoverQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPhPaperIdCover({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPhPaperIdCoverQueryKey(options)
});

/**
 * Delete Paper
 */
export const deletePhPaperIdMutation = (options?: Partial<Options<DeletePhPaperIdData>>): UseMutationOptions<DeletePhPaperIdResponse, DeletePhPaperIdError, Options<DeletePhPaperIdData>> => {
    const mutationOptions: UseMutationOptions<DeletePhPaperIdResponse, DeletePhPaperIdError, Options<DeletePhPaperIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePhPaperId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Paper
 */
export const patchPhPaperIdMutation = (options?: Partial<Options<PatchPhPaperIdData>>): UseMutationOptions<PatchPhPaperIdResponse, PatchPhPaperIdError, Options<PatchPhPaperIdData>> => {
    const mutationOptions: UseMutationOptions<PatchPhPaperIdResponse, PatchPhPaperIdError, Options<PatchPhPaperIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchPhPaperId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGroupsQueryKey = (options?: Options<GetGroupsData>) => createQueryKey('getGroups', options);

/**
 * Read Groups
 *
 * Return all groups from database as a list of dictionaries
 */
export const getGroupsOptions = (options?: Options<GetGroupsData>) => queryOptions<GetGroupsResponse, DefaultError, GetGroupsResponse, ReturnType<typeof getGroupsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getGroups({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getGroupsQueryKey(options)
});

/**
 * Create Group
 *
 * Create a new group.
 *
 * **This endpoint is only usable by administrators**
 */
export const postGroupsMutation = (options?: Partial<Options<PostGroupsData>>): UseMutationOptions<PostGroupsResponse, PostGroupsError, Options<PostGroupsData>> => {
    const mutationOptions: UseMutationOptions<PostGroupsResponse, PostGroupsError, Options<PostGroupsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGroups({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Group
 *
 * Delete group from database.
 * This will remove the group from all users but won't delete any user.
 *
 * `GroupTypes` groups can not be deleted.
 *
 * **This endpoint is only usable by administrators**
 */
export const deleteGroupsGroupIdMutation = (options?: Partial<Options<DeleteGroupsGroupIdData>>): UseMutationOptions<DeleteGroupsGroupIdResponse, DeleteGroupsGroupIdError, Options<DeleteGroupsGroupIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteGroupsGroupIdResponse, DeleteGroupsGroupIdError, Options<DeleteGroupsGroupIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGroupsGroupId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGroupsGroupIdQueryKey = (options: Options<GetGroupsGroupIdData>) => createQueryKey('getGroupsGroupId', options);

/**
 * Read Group
 *
 * Return group with id from database as a dictionary. This includes a list of users being members of the group.
 *
 * **This endpoint is only usable by administrators**
 */
export const getGroupsGroupIdOptions = (options: Options<GetGroupsGroupIdData>) => queryOptions<GetGroupsGroupIdResponse, GetGroupsGroupIdError, GetGroupsGroupIdResponse, ReturnType<typeof getGroupsGroupIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getGroupsGroupId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getGroupsGroupIdQueryKey(options)
});

/**
 * Update Group
 *
 * Update the name or the description of a group.
 *
 * **This endpoint is only usable by administrators**
 */
export const patchGroupsGroupIdMutation = (options?: Partial<Options<PatchGroupsGroupIdData>>): UseMutationOptions<PatchGroupsGroupIdResponse, PatchGroupsGroupIdError, Options<PatchGroupsGroupIdData>> => {
    const mutationOptions: UseMutationOptions<PatchGroupsGroupIdResponse, PatchGroupsGroupIdError, Options<PatchGroupsGroupIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchGroupsGroupId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Membership
 *
 * Delete a membership using the user and group ids.
 *
 * **This endpoint is only usable by administrators**
 */
export const deleteGroupsMembershipMutation = (options?: Partial<Options<DeleteGroupsMembershipData>>): UseMutationOptions<DeleteGroupsMembershipResponse, DeleteGroupsMembershipError, Options<DeleteGroupsMembershipData>> => {
    const mutationOptions: UseMutationOptions<DeleteGroupsMembershipResponse, DeleteGroupsMembershipError, Options<DeleteGroupsMembershipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGroupsMembership({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Membership
 *
 * Create a new membership in database and return the group. This allows to "add a user to a group".
 *
 * **This endpoint is only usable by administrators**
 */
export const postGroupsMembershipMutation = (options?: Partial<Options<PostGroupsMembershipData>>): UseMutationOptions<PostGroupsMembershipResponse, PostGroupsMembershipError, Options<PostGroupsMembershipData>> => {
    const mutationOptions: UseMutationOptions<PostGroupsMembershipResponse, PostGroupsMembershipError, Options<PostGroupsMembershipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGroupsMembership({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Batch Membership
 *
 * This endpoint removes all users from a given group.
 *
 * **This endpoint is only usable by administrators**
 */
export const deleteGroupsBatchMembershipMutation = (options?: Partial<Options<DeleteGroupsBatchMembershipData>>): UseMutationOptions<DeleteGroupsBatchMembershipResponse, DeleteGroupsBatchMembershipError, Options<DeleteGroupsBatchMembershipData>> => {
    const mutationOptions: UseMutationOptions<DeleteGroupsBatchMembershipResponse, DeleteGroupsBatchMembershipError, Options<DeleteGroupsBatchMembershipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteGroupsBatchMembership({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create Batch Membership
 *
 * Add a list of user to a group, using a list of email.
 * If an user does not exist it will be ignored.
 *
 * **This endpoint is only usable by administrators**
 */
export const postGroupsBatchMembershipMutation = (options?: Partial<Options<PostGroupsBatchMembershipData>>): UseMutationOptions<PostGroupsBatchMembershipResponse, PostGroupsBatchMembershipError, Options<PostGroupsBatchMembershipData>> => {
    const mutationOptions: UseMutationOptions<PostGroupsBatchMembershipResponse, PostGroupsBatchMembershipError, Options<PostGroupsBatchMembershipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postGroupsBatchMembership({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNotificationDevicesQueryKey = (options?: Options<GetNotificationDevicesData>) => createQueryKey('getNotificationDevices', options);

/**
 * Get Devices
 *
 * Get all devices a user have registered.
 * This endpoint is useful to get firebase tokens for debugging purposes.
 *
 * **Only admins can use this endpoint**
 */
export const getNotificationDevicesOptions = (options?: Options<GetNotificationDevicesData>) => queryOptions<GetNotificationDevicesResponse, GetNotificationDevicesError, GetNotificationDevicesResponse, ReturnType<typeof getNotificationDevicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNotificationDevices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNotificationDevicesQueryKey(options)
});

/**
 * Register Firebase Device
 *
 * Register a firebase device for the user, if the device already exists, this will update the creation date.
 * This endpoint should be called once a month to ensure that the token is still valide.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postNotificationDevicesMutation = (options?: Partial<Options<PostNotificationDevicesData>>): UseMutationOptions<PostNotificationDevicesResponse, PostNotificationDevicesError, Options<PostNotificationDevicesData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationDevicesResponse, PostNotificationDevicesError, Options<PostNotificationDevicesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postNotificationDevices({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unregister Firebase Device
 *
 * Unregister a firebase device for the user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const deleteNotificationDevicesFirebaseTokenMutation = (options?: Partial<Options<DeleteNotificationDevicesFirebaseTokenData>>): UseMutationOptions<DeleteNotificationDevicesFirebaseTokenResponse, DeleteNotificationDevicesFirebaseTokenError, Options<DeleteNotificationDevicesFirebaseTokenData>> => {
    const mutationOptions: UseMutationOptions<DeleteNotificationDevicesFirebaseTokenResponse, DeleteNotificationDevicesFirebaseTokenError, Options<DeleteNotificationDevicesFirebaseTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteNotificationDevicesFirebaseToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Subscribe To Topic
 *
 * Subscribe to a topic.
 *
 * If the topic define restrictions, the user must be in the corresponding group or be a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postNotificationTopicsTopicIdSubscribeMutation = (options?: Partial<Options<PostNotificationTopicsTopicIdSubscribeData>>): UseMutationOptions<PostNotificationTopicsTopicIdSubscribeResponse, PostNotificationTopicsTopicIdSubscribeError, Options<PostNotificationTopicsTopicIdSubscribeData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationTopicsTopicIdSubscribeResponse, PostNotificationTopicsTopicIdSubscribeError, Options<PostNotificationTopicsTopicIdSubscribeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postNotificationTopicsTopicIdSubscribe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unsubscribe To Topic
 *
 * Unsubscribe to a topic
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postNotificationTopicsTopicIdUnsubscribeMutation = (options?: Partial<Options<PostNotificationTopicsTopicIdUnsubscribeData>>): UseMutationOptions<PostNotificationTopicsTopicIdUnsubscribeResponse, PostNotificationTopicsTopicIdUnsubscribeError, Options<PostNotificationTopicsTopicIdUnsubscribeData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationTopicsTopicIdUnsubscribeResponse, PostNotificationTopicsTopicIdUnsubscribeError, Options<PostNotificationTopicsTopicIdUnsubscribeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postNotificationTopicsTopicIdUnsubscribe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNotificationTopicsQueryKey = (options?: Options<GetNotificationTopicsData>) => createQueryKey('getNotificationTopics', options);

/**
 * Get Topics
 *
 * Return all available topics for a user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getNotificationTopicsOptions = (options?: Options<GetNotificationTopicsData>) => queryOptions<GetNotificationTopicsResponse, DefaultError, GetNotificationTopicsResponse, ReturnType<typeof getNotificationTopicsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getNotificationTopics({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getNotificationTopicsQueryKey(options)
});

/**
 * Send Notification
 *
 * Send a notification to a group.
 *
 * **Only admins can use this endpoint**
 */
export const postNotificationSendMutation = (options?: Partial<Options<PostNotificationSendData>>): UseMutationOptions<PostNotificationSendResponse, PostNotificationSendError, Options<PostNotificationSendData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationSendResponse, PostNotificationSendError, Options<PostNotificationSendData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postNotificationSend({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Send Test Notification
 *
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const postNotificationTestSendMutation = (options?: Partial<Options<PostNotificationTestSendData>>): UseMutationOptions<unknown, PostNotificationTestSendError, Options<PostNotificationTestSendData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostNotificationTestSendError, Options<PostNotificationTestSendData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postNotificationTestSend({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Send Test Future Notification
 *
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const postNotificationTestSendFutureMutation = (options?: Partial<Options<PostNotificationTestSendFutureData>>): UseMutationOptions<PostNotificationTestSendFutureResponse, PostNotificationTestSendFutureError, Options<PostNotificationTestSendFutureData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationTestSendFutureResponse, PostNotificationTestSendFutureError, Options<PostNotificationTestSendFutureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postNotificationTestSendFuture({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Send Test Notification Topic
 *
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const postNotificationTestSendTopicMutation = (options?: Partial<Options<PostNotificationTestSendTopicData>>): UseMutationOptions<PostNotificationTestSendTopicResponse, DefaultError, Options<PostNotificationTestSendTopicData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationTestSendTopicResponse, DefaultError, Options<PostNotificationTestSendTopicData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postNotificationTestSendTopic({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Send Test Future Notification Topic
 *
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const postNotificationTestSendTopicFutureMutation = (options?: Partial<Options<PostNotificationTestSendTopicFutureData>>): UseMutationOptions<PostNotificationTestSendTopicFutureResponse, DefaultError, Options<PostNotificationTestSendTopicFutureData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationTestSendTopicFutureResponse, DefaultError, Options<PostNotificationTestSendTopicFutureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postNotificationTestSendTopicFuture({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInformationQueryKey = (options?: Options<GetInformationData>) => createQueryKey('getInformation', options);

/**
 * Read Information
 *
 * Return information about Hyperion. This endpoint can be used to check if the API is up.
 */
export const getInformationOptions = (options?: Options<GetInformationData>) => queryOptions<GetInformationResponse, DefaultError, GetInformationResponse, ReturnType<typeof getInformationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getInformation({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getInformationQueryKey(options)
});

export const getPrivacyQueryKey = (options?: Options<GetPrivacyData>) => createQueryKey('getPrivacy', options);

/**
 * Read Privacy
 *
 * Return Hyperion privacy
 */
export const getPrivacyOptions = (options?: Options<GetPrivacyData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getPrivacyQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPrivacy({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPrivacyQueryKey(options)
});

export const getTermsAndConditionsQueryKey = (options?: Options<GetTermsAndConditionsData>) => createQueryKey('getTermsAndConditions', options);

/**
 * Read Terms And Conditions
 *
 * Return Hyperion terms and conditions pages
 */
export const getTermsAndConditionsOptions = (options?: Options<GetTermsAndConditionsData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getTermsAndConditionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTermsAndConditions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTermsAndConditionsQueryKey(options)
});

export const getMyeclpayTermsOfServiceQueryKey = (options?: Options<GetMyeclpayTermsOfServiceData>) => createQueryKey('getMyeclpayTermsOfService', options);

/**
 * Read Myeclpay Tos
 *
 * Return MyECLPay latest ToS
 */
export const getMyeclpayTermsOfServiceOptions = (options?: Options<GetMyeclpayTermsOfServiceData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getMyeclpayTermsOfServiceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayTermsOfService({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayTermsOfServiceQueryKey(options)
});

export const getSupportQueryKey = (options?: Options<GetSupportData>) => createQueryKey('getSupport', options);

/**
 * Read Support
 *
 * Return Hyperion support
 */
export const getSupportOptions = (options?: Options<GetSupportData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getSupportQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSupport({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSupportQueryKey(options)
});

export const getSecurityTxtQueryKey = (options?: Options<GetSecurityTxtData>) => createQueryKey('getSecurityTxt', options);

/**
 * Read Security Txt
 *
 * Return Hyperion security.txt file
 */
export const getSecurityTxtOptions = (options?: Options<GetSecurityTxtData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getSecurityTxtQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSecurityTxt({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSecurityTxtQueryKey(options)
});

export const getWellKnownSecurityTxtQueryKey = (options?: Options<GetWellKnownSecurityTxtData>) => createQueryKey('getWellKnownSecurityTxt', options);

/**
 * Read Wellknown Security Txt
 *
 * Return Hyperion security.txt file
 */
export const getWellKnownSecurityTxtOptions = (options?: Options<GetWellKnownSecurityTxtData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getWellKnownSecurityTxtQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getWellKnownSecurityTxt({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getWellKnownSecurityTxtQueryKey(options)
});

export const getRobotsTxtQueryKey = (options?: Options<GetRobotsTxtData>) => createQueryKey('getRobotsTxt', options);

/**
 * Read Robots Txt
 *
 * Return Hyperion robots.txt file
 */
export const getRobotsTxtOptions = (options?: Options<GetRobotsTxtData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getRobotsTxtQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRobotsTxt({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRobotsTxtQueryKey(options)
});

export const getStyleFileCssQueryKey = (options: Options<GetStyleFileCssData>) => createQueryKey('getStyleFileCss', options);

/**
 * Get Style File
 *
 * Return a style file from the assets folder
 */
export const getStyleFileCssOptions = (options: Options<GetStyleFileCssData>) => queryOptions<unknown, GetStyleFileCssError, unknown, ReturnType<typeof getStyleFileCssQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStyleFileCss({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStyleFileCssQueryKey(options)
});

export const getFaviconIcoQueryKey = (options?: Options<GetFaviconIcoData>) => createQueryKey('getFaviconIco', options);

/**
 * Get Favicon
 */
export const getFaviconIcoOptions = (options?: Options<GetFaviconIcoData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getFaviconIcoQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getFaviconIco({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getFaviconIcoQueryKey(options)
});

export const getModuleVisibilityQueryKey = (options?: Options<GetModuleVisibilityData>) => createQueryKey('getModuleVisibility', options);

/**
 * Get Module Visibility
 *
 * Get all existing module_visibility.
 *
 * **This endpoint is only usable by administrators**
 */
export const getModuleVisibilityOptions = (options?: Options<GetModuleVisibilityData>) => queryOptions<GetModuleVisibilityResponse, DefaultError, GetModuleVisibilityResponse, ReturnType<typeof getModuleVisibilityQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getModuleVisibility({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getModuleVisibilityQueryKey(options)
});

/**
 * Add Module Visibility
 *
 * Add a new group or account type to a module
 *
 * **This endpoint is only usable by administrators**
 */
export const postModuleVisibilityMutation = (options?: Partial<Options<PostModuleVisibilityData>>): UseMutationOptions<unknown, PostModuleVisibilityError, Options<PostModuleVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostModuleVisibilityError, Options<PostModuleVisibilityData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postModuleVisibility({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getModuleVisibilityMeQueryKey = (options?: Options<GetModuleVisibilityMeData>) => createQueryKey('getModuleVisibilityMe', options);

/**
 * Get User Modules Visibility
 *
 * Get group user accessible root
 *
 * **This endpoint is only usable by everyone**
 */
export const getModuleVisibilityMeOptions = (options?: Options<GetModuleVisibilityMeData>) => queryOptions<GetModuleVisibilityMeResponse, DefaultError, GetModuleVisibilityMeResponse, ReturnType<typeof getModuleVisibilityMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getModuleVisibilityMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getModuleVisibilityMeQueryKey(options)
});

/**
 * Delete Module Group Visibility
 */
export const deleteModuleVisibilityRootGroupsGroupIdMutation = (options?: Partial<Options<DeleteModuleVisibilityRootGroupsGroupIdData>>): UseMutationOptions<DeleteModuleVisibilityRootGroupsGroupIdResponse, DeleteModuleVisibilityRootGroupsGroupIdError, Options<DeleteModuleVisibilityRootGroupsGroupIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteModuleVisibilityRootGroupsGroupIdResponse, DeleteModuleVisibilityRootGroupsGroupIdError, Options<DeleteModuleVisibilityRootGroupsGroupIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteModuleVisibilityRootGroupsGroupId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Module Account Type Visibility
 */
export const deleteModuleVisibilityRootAccountTypesAccountTypeMutation = (options?: Partial<Options<DeleteModuleVisibilityRootAccountTypesAccountTypeData>>): UseMutationOptions<DeleteModuleVisibilityRootAccountTypesAccountTypeResponse, DeleteModuleVisibilityRootAccountTypesAccountTypeError, Options<DeleteModuleVisibilityRootAccountTypesAccountTypeData>> => {
    const mutationOptions: UseMutationOptions<DeleteModuleVisibilityRootAccountTypesAccountTypeResponse, DeleteModuleVisibilityRootAccountTypesAccountTypeError, Options<DeleteModuleVisibilityRootAccountTypesAccountTypeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteModuleVisibilityRootAccountTypesAccountType({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayBankAccountHolderQueryKey = (options?: Options<GetMyeclpayBankAccountHolderData>) => createQueryKey('getMyeclpayBankAccountHolder', options);

/**
 * Get Bank Account Holder
 *
 * Get the current bank account holder information.
 */
export const getMyeclpayBankAccountHolderOptions = (options?: Options<GetMyeclpayBankAccountHolderData>) => queryOptions<GetMyeclpayBankAccountHolderResponse, DefaultError, GetMyeclpayBankAccountHolderResponse, ReturnType<typeof getMyeclpayBankAccountHolderQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayBankAccountHolder({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayBankAccountHolderQueryKey(options)
});

/**
 * Set Bank Account Holder
 *
 * Set the bank account holder information.
 */
export const postMyeclpayBankAccountHolderMutation = (options?: Partial<Options<PostMyeclpayBankAccountHolderData>>): UseMutationOptions<PostMyeclpayBankAccountHolderResponse, PostMyeclpayBankAccountHolderError, Options<PostMyeclpayBankAccountHolderData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayBankAccountHolderResponse, PostMyeclpayBankAccountHolderError, Options<PostMyeclpayBankAccountHolderData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayBankAccountHolder({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayStructuresQueryKey = (options?: Options<GetMyeclpayStructuresData>) => createQueryKey('getMyeclpayStructures', options);

/**
 * Get Structures
 *
 * Get all structures.
 */
export const getMyeclpayStructuresOptions = (options?: Options<GetMyeclpayStructuresData>) => queryOptions<GetMyeclpayStructuresResponse, DefaultError, GetMyeclpayStructuresResponse, ReturnType<typeof getMyeclpayStructuresQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayStructures({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayStructuresQueryKey(options)
});

/**
 * Create Structure
 *
 * Create a new structure.
 *
 * A structure contains:
 * - a name
 * - an association membership id
 * - a manager user id
 * - a list of stores
 *
 * **The user must be an admin to use this endpoint**
 */
export const postMyeclpayStructuresMutation = (options?: Partial<Options<PostMyeclpayStructuresData>>): UseMutationOptions<PostMyeclpayStructuresResponse, PostMyeclpayStructuresError, Options<PostMyeclpayStructuresData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayStructuresResponse, PostMyeclpayStructuresError, Options<PostMyeclpayStructuresData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayStructures({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Structure
 *
 * Delete a structure. Only structures without stores can be deleted.
 *
 * **The user must be an admin to use this endpoint**
 */
export const deleteMyeclpayStructuresStructureIdMutation = (options?: Partial<Options<DeleteMyeclpayStructuresStructureIdData>>): UseMutationOptions<DeleteMyeclpayStructuresStructureIdResponse, DeleteMyeclpayStructuresStructureIdError, Options<DeleteMyeclpayStructuresStructureIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteMyeclpayStructuresStructureIdResponse, DeleteMyeclpayStructuresStructureIdError, Options<DeleteMyeclpayStructuresStructureIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMyeclpayStructuresStructureId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Structure
 *
 * Update a structure.
 *
 * **The user must be an admin to use this endpoint**
 */
export const patchMyeclpayStructuresStructureIdMutation = (options?: Partial<Options<PatchMyeclpayStructuresStructureIdData>>): UseMutationOptions<PatchMyeclpayStructuresStructureIdResponse, PatchMyeclpayStructuresStructureIdError, Options<PatchMyeclpayStructuresStructureIdData>> => {
    const mutationOptions: UseMutationOptions<PatchMyeclpayStructuresStructureIdResponse, PatchMyeclpayStructuresStructureIdError, Options<PatchMyeclpayStructuresStructureIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchMyeclpayStructuresStructureId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Init Transfer Structure Manager
 *
 * Initiate the transfer of a structure to a new manager. The current manager will receive an email with a link to confirm the transfer.
 * The link will only be valid for a limited time.
 *
 * **The user must be the manager for this structure**
 */
export const postMyeclpayStructuresStructureIdInitManagerTransferMutation = (options?: Partial<Options<PostMyeclpayStructuresStructureIdInitManagerTransferData>>): UseMutationOptions<unknown, PostMyeclpayStructuresStructureIdInitManagerTransferError, Options<PostMyeclpayStructuresStructureIdInitManagerTransferData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostMyeclpayStructuresStructureIdInitManagerTransferError, Options<PostMyeclpayStructuresStructureIdInitManagerTransferData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayStructuresStructureIdInitManagerTransfer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayStructuresConfirmManagerTransferQueryKey = (options: Options<GetMyeclpayStructuresConfirmManagerTransferData>) => createQueryKey('getMyeclpayStructuresConfirmManagerTransfer', options);

/**
 * Confirm Structure Manager Transfer
 *
 * Update a manager for an association
 *
 * The user must have initiated the update of the manager with `init_update_structure_manager`
 */
export const getMyeclpayStructuresConfirmManagerTransferOptions = (options: Options<GetMyeclpayStructuresConfirmManagerTransferData>) => queryOptions<unknown, GetMyeclpayStructuresConfirmManagerTransferError, unknown, ReturnType<typeof getMyeclpayStructuresConfirmManagerTransferQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayStructuresConfirmManagerTransfer({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayStructuresConfirmManagerTransferQueryKey(options)
});

/**
 * Create Store
 *
 * Create a store. The structure manager will be added as a seller for the store.
 *
 * Stores name should be unique, as an user need to be able to identify a store by its name.
 *
 * **The user must be the manager for this structure**
 */
export const postMyeclpayStructuresStructureIdStoresMutation = (options?: Partial<Options<PostMyeclpayStructuresStructureIdStoresData>>): UseMutationOptions<PostMyeclpayStructuresStructureIdStoresResponse, PostMyeclpayStructuresStructureIdStoresError, Options<PostMyeclpayStructuresStructureIdStoresData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayStructuresStructureIdStoresResponse, PostMyeclpayStructuresStructureIdStoresError, Options<PostMyeclpayStructuresStructureIdStoresData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayStructuresStructureIdStores({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayStoresStoreIdHistoryQueryKey = (options: Options<GetMyeclpayStoresStoreIdHistoryData>) => createQueryKey('getMyeclpayStoresStoreIdHistory', options);

/**
 * Get Store History
 *
 * Get all transactions for the store.
 *
 * **The user must be authorized to see the store history**
 */
export const getMyeclpayStoresStoreIdHistoryOptions = (options: Options<GetMyeclpayStoresStoreIdHistoryData>) => queryOptions<GetMyeclpayStoresStoreIdHistoryResponse, GetMyeclpayStoresStoreIdHistoryError, GetMyeclpayStoresStoreIdHistoryResponse, ReturnType<typeof getMyeclpayStoresStoreIdHistoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayStoresStoreIdHistory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayStoresStoreIdHistoryQueryKey(options)
});

export const getMyeclpayUsersMeStoresQueryKey = (options?: Options<GetMyeclpayUsersMeStoresData>) => createQueryKey('getMyeclpayUsersMeStores', options);

/**
 * Get User Stores
 *
 * Get all stores for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getMyeclpayUsersMeStoresOptions = (options?: Options<GetMyeclpayUsersMeStoresData>) => queryOptions<GetMyeclpayUsersMeStoresResponse, DefaultError, GetMyeclpayUsersMeStoresResponse, ReturnType<typeof getMyeclpayUsersMeStoresQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayUsersMeStores({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayUsersMeStoresQueryKey(options)
});

/**
 * Delete Store
 *
 * Delete a store. Only stores without transactions can be deleted.
 *
 * **The user must be the manager for this store's structure**
 */
export const deleteMyeclpayStoresStoreIdMutation = (options?: Partial<Options<DeleteMyeclpayStoresStoreIdData>>): UseMutationOptions<DeleteMyeclpayStoresStoreIdResponse, DeleteMyeclpayStoresStoreIdError, Options<DeleteMyeclpayStoresStoreIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteMyeclpayStoresStoreIdResponse, DeleteMyeclpayStoresStoreIdError, Options<DeleteMyeclpayStoresStoreIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMyeclpayStoresStoreId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Store
 *
 * Update a store
 *
 * **The user must be the manager for this store's structure**
 */
export const patchMyeclpayStoresStoreIdMutation = (options?: Partial<Options<PatchMyeclpayStoresStoreIdData>>): UseMutationOptions<PatchMyeclpayStoresStoreIdResponse, PatchMyeclpayStoresStoreIdError, Options<PatchMyeclpayStoresStoreIdData>> => {
    const mutationOptions: UseMutationOptions<PatchMyeclpayStoresStoreIdResponse, PatchMyeclpayStoresStoreIdError, Options<PatchMyeclpayStoresStoreIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchMyeclpayStoresStoreId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayStoresStoreIdSellersQueryKey = (options: Options<GetMyeclpayStoresStoreIdSellersData>) => createQueryKey('getMyeclpayStoresStoreIdSellers', options);

/**
 * Get Store Sellers
 *
 * Get all sellers for the given store.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const getMyeclpayStoresStoreIdSellersOptions = (options: Options<GetMyeclpayStoresStoreIdSellersData>) => queryOptions<GetMyeclpayStoresStoreIdSellersResponse, GetMyeclpayStoresStoreIdSellersError, GetMyeclpayStoresStoreIdSellersResponse, ReturnType<typeof getMyeclpayStoresStoreIdSellersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayStoresStoreIdSellers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayStoresStoreIdSellersQueryKey(options)
});

/**
 * Create Store Seller
 *
 * Create a store seller.
 *
 * This seller will have authorized permissions among:
 * - can_bank
 * - can_see_history
 * - can_cancel
 * - can_manage_sellers
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const postMyeclpayStoresStoreIdSellersMutation = (options?: Partial<Options<PostMyeclpayStoresStoreIdSellersData>>): UseMutationOptions<PostMyeclpayStoresStoreIdSellersResponse, PostMyeclpayStoresStoreIdSellersError, Options<PostMyeclpayStoresStoreIdSellersData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayStoresStoreIdSellersResponse, PostMyeclpayStoresStoreIdSellersError, Options<PostMyeclpayStoresStoreIdSellersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayStoresStoreIdSellers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Store Seller
 *
 * Delete a store seller.
 * The structure manager cannot be deleted as a seller.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const deleteMyeclpayStoresStoreIdSellersSellerUserIdMutation = (options?: Partial<Options<DeleteMyeclpayStoresStoreIdSellersSellerUserIdData>>): UseMutationOptions<DeleteMyeclpayStoresStoreIdSellersSellerUserIdResponse, DeleteMyeclpayStoresStoreIdSellersSellerUserIdError, Options<DeleteMyeclpayStoresStoreIdSellersSellerUserIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteMyeclpayStoresStoreIdSellersSellerUserIdResponse, DeleteMyeclpayStoresStoreIdSellersSellerUserIdError, Options<DeleteMyeclpayStoresStoreIdSellersSellerUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMyeclpayStoresStoreIdSellersSellerUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Store Seller
 *
 * Update a store seller permissions.
 * The structure manager cannot be updated as a seller.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const patchMyeclpayStoresStoreIdSellersSellerUserIdMutation = (options?: Partial<Options<PatchMyeclpayStoresStoreIdSellersSellerUserIdData>>): UseMutationOptions<PatchMyeclpayStoresStoreIdSellersSellerUserIdResponse, PatchMyeclpayStoresStoreIdSellersSellerUserIdError, Options<PatchMyeclpayStoresStoreIdSellersSellerUserIdData>> => {
    const mutationOptions: UseMutationOptions<PatchMyeclpayStoresStoreIdSellersSellerUserIdResponse, PatchMyeclpayStoresStoreIdSellersSellerUserIdError, Options<PatchMyeclpayStoresStoreIdSellersSellerUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchMyeclpayStoresStoreIdSellersSellerUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Register User
 *
 * Sign MyECL Pay TOS for the given user.
 *
 * The user will need to accept the latest TOS version to be able to use MyECL Pay.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postMyeclpayUsersMeRegisterMutation = (options?: Partial<Options<PostMyeclpayUsersMeRegisterData>>): UseMutationOptions<PostMyeclpayUsersMeRegisterResponse, DefaultError, Options<PostMyeclpayUsersMeRegisterData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayUsersMeRegisterResponse, DefaultError, Options<PostMyeclpayUsersMeRegisterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayUsersMeRegister({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayUsersMeTosQueryKey = (options?: Options<GetMyeclpayUsersMeTosData>) => createQueryKey('getMyeclpayUsersMeTos', options);

/**
 * Get User Tos
 *
 * Get the latest TOS version and the user signed TOS version.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getMyeclpayUsersMeTosOptions = (options?: Options<GetMyeclpayUsersMeTosData>) => queryOptions<GetMyeclpayUsersMeTosResponse, DefaultError, GetMyeclpayUsersMeTosResponse, ReturnType<typeof getMyeclpayUsersMeTosQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayUsersMeTos({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayUsersMeTosQueryKey(options)
});

/**
 * Sign Tos
 *
 * Sign MyECL Pay TOS for the given user.
 *
 * If the user is already registered in the MyECLPay system, this will update the TOS version.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postMyeclpayUsersMeTosMutation = (options?: Partial<Options<PostMyeclpayUsersMeTosData>>): UseMutationOptions<PostMyeclpayUsersMeTosResponse, PostMyeclpayUsersMeTosError, Options<PostMyeclpayUsersMeTosData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayUsersMeTosResponse, PostMyeclpayUsersMeTosError, Options<PostMyeclpayUsersMeTosData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayUsersMeTos({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayUsersMeWalletDevicesQueryKey = (options?: Options<GetMyeclpayUsersMeWalletDevicesData>) => createQueryKey('getMyeclpayUsersMeWalletDevices', options);

/**
 * Get User Devices
 *
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getMyeclpayUsersMeWalletDevicesOptions = (options?: Options<GetMyeclpayUsersMeWalletDevicesData>) => queryOptions<GetMyeclpayUsersMeWalletDevicesResponse, DefaultError, GetMyeclpayUsersMeWalletDevicesResponse, ReturnType<typeof getMyeclpayUsersMeWalletDevicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayUsersMeWalletDevices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayUsersMeWalletDevicesQueryKey(options)
});

/**
 * Create User Devices
 *
 * Create a new device for the user.
 * The user will need to activate it using a token sent by email.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postMyeclpayUsersMeWalletDevicesMutation = (options?: Partial<Options<PostMyeclpayUsersMeWalletDevicesData>>): UseMutationOptions<PostMyeclpayUsersMeWalletDevicesResponse, PostMyeclpayUsersMeWalletDevicesError, Options<PostMyeclpayUsersMeWalletDevicesData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayUsersMeWalletDevicesResponse, PostMyeclpayUsersMeWalletDevicesError, Options<PostMyeclpayUsersMeWalletDevicesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayUsersMeWalletDevices({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayUsersMeWalletDevicesWalletDeviceIdQueryKey = (options: Options<GetMyeclpayUsersMeWalletDevicesWalletDeviceIdData>) => createQueryKey('getMyeclpayUsersMeWalletDevicesWalletDeviceId', options);

/**
 * Get User Device
 *
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getMyeclpayUsersMeWalletDevicesWalletDeviceIdOptions = (options: Options<GetMyeclpayUsersMeWalletDevicesWalletDeviceIdData>) => queryOptions<GetMyeclpayUsersMeWalletDevicesWalletDeviceIdResponse, GetMyeclpayUsersMeWalletDevicesWalletDeviceIdError, GetMyeclpayUsersMeWalletDevicesWalletDeviceIdResponse, ReturnType<typeof getMyeclpayUsersMeWalletDevicesWalletDeviceIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayUsersMeWalletDevicesWalletDeviceId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayUsersMeWalletDevicesWalletDeviceIdQueryKey(options)
});

export const getMyeclpayUsersMeWalletQueryKey = (options?: Options<GetMyeclpayUsersMeWalletData>) => createQueryKey('getMyeclpayUsersMeWallet', options);

/**
 * Get User Wallet
 *
 * Get user wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getMyeclpayUsersMeWalletOptions = (options?: Options<GetMyeclpayUsersMeWalletData>) => queryOptions<GetMyeclpayUsersMeWalletResponse, DefaultError, GetMyeclpayUsersMeWalletResponse, ReturnType<typeof getMyeclpayUsersMeWalletQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayUsersMeWallet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayUsersMeWalletQueryKey(options)
});

export const getMyeclpayDevicesActivateQueryKey = (options: Options<GetMyeclpayDevicesActivateData>) => createQueryKey('getMyeclpayDevicesActivate', options);

/**
 * Activate User Device
 *
 * Activate a wallet device
 */
export const getMyeclpayDevicesActivateOptions = (options: Options<GetMyeclpayDevicesActivateData>) => queryOptions<unknown, GetMyeclpayDevicesActivateError, unknown, ReturnType<typeof getMyeclpayDevicesActivateQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayDevicesActivate({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayDevicesActivateQueryKey(options)
});

/**
 * Revoke User Devices
 *
 * Revoke a device for the user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeMutation = (options?: Partial<Options<PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeData>>): UseMutationOptions<PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeResponse, PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeError, Options<PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeResponse, PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeError, Options<PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayUsersMeWalletDevicesWalletDeviceIdRevoke({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayUsersMeWalletHistoryQueryKey = (options?: Options<GetMyeclpayUsersMeWalletHistoryData>) => createQueryKey('getMyeclpayUsersMeWalletHistory', options);

/**
 * Get User Wallet History
 *
 * Get all transactions for the current user's wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getMyeclpayUsersMeWalletHistoryOptions = (options?: Options<GetMyeclpayUsersMeWalletHistoryData>) => queryOptions<GetMyeclpayUsersMeWalletHistoryResponse, GetMyeclpayUsersMeWalletHistoryError, GetMyeclpayUsersMeWalletHistoryResponse, ReturnType<typeof getMyeclpayUsersMeWalletHistoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayUsersMeWalletHistory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayUsersMeWalletHistoryQueryKey(options)
});

/**
 * Init Ha Transfer
 *
 * Initiate HelloAsso transfer, return a payment url to complete the transaction on HelloAsso website.
 */
export const postMyeclpayTransferInitMutation = (options?: Partial<Options<PostMyeclpayTransferInitData>>): UseMutationOptions<PostMyeclpayTransferInitResponse, PostMyeclpayTransferInitError, Options<PostMyeclpayTransferInitData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayTransferInitResponse, PostMyeclpayTransferInitError, Options<PostMyeclpayTransferInitData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayTransferInit({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayTransferRedirectQueryKey = (options: Options<GetMyeclpayTransferRedirectData>) => createQueryKey('getMyeclpayTransferRedirect', options);

/**
 * Redirect From Ha Transfer
 *
 * HelloAsso checkout should be configured to redirect the user to:
 * - f"{settings.CLIENT_URL}myeclpay/transfer/redirect?url={redirect_url}"
 * Redirect the user to the provided redirect `url`. The parameters `checkoutIntentId`, `code`, `orderId` and `error` passed by HelloAsso will be added to the redirect URL.
 * The redirect `url` must be trusted by Hyperion in the dotenv.
 */
export const getMyeclpayTransferRedirectOptions = (options: Options<GetMyeclpayTransferRedirectData>) => queryOptions<GetMyeclpayTransferRedirectResponse, GetMyeclpayTransferRedirectError, GetMyeclpayTransferRedirectResponse, ReturnType<typeof getMyeclpayTransferRedirectQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayTransferRedirect({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayTransferRedirectQueryKey(options)
});

/**
 * Validate Can Scan Qrcode
 *
 * Validate if a given QR Code can be scanned by the seller.
 *
 * The QR Code should be valid, the seller should have the `can_bank` permission for this store,
 * and the debited wallet device should be active.
 *
 * If the store structure has an association membership, the user should be a member of the association.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postMyeclpayStoresStoreIdScanCheckMutation = (options?: Partial<Options<PostMyeclpayStoresStoreIdScanCheckData>>): UseMutationOptions<PostMyeclpayStoresStoreIdScanCheckResponse, PostMyeclpayStoresStoreIdScanCheckError, Options<PostMyeclpayStoresStoreIdScanCheckData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayStoresStoreIdScanCheckResponse, PostMyeclpayStoresStoreIdScanCheckError, Options<PostMyeclpayStoresStoreIdScanCheckData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayStoresStoreIdScanCheck({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Store Scan Qrcode
 *
 * Scan and bank a QR code for this store.
 *
 * `signature` should be a base64 encoded string
 * - signed using *ed25519*,
 * - where data are a `QRCodeContentData` object:
 * ```
 * {
 * id: UUID
 * tot: int
 * iat: datetime
 * key: UUID
 * }
 * ```
 *
 * The provided content is checked to ensure:
 * - the QR Code is not already used
 * - the QR Code is not expired
 * - the QR Code is intended to be scanned for a store `scan_info.store`
 * - the signature is valid and correspond to `wallet_device_id` public key
 * - the debited's wallet device is active
 * - the debited's Wallet balance greater than the QR Code total
 *
 * **The user must be authenticated to use this endpoint**
 * **The user must have the `can_bank` permission for this store**
 */
export const postMyeclpayStoresStoreIdScanMutation = (options?: Partial<Options<PostMyeclpayStoresStoreIdScanData>>): UseMutationOptions<unknown, PostMyeclpayStoresStoreIdScanError, Options<PostMyeclpayStoresStoreIdScanData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostMyeclpayStoresStoreIdScanError, Options<PostMyeclpayStoresStoreIdScanData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayStoresStoreIdScan({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Refund Transaction
 *
 * Refund a transaction. Only transactions made in the last 30 days can be refunded.
 *
 * Currently transactions between users are forbidden and can thus not be refunded.
 *
 * To cancel a transaction made in the last 30 seconds, the endpoint `/myeclpay/transactions/{transaction_id}/cancel` should be used.
 *
 * **The user must either be the credited user or a seller with cancel permissions of the credited store of the transaction**
 */
export const postMyeclpayTransactionsTransactionIdRefundMutation = (options?: Partial<Options<PostMyeclpayTransactionsTransactionIdRefundData>>): UseMutationOptions<PostMyeclpayTransactionsTransactionIdRefundResponse, PostMyeclpayTransactionsTransactionIdRefundError, Options<PostMyeclpayTransactionsTransactionIdRefundData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayTransactionsTransactionIdRefundResponse, PostMyeclpayTransactionsTransactionIdRefundError, Options<PostMyeclpayTransactionsTransactionIdRefundData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayTransactionsTransactionIdRefund({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cancel Transaction
 *
 * Cancel a transaction.
 * A transaction can be canceled in the first 30 seconds after it has been created.
 *
 * To refund an older transaction, use the `/myeclpay/transactions/{transaction_id}/refund` endpoint.
 *
 * **The user must either be the credited user or the seller of the transaction**
 */
export const postMyeclpayTransactionsTransactionIdCancelMutation = (options?: Partial<Options<PostMyeclpayTransactionsTransactionIdCancelData>>): UseMutationOptions<PostMyeclpayTransactionsTransactionIdCancelResponse, PostMyeclpayTransactionsTransactionIdCancelError, Options<PostMyeclpayTransactionsTransactionIdCancelData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayTransactionsTransactionIdCancelResponse, PostMyeclpayTransactionsTransactionIdCancelError, Options<PostMyeclpayTransactionsTransactionIdCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayTransactionsTransactionIdCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayInvoicesQueryKey = (options?: Options<GetMyeclpayInvoicesData>) => createQueryKey('getMyeclpayInvoices', options);

/**
 * Get Invoices
 *
 * Get all invoices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getMyeclpayInvoicesOptions = (options?: Options<GetMyeclpayInvoicesData>) => queryOptions<GetMyeclpayInvoicesResponse, GetMyeclpayInvoicesError, GetMyeclpayInvoicesResponse, ReturnType<typeof getMyeclpayInvoicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayInvoices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayInvoicesQueryKey(options)
});

export const getMyeclpayInvoicesInfiniteQueryKey = (options?: Options<GetMyeclpayInvoicesData>): QueryKey<Options<GetMyeclpayInvoicesData>> => createQueryKey('getMyeclpayInvoices', options, true);

/**
 * Get Invoices
 *
 * Get all invoices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getMyeclpayInvoicesInfiniteOptions = (options?: Options<GetMyeclpayInvoicesData>) => infiniteQueryOptions<GetMyeclpayInvoicesResponse, GetMyeclpayInvoicesError, InfiniteData<GetMyeclpayInvoicesResponse>, QueryKey<Options<GetMyeclpayInvoicesData>>, number | null | Pick<QueryKey<Options<GetMyeclpayInvoicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetMyeclpayInvoicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getMyeclpayInvoices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayInvoicesInfiniteQueryKey(options)
});

export const getMyeclpayInvoicesStructuresStructureIdQueryKey = (options: Options<GetMyeclpayInvoicesStructuresStructureIdData>) => createQueryKey('getMyeclpayInvoicesStructuresStructureId', options);

/**
 * Get Structure Invoices
 *
 * Get all invoices.
 *
 * **The user must be the structure manager**
 */
export const getMyeclpayInvoicesStructuresStructureIdOptions = (options: Options<GetMyeclpayInvoicesStructuresStructureIdData>) => queryOptions<GetMyeclpayInvoicesStructuresStructureIdResponse, GetMyeclpayInvoicesStructuresStructureIdError, GetMyeclpayInvoicesStructuresStructureIdResponse, ReturnType<typeof getMyeclpayInvoicesStructuresStructureIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayInvoicesStructuresStructureId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayInvoicesStructuresStructureIdQueryKey(options)
});

export const getMyeclpayInvoicesStructuresStructureIdInfiniteQueryKey = (options: Options<GetMyeclpayInvoicesStructuresStructureIdData>): QueryKey<Options<GetMyeclpayInvoicesStructuresStructureIdData>> => createQueryKey('getMyeclpayInvoicesStructuresStructureId', options, true);

/**
 * Get Structure Invoices
 *
 * Get all invoices.
 *
 * **The user must be the structure manager**
 */
export const getMyeclpayInvoicesStructuresStructureIdInfiniteOptions = (options: Options<GetMyeclpayInvoicesStructuresStructureIdData>) => infiniteQueryOptions<GetMyeclpayInvoicesStructuresStructureIdResponse, GetMyeclpayInvoicesStructuresStructureIdError, InfiniteData<GetMyeclpayInvoicesStructuresStructureIdResponse>, QueryKey<Options<GetMyeclpayInvoicesStructuresStructureIdData>>, number | null | Pick<QueryKey<Options<GetMyeclpayInvoicesStructuresStructureIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetMyeclpayInvoicesStructuresStructureIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getMyeclpayInvoicesStructuresStructureId({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayInvoicesStructuresStructureIdInfiniteQueryKey(options)
});

/**
 * Create Structure Invoice
 *
 * Create an invoice for a structure.
 *
 * **The user must be the bank account holder**
 */
export const postMyeclpayInvoicesStructuresStructureIdMutation = (options?: Partial<Options<PostMyeclpayInvoicesStructuresStructureIdData>>): UseMutationOptions<PostMyeclpayInvoicesStructuresStructureIdResponse, PostMyeclpayInvoicesStructuresStructureIdError, Options<PostMyeclpayInvoicesStructuresStructureIdData>> => {
    const mutationOptions: UseMutationOptions<PostMyeclpayInvoicesStructuresStructureIdResponse, PostMyeclpayInvoicesStructuresStructureIdError, Options<PostMyeclpayInvoicesStructuresStructureIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMyeclpayInvoicesStructuresStructureId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Structure Invoice
 *
 * Delete a structure invoice.
 *
 * **The user must be the bank account holder**
 */
export const deleteMyeclpayInvoicesInvoiceIdMutation = (options?: Partial<Options<DeleteMyeclpayInvoicesInvoiceIdData>>): UseMutationOptions<DeleteMyeclpayInvoicesInvoiceIdResponse, DeleteMyeclpayInvoicesInvoiceIdError, Options<DeleteMyeclpayInvoicesInvoiceIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteMyeclpayInvoicesInvoiceIdResponse, DeleteMyeclpayInvoicesInvoiceIdError, Options<DeleteMyeclpayInvoicesInvoiceIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMyeclpayInvoicesInvoiceId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayInvoicesInvoiceIdQueryKey = (options: Options<GetMyeclpayInvoicesInvoiceIdData>) => createQueryKey('getMyeclpayInvoicesInvoiceId', options);

/**
 * Download Invoice
 */
export const getMyeclpayInvoicesInvoiceIdOptions = (options: Options<GetMyeclpayInvoicesInvoiceIdData>) => queryOptions<unknown, GetMyeclpayInvoicesInvoiceIdError, unknown, ReturnType<typeof getMyeclpayInvoicesInvoiceIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayInvoicesInvoiceId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayInvoicesInvoiceIdQueryKey(options)
});

/**
 * Update Invoice Paid Status
 *
 * Update the paid status of a structure invoice.
 *
 * **The user must be the bank account holder**
 */
export const patchMyeclpayInvoicesInvoiceIdPaidMutation = (options?: Partial<Options<PatchMyeclpayInvoicesInvoiceIdPaidData>>): UseMutationOptions<PatchMyeclpayInvoicesInvoiceIdPaidResponse, PatchMyeclpayInvoicesInvoiceIdPaidError, Options<PatchMyeclpayInvoicesInvoiceIdPaidData>> => {
    const mutationOptions: UseMutationOptions<PatchMyeclpayInvoicesInvoiceIdPaidResponse, PatchMyeclpayInvoicesInvoiceIdPaidError, Options<PatchMyeclpayInvoicesInvoiceIdPaidData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchMyeclpayInvoicesInvoiceIdPaid({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Aknowledge Invoice As Received
 *
 * Update the received status of a structure invoice.
 *
 * **The user must be the structure manager**
 */
export const patchMyeclpayInvoicesInvoiceIdReceivedMutation = (options?: Partial<Options<PatchMyeclpayInvoicesInvoiceIdReceivedData>>): UseMutationOptions<PatchMyeclpayInvoicesInvoiceIdReceivedResponse, PatchMyeclpayInvoicesInvoiceIdReceivedError, Options<PatchMyeclpayInvoicesInvoiceIdReceivedData>> => {
    const mutationOptions: UseMutationOptions<PatchMyeclpayInvoicesInvoiceIdReceivedResponse, PatchMyeclpayInvoicesInvoiceIdReceivedError, Options<PatchMyeclpayInvoicesInvoiceIdReceivedData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchMyeclpayInvoicesInvoiceIdReceived({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMyeclpayIntegrityCheckQueryKey = (options: Options<GetMyeclpayIntegrityCheckData>) => createQueryKey('getMyeclpayIntegrityCheck', options);

/**
 * Get Data For Integrity Check
 *
 * Send all the MyECL Pay data for integrity check.
 * Data includes:
 * - Wallets deducted of the last 30 seconds transactions
 * - Transactions with at least 30 seconds delay
 * - Transfers
 * - Refunds
 *
 * **The header must contain the MYECLPAY_DATA_VERIFIER_ACCESS_TOKEN defined in the settings in the `x-data-verifier-token` field**
 */
export const getMyeclpayIntegrityCheckOptions = (options: Options<GetMyeclpayIntegrityCheckData>) => queryOptions<GetMyeclpayIntegrityCheckResponse, GetMyeclpayIntegrityCheckError, GetMyeclpayIntegrityCheckResponse, ReturnType<typeof getMyeclpayIntegrityCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMyeclpayIntegrityCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMyeclpayIntegrityCheckQueryKey(options)
});

/**
 * Login For Access Token
 *
 * Ask for a JWT access token using oauth password flow.
 *
 * *username* and *password* must be provided
 *
 * Note: the request body needs to use **form-data** and not json.
 */
export const postAuthSimpleTokenMutation = (options?: Partial<Options<PostAuthSimpleTokenData>>): UseMutationOptions<PostAuthSimpleTokenResponse, PostAuthSimpleTokenError, Options<PostAuthSimpleTokenData>> => {
    const mutationOptions: UseMutationOptions<PostAuthSimpleTokenResponse, PostAuthSimpleTokenError, Options<PostAuthSimpleTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAuthSimpleToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuthAuthorizeQueryKey = (options: Options<GetAuthAuthorizeData>) => createQueryKey('getAuthAuthorize', options);

/**
 * Get Authorize Page
 *
 * This endpoint is the one the user is redirected to when they begin the Oauth or Openid connect (*oidc*) *Authorization code* process.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const getAuthAuthorizeOptions = (options: Options<GetAuthAuthorizeData>) => queryOptions<GetAuthAuthorizeResponse, GetAuthAuthorizeError, GetAuthAuthorizeResponse, ReturnType<typeof getAuthAuthorizeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAuthAuthorize({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAuthAuthorizeQueryKey(options)
});

/**
 * Post Authorize Page
 *
 * This endpoint is the one the user is redirected to when they begin the OAuth or Openid connect (*oidc*) *Authorization code* process with or without PKCE.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const postAuthAuthorizeMutation = (options?: Partial<Options<PostAuthAuthorizeData>>): UseMutationOptions<PostAuthAuthorizeResponse, PostAuthAuthorizeError, Options<PostAuthAuthorizeData>> => {
    const mutationOptions: UseMutationOptions<PostAuthAuthorizeResponse, PostAuthAuthorizeError, Options<PostAuthAuthorizeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAuthAuthorize({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Authorize Validation
 *
 * Part 1 of the authorization code grant.
 *
 * Parameters must be `application/x-www-form-urlencoded` and includes:
 *
 * * parameters for OAuth and Openid connect:
 * * `response_type`: must be `code`
 * * `client_id`: client identifier, needs to be registered in the server known_clients
 * * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization.
 * * `scope`: optional for OAuth, must contain "openid" for oidc. List of scope the client want to get access to.
 * * `state`: recommended. Opaque value used to maintain state between the request and the callback.
 *
 * * additional parameters for Openid connect:
 * * `nonce`: oidc only. A string value used to associate a client session with an ID Token, and to mitigate replay attacks.
 *
 * * additional parameters for PKCE (see specs on https://datatracker.ietf.org/doc/html/rfc7636/):
 * * `code_challenge`: PKCE only
 * * `code_challenge_method`: PKCE only
 *
 *
 * * parameters that allows to authenticate the user and know which scopes he grants access to.
 * * `email`
 * * `password`
 *
 * References:
 * * https://www.rfc-editor.org/rfc/rfc6749.html#section-4.1.2
 * * https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
 */
export const postAuthAuthorizationFlowAuthorizeValidationMutation = (options?: Partial<Options<PostAuthAuthorizationFlowAuthorizeValidationData>>): UseMutationOptions<unknown, PostAuthAuthorizationFlowAuthorizeValidationError, Options<PostAuthAuthorizationFlowAuthorizeValidationData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostAuthAuthorizationFlowAuthorizeValidationError, Options<PostAuthAuthorizationFlowAuthorizeValidationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAuthAuthorizationFlowAuthorizeValidation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Token
 *
 * Part 2 of the authorization code grant.
 * The client exchange its authorization code for an access token. The endpoint supports OAuth and Openid connect, with or without PKCE.
 *
 * Parameters must be `application/x-www-form-urlencoded` and include:
 *
 * * parameters for OAuth and Openid connect:
 * * `grant_type`: must be `authorization_code` or `refresh_token`
 * * `code`: the authorization code received from the authorization endpoint
 * * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization. If provided, must be the same as previously registered in the `redirect_uri` field of the client.
 *
 * * Client credentials
 * The client must send either:
 * the client id and secret in the authorization header or with client_id and client_secret parameters
 *
 * * additional parameters for PKCE:
 * * `code_verifier`: PKCE only, allows to verify the previous code_challenge
 *
 * https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3
 * https://openid.net/specs/openid-connect-core-1_0.html#TokenRequestValidation
 */
export const postAuthTokenMutation = (options?: Partial<Options<PostAuthTokenData>>): UseMutationOptions<PostAuthTokenResponse, PostAuthTokenError, Options<PostAuthTokenData>> => {
    const mutationOptions: UseMutationOptions<PostAuthTokenResponse, PostAuthTokenError, Options<PostAuthTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAuthToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Introspect
 *
 * Some clients requires an endpoint to check if an access token or a refresh token is valid.
 * This endpoint should not be publicly accessible, and is thus restricted to some AuthClient.
 *
 * * parameters:
 * * `token`: the token to introspect
 * * `token_type_hint`: may be `access_token` or `refresh_token`, we currently do not use this hint as we are able to differentiate access and refresh tokens
 *
 * * Client credentials
 * The client must send either:
 * the client id and secret in the authorization header or with client_id and client_secret parameters
 *
 * Reference:
 * https://www.oauth.com/oauth2-servers/token-introspection-endpoint/
 * https://datatracker.ietf.org/doc/html/rfc7662
 */
export const postAuthIntrospectMutation = (options?: Partial<Options<PostAuthIntrospectData>>): UseMutationOptions<PostAuthIntrospectResponse, PostAuthIntrospectError, Options<PostAuthIntrospectData>> => {
    const mutationOptions: UseMutationOptions<PostAuthIntrospectResponse, PostAuthIntrospectError, Options<PostAuthIntrospectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postAuthIntrospect({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuthUserinfoQueryKey = (options?: Options<GetAuthUserinfoData>) => createQueryKey('getAuthUserinfo', options);

/**
 * Auth Get Userinfo
 *
 * Openid connect specify an endpoint the client can use to get information about the user.
 * The oidc client will provide the access_token it got previously in the request.
 *
 * The information expected depends on the client and may include the user identifier, name, email, phone...
 * See the reference for possible claims. See the client documentation and implementation to know what it needs and can receive.
 * The sub (subject) Claim MUST always be returned in the UserInfo Response.
 *
 * The client can ask for specific information using scopes and claims. See the reference for more information.
 * This procedure is not implemented in Hyperion as we can customize the response using auth_client class
 *
 * Reference:
 * https://openid.net/specs/openid-connect-core-1_0.html#UserInfo
 */
export const getAuthUserinfoOptions = (options?: Options<GetAuthUserinfoData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getAuthUserinfoQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAuthUserinfo({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAuthUserinfoQueryKey(options)
});

export const getOidcAuthorizationFlowJwksUriQueryKey = (options?: Options<GetOidcAuthorizationFlowJwksUriData>) => createQueryKey('getOidcAuthorizationFlowJwksUri', options);

/**
 * Jwks Uri
 */
export const getOidcAuthorizationFlowJwksUriOptions = (options?: Options<GetOidcAuthorizationFlowJwksUriData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getOidcAuthorizationFlowJwksUriQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getOidcAuthorizationFlowJwksUri({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getOidcAuthorizationFlowJwksUriQueryKey(options)
});

export const getWellKnownOauthAuthorizationServerQueryKey = (options?: Options<GetWellKnownOauthAuthorizationServerData>) => createQueryKey('getWellKnownOauthAuthorizationServer', options);

/**
 * Oauth Configuration
 */
export const getWellKnownOauthAuthorizationServerOptions = (options?: Options<GetWellKnownOauthAuthorizationServerData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getWellKnownOauthAuthorizationServerQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getWellKnownOauthAuthorizationServer({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getWellKnownOauthAuthorizationServerQueryKey(options)
});

export const getWellKnownOpenidConfigurationQueryKey = (options?: Options<GetWellKnownOpenidConfigurationData>) => createQueryKey('getWellKnownOpenidConfiguration', options);

/**
 * Oidc Configuration
 */
export const getWellKnownOpenidConfigurationOptions = (options?: Options<GetWellKnownOpenidConfigurationData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getWellKnownOpenidConfigurationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getWellKnownOpenidConfiguration({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getWellKnownOpenidConfigurationQueryKey(options)
});

export const getUsersQueryKey = (options?: Options<GetUsersData>) => createQueryKey('getUsers', options);

/**
 * Read Users
 *
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export const getUsersOptions = (options?: Options<GetUsersData>) => queryOptions<GetUsersResponse, GetUsersError, GetUsersResponse, ReturnType<typeof getUsersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersQueryKey(options)
});

export const getUsersCountQueryKey = (options?: Options<GetUsersCountData>) => createQueryKey('getUsersCount', options);

/**
 * Count Users
 *
 * Return the number of users in the database
 *
 * **This endpoint is only usable by administrators**
 */
export const getUsersCountOptions = (options?: Options<GetUsersCountData>) => queryOptions<GetUsersCountResponse, DefaultError, GetUsersCountResponse, ReturnType<typeof getUsersCountQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersCount({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersCountQueryKey(options)
});

export const getUsersSearchQueryKey = (options: Options<GetUsersSearchData>) => createQueryKey('getUsersSearch', options);

/**
 * Search Users
 *
 * Search for a user using Jaro_Winkler distance algorithm.
 * The `query` will be compared against users name, firstname and nickname.
 * Assume that `query` is the beginning of a name, so we can capitalize words to improve results.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getUsersSearchOptions = (options: Options<GetUsersSearchData>) => queryOptions<GetUsersSearchResponse, GetUsersSearchError, GetUsersSearchResponse, ReturnType<typeof getUsersSearchQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersSearch({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersSearchQueryKey(options)
});

export const getUsersAccountTypesQueryKey = (options?: Options<GetUsersAccountTypesData>) => createQueryKey('getUsersAccountTypes', options);

/**
 * Get Account Types
 *
 * Return all account types hardcoded in the system
 */
export const getUsersAccountTypesOptions = (options?: Options<GetUsersAccountTypesData>) => queryOptions<GetUsersAccountTypesResponse, DefaultError, GetUsersAccountTypesResponse, ReturnType<typeof getUsersAccountTypesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersAccountTypes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersAccountTypesQueryKey(options)
});

export const getUsersMeQueryKey = (options?: Options<GetUsersMeData>) => createQueryKey('getUsersMe', options);

/**
 * Read Current User
 *
 * Return `CoreUser` representation of current user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getUsersMeOptions = (options?: Options<GetUsersMeData>) => queryOptions<GetUsersMeResponse, DefaultError, GetUsersMeResponse, ReturnType<typeof getUsersMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersMeQueryKey(options)
});

/**
 * Update Current User
 *
 * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **The user must be authenticated to use this endpoint**
 */
export const patchUsersMeMutation = (options?: Partial<Options<PatchUsersMeData>>): UseMutationOptions<PatchUsersMeResponse, PatchUsersMeError, Options<PatchUsersMeData>> => {
    const mutationOptions: UseMutationOptions<PatchUsersMeResponse, PatchUsersMeError, Options<PatchUsersMeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchUsersMe({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create User By User
 *
 * Start the user account creation process. The user will be sent an email with a link to activate his account.
 * > The received token needs to be sent to the `/users/activate` endpoint to activate the account.
 *
 * If the **password** is not provided, it will be required during the activation process. Don't submit a password if you are creating an account for someone else.
 *
 * When creating **student** or **staff** account a valid ECL email is required.
 * Only admin users can create other **account types**, contact CLAIR for more information.
 */
export const postUsersCreateMutation = (options?: Partial<Options<PostUsersCreateData>>): UseMutationOptions<PostUsersCreateResponse, PostUsersCreateError, Options<PostUsersCreateData>> => {
    const mutationOptions: UseMutationOptions<PostUsersCreateResponse, PostUsersCreateError, Options<PostUsersCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch Create Users
 *
 * Batch user account creation process. All users will be sent an email with a link to activate their account.
 * > The received token needs to be send to `/users/activate` endpoint to activate the account.
 *
 * Even for creating **student** or **staff** account a valid ECL email is not required but should preferably be used.
 *
 * The endpoint return a dictionary of unsuccessful user creation: `{email: error message}`.
 *
 * **This endpoint is only usable by administrators**
 */
export const postUsersBatchCreationMutation = (options?: Partial<Options<PostUsersBatchCreationData>>): UseMutationOptions<PostUsersBatchCreationResponse, PostUsersBatchCreationError, Options<PostUsersBatchCreationData>> => {
    const mutationOptions: UseMutationOptions<PostUsersBatchCreationResponse, PostUsersBatchCreationError, Options<PostUsersBatchCreationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersBatchCreation({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Activate User
 *
 * Activate the previously created account.
 *
 * **token**: the activation token sent by email to the user
 *
 * **password**: user password, required if it was not provided previously
 */
export const postUsersActivateMutation = (options?: Partial<Options<PostUsersActivateData>>): UseMutationOptions<PostUsersActivateResponse, PostUsersActivateError, Options<PostUsersActivateData>> => {
    const mutationOptions: UseMutationOptions<PostUsersActivateResponse, PostUsersActivateError, Options<PostUsersActivateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersActivate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Init S3 For Users
 *
 * This endpoint is used to initialize the S3 bucket for users.
 * It will create a file for each existing user in the S3 bucket.
 * It should be used only once, when the S3 bucket is created.
 */
export const postUsersS3InitMutation = (options?: Partial<Options<PostUsersS3InitData>>): UseMutationOptions<unknown, DefaultError, Options<PostUsersS3InitData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PostUsersS3InitData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersS3Init({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Make Admin
 *
 * This endpoint is only usable if the database contains exactly one user.
 * It will add this user to the `admin` group.
 */
export const postUsersMakeAdminMutation = (options?: Partial<Options<PostUsersMakeAdminData>>): UseMutationOptions<PostUsersMakeAdminResponse, DefaultError, Options<PostUsersMakeAdminData>> => {
    const mutationOptions: UseMutationOptions<PostUsersMakeAdminResponse, DefaultError, Options<PostUsersMakeAdminData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersMakeAdmin({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Recover User
 *
 * Allow a user to start a password reset process.
 *
 * If the provided **email** corresponds to an existing account, a password reset token will be sent.
 * Using this token, the password can be changed with `/users/reset-password` endpoint
 */
export const postUsersRecoverMutation = (options?: Partial<Options<PostUsersRecoverData>>): UseMutationOptions<PostUsersRecoverResponse, PostUsersRecoverError, Options<PostUsersRecoverData>> => {
    const mutationOptions: UseMutationOptions<PostUsersRecoverResponse, PostUsersRecoverError, Options<PostUsersRecoverData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersRecover({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset Password
 *
 * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
 */
export const postUsersResetPasswordMutation = (options?: Partial<Options<PostUsersResetPasswordData>>): UseMutationOptions<PostUsersResetPasswordResponse, PostUsersResetPasswordError, Options<PostUsersResetPasswordData>> => {
    const mutationOptions: UseMutationOptions<PostUsersResetPasswordResponse, PostUsersResetPasswordError, Options<PostUsersResetPasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersResetPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Migrate Mail
 *
 * This endpoint will send a confirmation code to the user's new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
 */
export const postUsersMigrateMailMutation = (options?: Partial<Options<PostUsersMigrateMailData>>): UseMutationOptions<PostUsersMigrateMailResponse, PostUsersMigrateMailError, Options<PostUsersMigrateMailData>> => {
    const mutationOptions: UseMutationOptions<PostUsersMigrateMailResponse, PostUsersMigrateMailError, Options<PostUsersMigrateMailData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersMigrateMail({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersMigrateMailConfirmQueryKey = (options: Options<GetUsersMigrateMailConfirmData>) => createQueryKey('getUsersMigrateMailConfirm', options);

/**
 * Migrate Mail Confirm
 *
 * This endpoint will updates the user new email address.
 * The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
 */
export const getUsersMigrateMailConfirmOptions = (options: Options<GetUsersMigrateMailConfirmData>) => queryOptions<unknown, GetUsersMigrateMailConfirmError, unknown, ReturnType<typeof getUsersMigrateMailConfirmQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersMigrateMailConfirm({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersMigrateMailConfirmQueryKey(options)
});

/**
 * Change Password
 *
 * Change a user password.
 *
 * This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
 */
export const postUsersChangePasswordMutation = (options?: Partial<Options<PostUsersChangePasswordData>>): UseMutationOptions<PostUsersChangePasswordResponse, PostUsersChangePasswordError, Options<PostUsersChangePasswordData>> => {
    const mutationOptions: UseMutationOptions<PostUsersChangePasswordResponse, PostUsersChangePasswordError, Options<PostUsersChangePasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersChangePassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersUserIdQueryKey = (options: Options<GetUsersUserIdData>) => createQueryKey('getUsersUserId', options);

/**
 * Read User
 *
 * Return `CoreUser` representation of user with id `user_id`
 *
 * **The user must be authenticated to use this endpoint**
 */
export const getUsersUserIdOptions = (options: Options<GetUsersUserIdData>) => queryOptions<GetUsersUserIdResponse, GetUsersUserIdError, GetUsersUserIdResponse, ReturnType<typeof getUsersUserIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersUserId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersUserIdQueryKey(options)
});

/**
 * Update User
 *
 * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **This endpoint is only usable by administrators**
 */
export const patchUsersUserIdMutation = (options?: Partial<Options<PatchUsersUserIdData>>): UseMutationOptions<PatchUsersUserIdResponse, PatchUsersUserIdError, Options<PatchUsersUserIdData>> => {
    const mutationOptions: UseMutationOptions<PatchUsersUserIdResponse, PatchUsersUserIdError, Options<PatchUsersUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchUsersUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User
 *
 * This endpoint will ask administrators to process to the user deletion.
 * This manual verification is needed to prevent data from being deleting for other users
 */
export const postUsersMeAskDeletionMutation = (options?: Partial<Options<PostUsersMeAskDeletionData>>): UseMutationOptions<PostUsersMeAskDeletionResponse, DefaultError, Options<PostUsersMeAskDeletionData>> => {
    const mutationOptions: UseMutationOptions<PostUsersMeAskDeletionResponse, DefaultError, Options<PostUsersMeAskDeletionData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersMeAskDeletion({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Merge Users
 *
 * Fusion two users into one. The first user will be deleted and its data will be transferred to the second user.
 */
export const postUsersMergeMutation = (options?: Partial<Options<PostUsersMergeData>>): UseMutationOptions<PostUsersMergeResponse, PostUsersMergeError, Options<PostUsersMergeData>> => {
    const mutationOptions: UseMutationOptions<PostUsersMergeResponse, PostUsersMergeError, Options<PostUsersMergeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersMerge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersMeProfilePictureQueryKey = (options?: Options<GetUsersMeProfilePictureData>) => createQueryKey('getUsersMeProfilePicture', options);

/**
 * Read Own Profile Picture
 *
 * Get the profile picture of the authenticated user.
 */
export const getUsersMeProfilePictureOptions = (options?: Options<GetUsersMeProfilePictureData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getUsersMeProfilePictureQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersMeProfilePicture({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersMeProfilePictureQueryKey(options)
});

/**
 * Create Current User Profile Picture
 *
 * Upload a profile picture for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const postUsersMeProfilePictureMutation = (options?: Partial<Options<PostUsersMeProfilePictureData>>): UseMutationOptions<PostUsersMeProfilePictureResponse, PostUsersMeProfilePictureError, Options<PostUsersMeProfilePictureData>> => {
    const mutationOptions: UseMutationOptions<PostUsersMeProfilePictureResponse, PostUsersMeProfilePictureError, Options<PostUsersMeProfilePictureData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postUsersMeProfilePicture({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersUserIdProfilePictureQueryKey = (options: Options<GetUsersUserIdProfilePictureData>) => createQueryKey('getUsersUserIdProfilePicture', options);

/**
 * Read User Profile Picture
 *
 * Get the profile picture of an user.
 *
 * Unauthenticated users can use this endpoint (needed for some OIDC services)
 */
export const getUsersUserIdProfilePictureOptions = (options: Options<GetUsersUserIdProfilePictureData>) => queryOptions<unknown, GetUsersUserIdProfilePictureError, unknown, ReturnType<typeof getUsersUserIdProfilePictureQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersUserIdProfilePicture({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersUserIdProfilePictureQueryKey(options)
});

export const getGoogleApiOauth2CallbackQueryKey = (options?: Options<GetGoogleApiOauth2CallbackData>) => createQueryKey('getGoogleApiOauth2Callback', options);

/**
 * Google Api Callback
 */
export const getGoogleApiOauth2CallbackOptions = (options?: Options<GetGoogleApiOauth2CallbackData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getGoogleApiOauth2CallbackQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getGoogleApiOauth2Callback({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getGoogleApiOauth2CallbackQueryKey(options)
});

export const getSchoolsQueryKey = (options?: Options<GetSchoolsData>) => createQueryKey('getSchools', options);

/**
 * Read Schools
 *
 * Return all schools from database as a list of dictionaries
 */
export const getSchoolsOptions = (options?: Options<GetSchoolsData>) => queryOptions<GetSchoolsResponse, DefaultError, GetSchoolsResponse, ReturnType<typeof getSchoolsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSchools({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSchoolsQueryKey(options)
});

/**
 * Create School
 *
 * Create a new school and add users to it based on the email regex.
 *
 * **This endpoint is only usable by administrators**
 */
export const postSchoolsMutation = (options?: Partial<Options<PostSchoolsData>>): UseMutationOptions<PostSchoolsResponse, PostSchoolsError, Options<PostSchoolsData>> => {
    const mutationOptions: UseMutationOptions<PostSchoolsResponse, PostSchoolsError, Options<PostSchoolsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postSchools({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete School
 *
 * Delete school from database.
 * This will remove the school from all users but won't delete any user.
 *
 * `SchoolTypes` schools can not be deleted.
 *
 * **This endpoint is only usable by administrators**
 */
export const deleteSchoolsSchoolIdMutation = (options?: Partial<Options<DeleteSchoolsSchoolIdData>>): UseMutationOptions<DeleteSchoolsSchoolIdResponse, DeleteSchoolsSchoolIdError, Options<DeleteSchoolsSchoolIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteSchoolsSchoolIdResponse, DeleteSchoolsSchoolIdError, Options<DeleteSchoolsSchoolIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteSchoolsSchoolId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSchoolsSchoolIdQueryKey = (options: Options<GetSchoolsSchoolIdData>) => createQueryKey('getSchoolsSchoolId', options);

/**
 * Read School
 *
 * Return school with id from database as a dictionary.
 *
 * **This endpoint is only usable by administrators**
 */
export const getSchoolsSchoolIdOptions = (options: Options<GetSchoolsSchoolIdData>) => queryOptions<GetSchoolsSchoolIdResponse, GetSchoolsSchoolIdError, GetSchoolsSchoolIdResponse, ReturnType<typeof getSchoolsSchoolIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSchoolsSchoolId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSchoolsSchoolIdQueryKey(options)
});

/**
 * Update School
 *
 * Update the name or the description of a school.
 *
 * **This endpoint is only usable by administrators**
 */
export const patchSchoolsSchoolIdMutation = (options?: Partial<Options<PatchSchoolsSchoolIdData>>): UseMutationOptions<PatchSchoolsSchoolIdResponse, PatchSchoolsSchoolIdError, Options<PatchSchoolsSchoolIdData>> => {
    const mutationOptions: UseMutationOptions<PatchSchoolsSchoolIdResponse, PatchSchoolsSchoolIdError, Options<PatchSchoolsSchoolIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchSchoolsSchoolId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembershipsQueryKey = (options?: Options<GetMembershipsData>) => createQueryKey('getMemberships', options);

/**
 * Read Associations Memberships
 *
 * Return all memberships from database as a list of dictionaries
 */
export const getMembershipsOptions = (options?: Options<GetMembershipsData>) => queryOptions<GetMembershipsResponse, DefaultError, GetMembershipsResponse, ReturnType<typeof getMembershipsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMemberships({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMembershipsQueryKey(options)
});

/**
 * Create Association Membership
 *
 * Create a new membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const postMembershipsMutation = (options?: Partial<Options<PostMembershipsData>>): UseMutationOptions<PostMembershipsResponse, PostMembershipsError, Options<PostMembershipsData>> => {
    const mutationOptions: UseMutationOptions<PostMembershipsResponse, PostMembershipsError, Options<PostMembershipsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMemberships({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembershipsAssociationMembershipIdMembersQueryKey = (options: Options<GetMembershipsAssociationMembershipIdMembersData>) => createQueryKey('getMembershipsAssociationMembershipIdMembers', options);

/**
 * Read Association Membership
 *
 * Return membership with the given ID.
 *
 * **This endpoint is only usable by ECL members**
 */
export const getMembershipsAssociationMembershipIdMembersOptions = (options: Options<GetMembershipsAssociationMembershipIdMembersData>) => queryOptions<GetMembershipsAssociationMembershipIdMembersResponse, GetMembershipsAssociationMembershipIdMembersError, GetMembershipsAssociationMembershipIdMembersResponse, ReturnType<typeof getMembershipsAssociationMembershipIdMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMembershipsAssociationMembershipIdMembers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMembershipsAssociationMembershipIdMembersQueryKey(options)
});

/**
 * Delete Association Membership
 *
 * Delete a membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const deleteMembershipsAssociationMembershipIdMutation = (options?: Partial<Options<DeleteMembershipsAssociationMembershipIdData>>): UseMutationOptions<DeleteMembershipsAssociationMembershipIdResponse, DeleteMembershipsAssociationMembershipIdError, Options<DeleteMembershipsAssociationMembershipIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteMembershipsAssociationMembershipIdResponse, DeleteMembershipsAssociationMembershipIdError, Options<DeleteMembershipsAssociationMembershipIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMembershipsAssociationMembershipId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Association Membership
 *
 * Update a membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const patchMembershipsAssociationMembershipIdMutation = (options?: Partial<Options<PatchMembershipsAssociationMembershipIdData>>): UseMutationOptions<PatchMembershipsAssociationMembershipIdResponse, PatchMembershipsAssociationMembershipIdError, Options<PatchMembershipsAssociationMembershipIdData>> => {
    const mutationOptions: UseMutationOptions<PatchMembershipsAssociationMembershipIdResponse, PatchMembershipsAssociationMembershipIdError, Options<PatchMembershipsAssociationMembershipIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchMembershipsAssociationMembershipId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembershipsUsersUserIdQueryKey = (options: Options<GetMembershipsUsersUserIdData>) => createQueryKey('getMembershipsUsersUserId', options);

/**
 * Read User Memberships
 *
 * Return all memberships for a user.
 */
export const getMembershipsUsersUserIdOptions = (options: Options<GetMembershipsUsersUserIdData>) => queryOptions<GetMembershipsUsersUserIdResponse, GetMembershipsUsersUserIdError, GetMembershipsUsersUserIdResponse, ReturnType<typeof getMembershipsUsersUserIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMembershipsUsersUserId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMembershipsUsersUserIdQueryKey(options)
});

/**
 * Create User Membership
 *
 * Create a new user membership.
 *
 * **This endpoint is only usable by administrators and membership managers**
 */
export const postMembershipsUsersUserIdMutation = (options?: Partial<Options<PostMembershipsUsersUserIdData>>): UseMutationOptions<PostMembershipsUsersUserIdResponse, PostMembershipsUsersUserIdError, Options<PostMembershipsUsersUserIdData>> => {
    const mutationOptions: UseMutationOptions<PostMembershipsUsersUserIdResponse, PostMembershipsUsersUserIdError, Options<PostMembershipsUsersUserIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMembershipsUsersUserId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMembershipsUsersUserIdAssociationMembershipIdQueryKey = (options: Options<GetMembershipsUsersUserIdAssociationMembershipIdData>) => createQueryKey('getMembershipsUsersUserIdAssociationMembershipId', options);

/**
 * Read User Association Membership History
 *
 * Return all user memberships for a specific association membership for a user.
 *
 * **This endpoint is only usable by administrators and membership managers**
 */
export const getMembershipsUsersUserIdAssociationMembershipIdOptions = (options: Options<GetMembershipsUsersUserIdAssociationMembershipIdData>) => queryOptions<GetMembershipsUsersUserIdAssociationMembershipIdResponse, GetMembershipsUsersUserIdAssociationMembershipIdError, GetMembershipsUsersUserIdAssociationMembershipIdResponse, ReturnType<typeof getMembershipsUsersUserIdAssociationMembershipIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMembershipsUsersUserIdAssociationMembershipId({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMembershipsUsersUserIdAssociationMembershipIdQueryKey(options)
});

/**
 * Add Batch Membership
 *
 * Add a batch of user to a membership.
 *
 * Return the list of unknown users whose email is not in the database.
 *
 * **User must be an administrator or a membership manager to use this endpoint.**
 */
export const postMembershipsAssociationMembershipIdAddBatchMutation = (options?: Partial<Options<PostMembershipsAssociationMembershipIdAddBatchData>>): UseMutationOptions<PostMembershipsAssociationMembershipIdAddBatchResponse, PostMembershipsAssociationMembershipIdAddBatchError, Options<PostMembershipsAssociationMembershipIdAddBatchData>> => {
    const mutationOptions: UseMutationOptions<PostMembershipsAssociationMembershipIdAddBatchResponse, PostMembershipsAssociationMembershipIdAddBatchError, Options<PostMembershipsAssociationMembershipIdAddBatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postMembershipsAssociationMembershipIdAddBatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete User Membership
 *
 * Delete a user membership.
 *
 * **This endpoint is only usable by administrators and membership managers**
 */
export const deleteMembershipsUsersMembershipIdMutation = (options?: Partial<Options<DeleteMembershipsUsersMembershipIdData>>): UseMutationOptions<DeleteMembershipsUsersMembershipIdResponse, DeleteMembershipsUsersMembershipIdError, Options<DeleteMembershipsUsersMembershipIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteMembershipsUsersMembershipIdResponse, DeleteMembershipsUsersMembershipIdError, Options<DeleteMembershipsUsersMembershipIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMembershipsUsersMembershipId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update User Membership
 *
 * Update a user membership.
 *
 * **This endpoint is only usable by administrators and membership managers**
 */
export const patchMembershipsUsersMembershipIdMutation = (options?: Partial<Options<PatchMembershipsUsersMembershipIdData>>): UseMutationOptions<PatchMembershipsUsersMembershipIdResponse, PatchMembershipsUsersMembershipIdError, Options<PatchMembershipsUsersMembershipIdData>> => {
    const mutationOptions: UseMutationOptions<PatchMembershipsUsersMembershipIdResponse, PatchMembershipsUsersMembershipIdError, Options<PatchMembershipsUsersMembershipIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchMembershipsUsersMembershipId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Webhook
 */
export const postPaymentHelloassoWebhookMutation = (options?: Partial<Options<PostPaymentHelloassoWebhookData>>): UseMutationOptions<PostPaymentHelloassoWebhookResponse, DefaultError, Options<PostPaymentHelloassoWebhookData>> => {
    const mutationOptions: UseMutationOptions<PostPaymentHelloassoWebhookResponse, DefaultError, Options<PostPaymentHelloassoWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPaymentHelloassoWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
